# Auto-generated by gen_msp_messages.py. Do not edit by hand.
from __future__ import annotations
from dataclasses import dataclass, field
from typing import Any, Dict, List, Tuple, Optional
import struct

CTYPE = {
    'uint8_t': ('<B', 0, 255, 1),
    'int8_t': ('<b', -128, 127, 1),
    'uint16_t': ('<H', 0, 65535, 2),
    'int16_t': ('<h', -32768, 32767, 2),
    'uint32_t': ('<I', 0, 4294967295, 4),
    'int32_t': ('<i', -2147483648, 2147483647, 4),
    'uint64_t': ('<Q', 0, 18446744073709551615, 8),
    'int64_t': ('<q', -9223372036854775808, 9223372036854775807, 8),
    'float': ('<f', None, None, 4),
}

def _assert_int_in_range(name: str, v: int, lo, hi):
    if not isinstance(v, int):
        raise TypeError(f"{name} must be int, got {type(v).__name__}")
    if lo is not None and v < lo:
        raise ValueError(f"{name} {v} < {lo}")
    if hi is not None and v > hi:
        raise ValueError(f"{name} {v} > {hi}")

def _pack_scalar(ctype: str, name: str, v: Any) -> bytes:
    if ctype == 'char':
        raise RuntimeError('scalar char must be handled by array logic')
    fmt, lo, hi, _ = CTYPE[ctype]
    if lo is not None:
        _assert_int_in_range(name, v, lo, hi)
    elif ctype == 'float':
        if not isinstance(v, (int, float)):
            raise TypeError(f"{name} must be float compatible")
        v = float(v)
    return struct.pack(fmt, v)

def _unpack_scalar(ctype: str, name: str, data: bytes):
    if ctype == 'char':
        raise RuntimeError('scalar char must be handled by array logic')
    fmt, _, _, size = CTYPE[ctype]
    if len(data) < size:
        raise ValueError(f'not enough data to unpack {name} ({ctype}) need {size} have {len(data)}')
    v = struct.unpack(fmt, data[:size])[0]
    return v, data[size:]


class MspApiVersion:
    CODE = 1
    MSPV = 1
    """Provides the MSP protocol version and the INAV API version."""
    @dataclass
    class Reply:
        mspProtocolVersion: int = 0
        apiVersionMajor: int = 0
        apiVersionMinor: int = 0

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.mspProtocolVersion
            out += _pack_scalar('uint8_t', 'mspProtocolVersion', _v)
            _v = self.apiVersionMajor
            out += _pack_scalar('uint8_t', 'apiVersionMajor', _v)
            _v = self.apiVersionMinor
            out += _pack_scalar('uint8_t', 'apiVersionMinor', _v)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Reply', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _val, _data = _unpack_scalar('uint8_t', 'mspProtocolVersion', _data)
            _kwargs['mspProtocolVersion'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'apiVersionMajor', _data)
            _kwargs['apiVersionMajor'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'apiVersionMinor', _data)
            _kwargs['apiVersionMinor'] = _val
            return cls(**_kwargs), _data


class MspFcVariant:
    CODE = 2
    MSPV = 1
    """Identifies the flight controller firmware variant (e.g., INAV, Betaflight)."""
    @dataclass
    class Reply:
        fcVariantIdentifier: str = ''

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.fcVariantIdentifier
            if not isinstance(_v, str):
                raise TypeError('fcVariantIdentifier must be str')
            _b = _v.encode('ascii', errors='ignore')
            if len(_b) > 4:
                raise ValueError('fcVariantIdentifier length {} > 4'.format(len(_b)))
            out += _b.ljust(4, b'\x00')
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Reply', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            if len(_data) < 4:
                raise ValueError('not enough data to unpack fcVariantIdentifier')
            _raw = _data[:4]
            _kwargs['fcVariantIdentifier'] = _raw.split(b'\x00', 1)[0].decode('ascii', errors='ignore')
            _data = _data[4:]
            return cls(**_kwargs), _data


class MspFcVersion:
    CODE = 3
    MSPV = 1
    """Provides the specific version number of the flight controller firmware."""
    @dataclass
    class Reply:
        fcVersionMajor: int = 0
        fcVersionMinor: int = 0
        fcVersionPatch: int = 0

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.fcVersionMajor
            out += _pack_scalar('uint8_t', 'fcVersionMajor', _v)
            _v = self.fcVersionMinor
            out += _pack_scalar('uint8_t', 'fcVersionMinor', _v)
            _v = self.fcVersionPatch
            out += _pack_scalar('uint8_t', 'fcVersionPatch', _v)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Reply', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _val, _data = _unpack_scalar('uint8_t', 'fcVersionMajor', _data)
            _kwargs['fcVersionMajor'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'fcVersionMinor', _data)
            _kwargs['fcVersionMinor'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'fcVersionPatch', _data)
            _kwargs['fcVersionPatch'] = _val
            return cls(**_kwargs), _data


class MspBoardInfo:
    CODE = 4
    MSPV = 1
    """Provides information about the specific hardware board and its capabilities."""
    @dataclass
    class Reply:
        boardIdentifier: str = ''
        hardwareRevision: int = 0
        osdSupport: int = 0
        commCapabilities: int = 0
        targetNameLength: int = 0
        targetName: bytes = b''

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.boardIdentifier
            if not isinstance(_v, str):
                raise TypeError('boardIdentifier must be str')
            _b = _v.encode('ascii', errors='ignore')
            if len(_b) > 4:
                raise ValueError('boardIdentifier length {} > 4'.format(len(_b)))
            out += _b.ljust(4, b'\x00')
            _v = self.hardwareRevision
            out += _pack_scalar('uint16_t', 'hardwareRevision', _v)
            _v = self.osdSupport
            out += _pack_scalar('uint8_t', 'osdSupport', _v)
            _v = self.commCapabilities
            out += _pack_scalar('uint8_t', 'commCapabilities', _v)
            _v = self.targetNameLength
            out += _pack_scalar('uint8_t', 'targetNameLength', _v)
            _v = self.targetName
            if not isinstance(_v, (bytes, bytearray)):
                raise TypeError('targetName must be bytes for variable length char array')
            out += _v
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Reply', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            if len(_data) < 4:
                raise ValueError('not enough data to unpack boardIdentifier')
            _raw = _data[:4]
            _kwargs['boardIdentifier'] = _raw.split(b'\x00', 1)[0].decode('ascii', errors='ignore')
            _data = _data[4:]
            _val, _data = _unpack_scalar('uint16_t', 'hardwareRevision', _data)
            _kwargs['hardwareRevision'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'osdSupport', _data)
            _kwargs['osdSupport'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'commCapabilities', _data)
            _kwargs['commCapabilities'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'targetNameLength', _data)
            _kwargs['targetNameLength'] = _val
            _len = hints.get('targetName_len', len(_data))
            if len(_data) < _len:
                raise ValueError('not enough data to unpack targetName variable bytes')
            _kwargs['targetName'] = _data[:_len]
            _data = _data[_len:]
            return cls(**_kwargs), _data


class MspBuildInfo:
    CODE = 5
    MSPV = 1
    """Provides build date, time, and Git revision of the firmware."""
    @dataclass
    class Reply:
        buildDate: str = ''
        buildTime: str = ''
        gitRevision: str = ''

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.buildDate
            if not isinstance(_v, str):
                raise TypeError('buildDate must be str')
            _b = _v.encode('ascii', errors='ignore')
            if len(_b) > 11:
                raise ValueError('buildDate length {} > 11'.format(len(_b)))
            out += _b.ljust(11, b'\x00')
            _v = self.buildTime
            if not isinstance(_v, str):
                raise TypeError('buildTime must be str')
            _b = _v.encode('ascii', errors='ignore')
            if len(_b) > 8:
                raise ValueError('buildTime length {} > 8'.format(len(_b)))
            out += _b.ljust(8, b'\x00')
            _v = self.gitRevision
            if not isinstance(_v, str):
                raise TypeError('gitRevision must be str')
            _b = _v.encode('ascii', errors='ignore')
            if len(_b) > 8:
                raise ValueError('gitRevision length {} > 8'.format(len(_b)))
            out += _b.ljust(8, b'\x00')
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Reply', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            if len(_data) < 11:
                raise ValueError('not enough data to unpack buildDate')
            _raw = _data[:11]
            _kwargs['buildDate'] = _raw.split(b'\x00', 1)[0].decode('ascii', errors='ignore')
            _data = _data[11:]
            if len(_data) < 8:
                raise ValueError('not enough data to unpack buildTime')
            _raw = _data[:8]
            _kwargs['buildTime'] = _raw.split(b'\x00', 1)[0].decode('ascii', errors='ignore')
            _data = _data[8:]
            if len(_data) < 8:
                raise ValueError('not enough data to unpack gitRevision')
            _raw = _data[:8]
            _kwargs['gitRevision'] = _raw.split(b'\x00', 1)[0].decode('ascii', errors='ignore')
            _data = _data[8:]
            return cls(**_kwargs), _data


class MspInavPid:
    CODE = 6
    MSPV = 1
    """Retrieves legacy INAV-specific PID controller related settings. Many fields are now obsolete or placeholders."""
    @dataclass
    class Reply:
        legacyAsyncProcessing: int = 0
        legacyAsyncValue1: int = 0
        legacyAsyncValue2: int = 0
        headingHoldRateLimit: int = 0
        headingHoldLpfFreq: int = 0
        legacyYawJumpLimit: int = 0
        legacyGyroLpf: int = 0
        accLpfHz: int = 0
        reserved1: int = 0
        reserved2: int = 0
        reserved3: int = 0
        reserved4: int = 0

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.legacyAsyncProcessing
            out += _pack_scalar('uint8_t', 'legacyAsyncProcessing', _v)
            _v = self.legacyAsyncValue1
            out += _pack_scalar('uint16_t', 'legacyAsyncValue1', _v)
            _v = self.legacyAsyncValue2
            out += _pack_scalar('int16_t', 'legacyAsyncValue2', _v)
            _v = self.headingHoldRateLimit
            out += _pack_scalar('uint8_t', 'headingHoldRateLimit', _v)
            _v = self.headingHoldLpfFreq
            out += _pack_scalar('uint8_t', 'headingHoldLpfFreq', _v)
            _v = self.legacyYawJumpLimit
            out += _pack_scalar('int16_t', 'legacyYawJumpLimit', _v)
            _v = self.legacyGyroLpf
            out += _pack_scalar('uint8_t', 'legacyGyroLpf', _v)
            _v = self.accLpfHz
            out += _pack_scalar('uint8_t', 'accLpfHz', _v)
            _v = self.reserved1
            out += _pack_scalar('uint8_t', 'reserved1', _v)
            _v = self.reserved2
            out += _pack_scalar('uint8_t', 'reserved2', _v)
            _v = self.reserved3
            out += _pack_scalar('uint8_t', 'reserved3', _v)
            _v = self.reserved4
            out += _pack_scalar('uint8_t', 'reserved4', _v)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Reply', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _val, _data = _unpack_scalar('uint8_t', 'legacyAsyncProcessing', _data)
            _kwargs['legacyAsyncProcessing'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'legacyAsyncValue1', _data)
            _kwargs['legacyAsyncValue1'] = _val
            _val, _data = _unpack_scalar('int16_t', 'legacyAsyncValue2', _data)
            _kwargs['legacyAsyncValue2'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'headingHoldRateLimit', _data)
            _kwargs['headingHoldRateLimit'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'headingHoldLpfFreq', _data)
            _kwargs['headingHoldLpfFreq'] = _val
            _val, _data = _unpack_scalar('int16_t', 'legacyYawJumpLimit', _data)
            _kwargs['legacyYawJumpLimit'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'legacyGyroLpf', _data)
            _kwargs['legacyGyroLpf'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'accLpfHz', _data)
            _kwargs['accLpfHz'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'reserved1', _data)
            _kwargs['reserved1'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'reserved2', _data)
            _kwargs['reserved2'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'reserved3', _data)
            _kwargs['reserved3'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'reserved4', _data)
            _kwargs['reserved4'] = _val
            return cls(**_kwargs), _data


class MspSetInavPid:
    CODE = 7
    MSPV = 1
    """Sets legacy INAV-specific PID controller related settings."""
    @dataclass
    class Request:
        legacyAsyncProcessing: int = 0
        legacyAsyncValue1: int = 0
        legacyAsyncValue2: int = 0
        headingHoldRateLimit: int = 0
        headingHoldLpfFreq: int = 0
        legacyYawJumpLimit: int = 0
        legacyGyroLpf: int = 0
        accLpfHz: int = 0
        reserved1: int = 0
        reserved2: int = 0
        reserved3: int = 0
        reserved4: int = 0

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.legacyAsyncProcessing
            out += _pack_scalar('uint8_t', 'legacyAsyncProcessing', _v)
            _v = self.legacyAsyncValue1
            out += _pack_scalar('int16_t', 'legacyAsyncValue1', _v)
            _v = self.legacyAsyncValue2
            out += _pack_scalar('int16_t', 'legacyAsyncValue2', _v)
            _v = self.headingHoldRateLimit
            out += _pack_scalar('uint8_t', 'headingHoldRateLimit', _v)
            _v = self.headingHoldLpfFreq
            out += _pack_scalar('uint8_t', 'headingHoldLpfFreq', _v)
            _v = self.legacyYawJumpLimit
            out += _pack_scalar('int16_t', 'legacyYawJumpLimit', _v)
            _v = self.legacyGyroLpf
            out += _pack_scalar('uint8_t', 'legacyGyroLpf', _v)
            _v = self.accLpfHz
            out += _pack_scalar('uint8_t', 'accLpfHz', _v)
            _v = self.reserved1
            out += _pack_scalar('uint8_t', 'reserved1', _v)
            _v = self.reserved2
            out += _pack_scalar('uint8_t', 'reserved2', _v)
            _v = self.reserved3
            out += _pack_scalar('uint8_t', 'reserved3', _v)
            _v = self.reserved4
            out += _pack_scalar('uint8_t', 'reserved4', _v)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Request', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _val, _data = _unpack_scalar('uint8_t', 'legacyAsyncProcessing', _data)
            _kwargs['legacyAsyncProcessing'] = _val
            _val, _data = _unpack_scalar('int16_t', 'legacyAsyncValue1', _data)
            _kwargs['legacyAsyncValue1'] = _val
            _val, _data = _unpack_scalar('int16_t', 'legacyAsyncValue2', _data)
            _kwargs['legacyAsyncValue2'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'headingHoldRateLimit', _data)
            _kwargs['headingHoldRateLimit'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'headingHoldLpfFreq', _data)
            _kwargs['headingHoldLpfFreq'] = _val
            _val, _data = _unpack_scalar('int16_t', 'legacyYawJumpLimit', _data)
            _kwargs['legacyYawJumpLimit'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'legacyGyroLpf', _data)
            _kwargs['legacyGyroLpf'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'accLpfHz', _data)
            _kwargs['accLpfHz'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'reserved1', _data)
            _kwargs['reserved1'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'reserved2', _data)
            _kwargs['reserved2'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'reserved3', _data)
            _kwargs['reserved3'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'reserved4', _data)
            _kwargs['reserved4'] = _val
            return cls(**_kwargs), _data


class MspName:
    CODE = 10
    MSPV = 1
    """Returns the user-defined craft name."""
    @dataclass
    class Reply:
        craftName: bytes = b''

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.craftName
            if not isinstance(_v, (bytes, bytearray)):
                raise TypeError('craftName must be bytes for variable length char array')
            out += _v
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Reply', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _len = hints.get('craftName_len', len(_data))
            if len(_data) < _len:
                raise ValueError('not enough data to unpack craftName variable bytes')
            _kwargs['craftName'] = _data[:_len]
            _data = _data[_len:]
            return cls(**_kwargs), _data


class MspSetName:
    CODE = 11
    MSPV = 1
    """Sets the user-defined craft name."""
    @dataclass
    class Request:
        craftName: bytes = b''

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.craftName
            if not isinstance(_v, (bytes, bytearray)):
                raise TypeError('craftName must be bytes for variable length char array')
            out += _v
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Request', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _len = hints.get('craftName_len', len(_data))
            if len(_data) < _len:
                raise ValueError('not enough data to unpack craftName variable bytes')
            _kwargs['craftName'] = _data[:_len]
            _data = _data[_len:]
            return cls(**_kwargs), _data


class MspNavPoshold:
    CODE = 12
    MSPV = 1
    """Retrieves navigation position hold and general manual/auto flight parameters. Some parameters depend on the platform type (Multirotor vs Fixed Wing)."""
    @dataclass
    class Reply:
        userControlMode: int = 0
        maxAutoSpeed: int = 0
        maxAutoClimbRate: int = 0
        maxManualSpeed: int = 0
        maxManualClimbRate: int = 0
        mcMaxBankAngle: int = 0
        mcAltHoldThrottleType: int = 0
        mcHoverThrottle: int = 0

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.userControlMode
            out += _pack_scalar('uint8_t', 'userControlMode', _v)
            _v = self.maxAutoSpeed
            out += _pack_scalar('uint16_t', 'maxAutoSpeed', _v)
            _v = self.maxAutoClimbRate
            out += _pack_scalar('uint16_t', 'maxAutoClimbRate', _v)
            _v = self.maxManualSpeed
            out += _pack_scalar('uint16_t', 'maxManualSpeed', _v)
            _v = self.maxManualClimbRate
            out += _pack_scalar('uint16_t', 'maxManualClimbRate', _v)
            _v = self.mcMaxBankAngle
            out += _pack_scalar('uint8_t', 'mcMaxBankAngle', _v)
            _v = self.mcAltHoldThrottleType
            out += _pack_scalar('uint8_t', 'mcAltHoldThrottleType', _v)
            _v = self.mcHoverThrottle
            out += _pack_scalar('uint16_t', 'mcHoverThrottle', _v)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Reply', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _val, _data = _unpack_scalar('uint8_t', 'userControlMode', _data)
            _kwargs['userControlMode'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'maxAutoSpeed', _data)
            _kwargs['maxAutoSpeed'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'maxAutoClimbRate', _data)
            _kwargs['maxAutoClimbRate'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'maxManualSpeed', _data)
            _kwargs['maxManualSpeed'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'maxManualClimbRate', _data)
            _kwargs['maxManualClimbRate'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'mcMaxBankAngle', _data)
            _kwargs['mcMaxBankAngle'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'mcAltHoldThrottleType', _data)
            _kwargs['mcAltHoldThrottleType'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'mcHoverThrottle', _data)
            _kwargs['mcHoverThrottle'] = _val
            return cls(**_kwargs), _data


class MspSetNavPoshold:
    CODE = 13
    MSPV = 1
    """Sets navigation position hold and general manual/auto flight parameters."""
    @dataclass
    class Request:
        userControlMode: int = 0
        maxAutoSpeed: int = 0
        maxAutoClimbRate: int = 0
        maxManualSpeed: int = 0
        maxManualClimbRate: int = 0
        mcMaxBankAngle: int = 0
        mcAltHoldThrottleType: int = 0
        mcHoverThrottle: int = 0

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.userControlMode
            out += _pack_scalar('uint8_t', 'userControlMode', _v)
            _v = self.maxAutoSpeed
            out += _pack_scalar('uint16_t', 'maxAutoSpeed', _v)
            _v = self.maxAutoClimbRate
            out += _pack_scalar('uint16_t', 'maxAutoClimbRate', _v)
            _v = self.maxManualSpeed
            out += _pack_scalar('uint16_t', 'maxManualSpeed', _v)
            _v = self.maxManualClimbRate
            out += _pack_scalar('uint16_t', 'maxManualClimbRate', _v)
            _v = self.mcMaxBankAngle
            out += _pack_scalar('uint8_t', 'mcMaxBankAngle', _v)
            _v = self.mcAltHoldThrottleType
            out += _pack_scalar('uint8_t', 'mcAltHoldThrottleType', _v)
            _v = self.mcHoverThrottle
            out += _pack_scalar('uint16_t', 'mcHoverThrottle', _v)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Request', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _val, _data = _unpack_scalar('uint8_t', 'userControlMode', _data)
            _kwargs['userControlMode'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'maxAutoSpeed', _data)
            _kwargs['maxAutoSpeed'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'maxAutoClimbRate', _data)
            _kwargs['maxAutoClimbRate'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'maxManualSpeed', _data)
            _kwargs['maxManualSpeed'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'maxManualClimbRate', _data)
            _kwargs['maxManualClimbRate'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'mcMaxBankAngle', _data)
            _kwargs['mcMaxBankAngle'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'mcAltHoldThrottleType', _data)
            _kwargs['mcAltHoldThrottleType'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'mcHoverThrottle', _data)
            _kwargs['mcHoverThrottle'] = _val
            return cls(**_kwargs), _data


class MspCalibrationData:
    CODE = 14
    MSPV = 1
    """Retrieves sensor calibration data (Accelerometer zero/gain, Magnetometer zero/gain, Optical Flow scale)."""
    @dataclass
    class Reply:
        accCalibAxisFlags: int = 0
        accZeroX: int = 0
        accZeroY: int = 0
        accZeroZ: int = 0
        accGainX: int = 0
        accGainY: int = 0
        accGainZ: int = 0
        magZeroX: int = 0
        magZeroY: int = 0
        magZeroZ: int = 0
        opflowScale: int = 0
        magGainX: int = 0
        magGainY: int = 0
        magGainZ: int = 0

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.accCalibAxisFlags
            out += _pack_scalar('uint8_t', 'accCalibAxisFlags', _v)
            _v = self.accZeroX
            out += _pack_scalar('int16_t', 'accZeroX', _v)
            _v = self.accZeroY
            out += _pack_scalar('int16_t', 'accZeroY', _v)
            _v = self.accZeroZ
            out += _pack_scalar('int16_t', 'accZeroZ', _v)
            _v = self.accGainX
            out += _pack_scalar('int16_t', 'accGainX', _v)
            _v = self.accGainY
            out += _pack_scalar('int16_t', 'accGainY', _v)
            _v = self.accGainZ
            out += _pack_scalar('int16_t', 'accGainZ', _v)
            _v = self.magZeroX
            out += _pack_scalar('int16_t', 'magZeroX', _v)
            _v = self.magZeroY
            out += _pack_scalar('int16_t', 'magZeroY', _v)
            _v = self.magZeroZ
            out += _pack_scalar('int16_t', 'magZeroZ', _v)
            _v = self.opflowScale
            out += _pack_scalar('uint16_t', 'opflowScale', _v)
            _v = self.magGainX
            out += _pack_scalar('int16_t', 'magGainX', _v)
            _v = self.magGainY
            out += _pack_scalar('int16_t', 'magGainY', _v)
            _v = self.magGainZ
            out += _pack_scalar('int16_t', 'magGainZ', _v)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Reply', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _val, _data = _unpack_scalar('uint8_t', 'accCalibAxisFlags', _data)
            _kwargs['accCalibAxisFlags'] = _val
            _val, _data = _unpack_scalar('int16_t', 'accZeroX', _data)
            _kwargs['accZeroX'] = _val
            _val, _data = _unpack_scalar('int16_t', 'accZeroY', _data)
            _kwargs['accZeroY'] = _val
            _val, _data = _unpack_scalar('int16_t', 'accZeroZ', _data)
            _kwargs['accZeroZ'] = _val
            _val, _data = _unpack_scalar('int16_t', 'accGainX', _data)
            _kwargs['accGainX'] = _val
            _val, _data = _unpack_scalar('int16_t', 'accGainY', _data)
            _kwargs['accGainY'] = _val
            _val, _data = _unpack_scalar('int16_t', 'accGainZ', _data)
            _kwargs['accGainZ'] = _val
            _val, _data = _unpack_scalar('int16_t', 'magZeroX', _data)
            _kwargs['magZeroX'] = _val
            _val, _data = _unpack_scalar('int16_t', 'magZeroY', _data)
            _kwargs['magZeroY'] = _val
            _val, _data = _unpack_scalar('int16_t', 'magZeroZ', _data)
            _kwargs['magZeroZ'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'opflowScale', _data)
            _kwargs['opflowScale'] = _val
            _val, _data = _unpack_scalar('int16_t', 'magGainX', _data)
            _kwargs['magGainX'] = _val
            _val, _data = _unpack_scalar('int16_t', 'magGainY', _data)
            _kwargs['magGainY'] = _val
            _val, _data = _unpack_scalar('int16_t', 'magGainZ', _data)
            _kwargs['magGainZ'] = _val
            return cls(**_kwargs), _data


class MspSetCalibrationData:
    CODE = 15
    MSPV = 1
    """Sets sensor calibration data."""
    @dataclass
    class Request:
        accZeroX: int = 0
        accZeroY: int = 0
        accZeroZ: int = 0
        accGainX: int = 0
        accGainY: int = 0
        accGainZ: int = 0
        magZeroX: int = 0
        magZeroY: int = 0
        magZeroZ: int = 0
        opflowScale: int = 0
        magGainX: int = 0
        magGainY: int = 0
        magGainZ: int = 0

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.accZeroX
            out += _pack_scalar('int16_t', 'accZeroX', _v)
            _v = self.accZeroY
            out += _pack_scalar('int16_t', 'accZeroY', _v)
            _v = self.accZeroZ
            out += _pack_scalar('int16_t', 'accZeroZ', _v)
            _v = self.accGainX
            out += _pack_scalar('int16_t', 'accGainX', _v)
            _v = self.accGainY
            out += _pack_scalar('int16_t', 'accGainY', _v)
            _v = self.accGainZ
            out += _pack_scalar('int16_t', 'accGainZ', _v)
            _v = self.magZeroX
            out += _pack_scalar('int16_t', 'magZeroX', _v)
            _v = self.magZeroY
            out += _pack_scalar('int16_t', 'magZeroY', _v)
            _v = self.magZeroZ
            out += _pack_scalar('int16_t', 'magZeroZ', _v)
            _v = self.opflowScale
            out += _pack_scalar('uint16_t', 'opflowScale', _v)
            _v = self.magGainX
            out += _pack_scalar('int16_t', 'magGainX', _v)
            _v = self.magGainY
            out += _pack_scalar('int16_t', 'magGainY', _v)
            _v = self.magGainZ
            out += _pack_scalar('int16_t', 'magGainZ', _v)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Request', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _val, _data = _unpack_scalar('int16_t', 'accZeroX', _data)
            _kwargs['accZeroX'] = _val
            _val, _data = _unpack_scalar('int16_t', 'accZeroY', _data)
            _kwargs['accZeroY'] = _val
            _val, _data = _unpack_scalar('int16_t', 'accZeroZ', _data)
            _kwargs['accZeroZ'] = _val
            _val, _data = _unpack_scalar('int16_t', 'accGainX', _data)
            _kwargs['accGainX'] = _val
            _val, _data = _unpack_scalar('int16_t', 'accGainY', _data)
            _kwargs['accGainY'] = _val
            _val, _data = _unpack_scalar('int16_t', 'accGainZ', _data)
            _kwargs['accGainZ'] = _val
            _val, _data = _unpack_scalar('int16_t', 'magZeroX', _data)
            _kwargs['magZeroX'] = _val
            _val, _data = _unpack_scalar('int16_t', 'magZeroY', _data)
            _kwargs['magZeroY'] = _val
            _val, _data = _unpack_scalar('int16_t', 'magZeroZ', _data)
            _kwargs['magZeroZ'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'opflowScale', _data)
            _kwargs['opflowScale'] = _val
            _val, _data = _unpack_scalar('int16_t', 'magGainX', _data)
            _kwargs['magGainX'] = _val
            _val, _data = _unpack_scalar('int16_t', 'magGainY', _data)
            _kwargs['magGainY'] = _val
            _val, _data = _unpack_scalar('int16_t', 'magGainZ', _data)
            _kwargs['magGainZ'] = _val
            return cls(**_kwargs), _data


class MspPositionEstimationConfig:
    CODE = 16
    MSPV = 1
    """Retrieves parameters related to the INAV position estimation fusion weights and GPS minimum satellite count."""
    @dataclass
    class Reply:
        weightZBaroP: int = 0
        weightZGPSP: int = 0
        weightZGPSV: int = 0
        weightXYGPSP: int = 0
        weightXYGPSV: int = 0
        minSats: int = 0
        useGPSVelNED: int = 0

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.weightZBaroP
            out += _pack_scalar('uint16_t', 'weightZBaroP', _v)
            _v = self.weightZGPSP
            out += _pack_scalar('uint16_t', 'weightZGPSP', _v)
            _v = self.weightZGPSV
            out += _pack_scalar('uint16_t', 'weightZGPSV', _v)
            _v = self.weightXYGPSP
            out += _pack_scalar('uint16_t', 'weightXYGPSP', _v)
            _v = self.weightXYGPSV
            out += _pack_scalar('uint16_t', 'weightXYGPSV', _v)
            _v = self.minSats
            out += _pack_scalar('uint8_t', 'minSats', _v)
            _v = self.useGPSVelNED
            out += _pack_scalar('uint8_t', 'useGPSVelNED', _v)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Reply', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _val, _data = _unpack_scalar('uint16_t', 'weightZBaroP', _data)
            _kwargs['weightZBaroP'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'weightZGPSP', _data)
            _kwargs['weightZGPSP'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'weightZGPSV', _data)
            _kwargs['weightZGPSV'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'weightXYGPSP', _data)
            _kwargs['weightXYGPSP'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'weightXYGPSV', _data)
            _kwargs['weightXYGPSV'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'minSats', _data)
            _kwargs['minSats'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'useGPSVelNED', _data)
            _kwargs['useGPSVelNED'] = _val
            return cls(**_kwargs), _data


class MspSetPositionEstimationConfig:
    CODE = 17
    MSPV = 1
    """Sets parameters related to the INAV position estimation fusion weights and GPS minimum satellite count."""
    @dataclass
    class Request:
        weightZBaroP: int = 0
        weightZGPSP: int = 0
        weightZGPSV: int = 0
        weightXYGPSP: int = 0
        weightXYGPSV: int = 0
        minSats: int = 0
        useGPSVelNED: int = 0

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.weightZBaroP
            out += _pack_scalar('uint16_t', 'weightZBaroP', _v)
            _v = self.weightZGPSP
            out += _pack_scalar('uint16_t', 'weightZGPSP', _v)
            _v = self.weightZGPSV
            out += _pack_scalar('uint16_t', 'weightZGPSV', _v)
            _v = self.weightXYGPSP
            out += _pack_scalar('uint16_t', 'weightXYGPSP', _v)
            _v = self.weightXYGPSV
            out += _pack_scalar('uint16_t', 'weightXYGPSV', _v)
            _v = self.minSats
            out += _pack_scalar('uint8_t', 'minSats', _v)
            _v = self.useGPSVelNED
            out += _pack_scalar('uint8_t', 'useGPSVelNED', _v)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Request', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _val, _data = _unpack_scalar('uint16_t', 'weightZBaroP', _data)
            _kwargs['weightZBaroP'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'weightZGPSP', _data)
            _kwargs['weightZGPSP'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'weightZGPSV', _data)
            _kwargs['weightZGPSV'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'weightXYGPSP', _data)
            _kwargs['weightXYGPSP'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'weightXYGPSV', _data)
            _kwargs['weightXYGPSV'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'minSats', _data)
            _kwargs['minSats'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'useGPSVelNED', _data)
            _kwargs['useGPSVelNED'] = _val
            return cls(**_kwargs), _data


class MspWpMissionLoad:
    CODE = 18
    MSPV = 1
    """Commands the FC to load the waypoint mission stored in non-volatile memory (e.g., EEPROM or FlashFS) into the active mission buffer."""
    @dataclass
    class Request:
        missionID: int = 0

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.missionID
            out += _pack_scalar('uint8_t', 'missionID', _v)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Request', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _val, _data = _unpack_scalar('uint8_t', 'missionID', _data)
            _kwargs['missionID'] = _val
            return cls(**_kwargs), _data


class MspWpMissionSave:
    CODE = 19
    MSPV = 1
    """Commands the FC to save the currently active waypoint mission from RAM to non-volatile memory (e.g., EEPROM or FlashFS)."""
    @dataclass
    class Request:
        missionID: int = 0

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.missionID
            out += _pack_scalar('uint8_t', 'missionID', _v)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Request', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _val, _data = _unpack_scalar('uint8_t', 'missionID', _data)
            _kwargs['missionID'] = _val
            return cls(**_kwargs), _data


class MspWpGetinfo:
    CODE = 20
    MSPV = 1
    """Retrieves information about the waypoint mission capabilities and the status of the currently loaded mission."""
    @dataclass
    class Reply:
        wpCapabilities: int = 0
        maxWaypoints: int = 0
        missionValid: int = 0
        waypointCount: int = 0

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.wpCapabilities
            out += _pack_scalar('uint8_t', 'wpCapabilities', _v)
            _v = self.maxWaypoints
            out += _pack_scalar('uint8_t', 'maxWaypoints', _v)
            _v = self.missionValid
            out += _pack_scalar('uint8_t', 'missionValid', _v)
            _v = self.waypointCount
            out += _pack_scalar('uint8_t', 'waypointCount', _v)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Reply', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _val, _data = _unpack_scalar('uint8_t', 'wpCapabilities', _data)
            _kwargs['wpCapabilities'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'maxWaypoints', _data)
            _kwargs['maxWaypoints'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'missionValid', _data)
            _kwargs['missionValid'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'waypointCount', _data)
            _kwargs['waypointCount'] = _val
            return cls(**_kwargs), _data


class MspRthAndLandConfig:
    CODE = 21
    MSPV = 1
    """Retrieves configuration parameters related to Return-to-Home (RTH) and automatic landing behaviors."""
    @dataclass
    class Reply:
        minRthDistance: int = 0
        rthClimbFirst: int = 0
        rthClimbIgnoreEmerg: int = 0
        rthTailFirst: int = 0
        rthAllowLanding: int = 0
        rthAltControlMode: int = 0
        rthAbortThreshold: int = 0
        rthAltitude: int = 0
        landMinAltVspd: int = 0
        landMaxAltVspd: int = 0
        landSlowdownMinAlt: int = 0
        landSlowdownMaxAlt: int = 0
        emergDescentRate: int = 0

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.minRthDistance
            out += _pack_scalar('uint16_t', 'minRthDistance', _v)
            _v = self.rthClimbFirst
            out += _pack_scalar('uint8_t', 'rthClimbFirst', _v)
            _v = self.rthClimbIgnoreEmerg
            out += _pack_scalar('uint8_t', 'rthClimbIgnoreEmerg', _v)
            _v = self.rthTailFirst
            out += _pack_scalar('uint8_t', 'rthTailFirst', _v)
            _v = self.rthAllowLanding
            out += _pack_scalar('uint8_t', 'rthAllowLanding', _v)
            _v = self.rthAltControlMode
            out += _pack_scalar('uint8_t', 'rthAltControlMode', _v)
            _v = self.rthAbortThreshold
            out += _pack_scalar('uint16_t', 'rthAbortThreshold', _v)
            _v = self.rthAltitude
            out += _pack_scalar('uint16_t', 'rthAltitude', _v)
            _v = self.landMinAltVspd
            out += _pack_scalar('uint16_t', 'landMinAltVspd', _v)
            _v = self.landMaxAltVspd
            out += _pack_scalar('uint16_t', 'landMaxAltVspd', _v)
            _v = self.landSlowdownMinAlt
            out += _pack_scalar('uint16_t', 'landSlowdownMinAlt', _v)
            _v = self.landSlowdownMaxAlt
            out += _pack_scalar('uint16_t', 'landSlowdownMaxAlt', _v)
            _v = self.emergDescentRate
            out += _pack_scalar('uint16_t', 'emergDescentRate', _v)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Reply', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _val, _data = _unpack_scalar('uint16_t', 'minRthDistance', _data)
            _kwargs['minRthDistance'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'rthClimbFirst', _data)
            _kwargs['rthClimbFirst'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'rthClimbIgnoreEmerg', _data)
            _kwargs['rthClimbIgnoreEmerg'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'rthTailFirst', _data)
            _kwargs['rthTailFirst'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'rthAllowLanding', _data)
            _kwargs['rthAllowLanding'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'rthAltControlMode', _data)
            _kwargs['rthAltControlMode'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'rthAbortThreshold', _data)
            _kwargs['rthAbortThreshold'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'rthAltitude', _data)
            _kwargs['rthAltitude'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'landMinAltVspd', _data)
            _kwargs['landMinAltVspd'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'landMaxAltVspd', _data)
            _kwargs['landMaxAltVspd'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'landSlowdownMinAlt', _data)
            _kwargs['landSlowdownMinAlt'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'landSlowdownMaxAlt', _data)
            _kwargs['landSlowdownMaxAlt'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'emergDescentRate', _data)
            _kwargs['emergDescentRate'] = _val
            return cls(**_kwargs), _data


class MspSetRthAndLandConfig:
    CODE = 22
    MSPV = 1
    """Sets configuration parameters related to Return-to-Home (RTH) and automatic landing behaviors."""
    @dataclass
    class Request:
        minRthDistance: int = 0
        rthClimbFirst: int = 0
        rthClimbIgnoreEmerg: int = 0
        rthTailFirst: int = 0
        rthAllowLanding: int = 0
        rthAltControlMode: int = 0
        rthAbortThreshold: int = 0
        rthAltitude: int = 0
        landMinAltVspd: int = 0
        landMaxAltVspd: int = 0
        landSlowdownMinAlt: int = 0
        landSlowdownMaxAlt: int = 0
        emergDescentRate: int = 0

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.minRthDistance
            out += _pack_scalar('uint16_t', 'minRthDistance', _v)
            _v = self.rthClimbFirst
            out += _pack_scalar('uint8_t', 'rthClimbFirst', _v)
            _v = self.rthClimbIgnoreEmerg
            out += _pack_scalar('uint8_t', 'rthClimbIgnoreEmerg', _v)
            _v = self.rthTailFirst
            out += _pack_scalar('uint8_t', 'rthTailFirst', _v)
            _v = self.rthAllowLanding
            out += _pack_scalar('uint8_t', 'rthAllowLanding', _v)
            _v = self.rthAltControlMode
            out += _pack_scalar('uint8_t', 'rthAltControlMode', _v)
            _v = self.rthAbortThreshold
            out += _pack_scalar('uint16_t', 'rthAbortThreshold', _v)
            _v = self.rthAltitude
            out += _pack_scalar('uint16_t', 'rthAltitude', _v)
            _v = self.landMinAltVspd
            out += _pack_scalar('uint16_t', 'landMinAltVspd', _v)
            _v = self.landMaxAltVspd
            out += _pack_scalar('uint16_t', 'landMaxAltVspd', _v)
            _v = self.landSlowdownMinAlt
            out += _pack_scalar('uint16_t', 'landSlowdownMinAlt', _v)
            _v = self.landSlowdownMaxAlt
            out += _pack_scalar('uint16_t', 'landSlowdownMaxAlt', _v)
            _v = self.emergDescentRate
            out += _pack_scalar('uint16_t', 'emergDescentRate', _v)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Request', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _val, _data = _unpack_scalar('uint16_t', 'minRthDistance', _data)
            _kwargs['minRthDistance'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'rthClimbFirst', _data)
            _kwargs['rthClimbFirst'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'rthClimbIgnoreEmerg', _data)
            _kwargs['rthClimbIgnoreEmerg'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'rthTailFirst', _data)
            _kwargs['rthTailFirst'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'rthAllowLanding', _data)
            _kwargs['rthAllowLanding'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'rthAltControlMode', _data)
            _kwargs['rthAltControlMode'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'rthAbortThreshold', _data)
            _kwargs['rthAbortThreshold'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'rthAltitude', _data)
            _kwargs['rthAltitude'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'landMinAltVspd', _data)
            _kwargs['landMinAltVspd'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'landMaxAltVspd', _data)
            _kwargs['landMaxAltVspd'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'landSlowdownMinAlt', _data)
            _kwargs['landSlowdownMinAlt'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'landSlowdownMaxAlt', _data)
            _kwargs['landSlowdownMaxAlt'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'emergDescentRate', _data)
            _kwargs['emergDescentRate'] = _val
            return cls(**_kwargs), _data


class MspFwConfig:
    CODE = 23
    MSPV = 1
    """Retrieves configuration parameters specific to Fixed Wing navigation."""
    @dataclass
    class Reply:
        cruiseThrottle: int = 0
        minThrottle: int = 0
        maxThrottle: int = 0
        maxBankAngle: int = 0
        maxClimbAngle: int = 0
        maxDiveAngle: int = 0
        pitchToThrottle: int = 0
        loiterRadius: int = 0

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.cruiseThrottle
            out += _pack_scalar('uint16_t', 'cruiseThrottle', _v)
            _v = self.minThrottle
            out += _pack_scalar('uint16_t', 'minThrottle', _v)
            _v = self.maxThrottle
            out += _pack_scalar('uint16_t', 'maxThrottle', _v)
            _v = self.maxBankAngle
            out += _pack_scalar('uint8_t', 'maxBankAngle', _v)
            _v = self.maxClimbAngle
            out += _pack_scalar('uint8_t', 'maxClimbAngle', _v)
            _v = self.maxDiveAngle
            out += _pack_scalar('uint8_t', 'maxDiveAngle', _v)
            _v = self.pitchToThrottle
            out += _pack_scalar('uint8_t', 'pitchToThrottle', _v)
            _v = self.loiterRadius
            out += _pack_scalar('uint16_t', 'loiterRadius', _v)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Reply', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _val, _data = _unpack_scalar('uint16_t', 'cruiseThrottle', _data)
            _kwargs['cruiseThrottle'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'minThrottle', _data)
            _kwargs['minThrottle'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'maxThrottle', _data)
            _kwargs['maxThrottle'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'maxBankAngle', _data)
            _kwargs['maxBankAngle'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'maxClimbAngle', _data)
            _kwargs['maxClimbAngle'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'maxDiveAngle', _data)
            _kwargs['maxDiveAngle'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'pitchToThrottle', _data)
            _kwargs['pitchToThrottle'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'loiterRadius', _data)
            _kwargs['loiterRadius'] = _val
            return cls(**_kwargs), _data


class MspSetFwConfig:
    CODE = 24
    MSPV = 1
    """Sets configuration parameters specific to Fixed Wing navigation."""
    @dataclass
    class Request:
        cruiseThrottle: int = 0
        minThrottle: int = 0
        maxThrottle: int = 0
        maxBankAngle: int = 0
        maxClimbAngle: int = 0
        maxDiveAngle: int = 0
        pitchToThrottle: int = 0
        loiterRadius: int = 0

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.cruiseThrottle
            out += _pack_scalar('uint16_t', 'cruiseThrottle', _v)
            _v = self.minThrottle
            out += _pack_scalar('uint16_t', 'minThrottle', _v)
            _v = self.maxThrottle
            out += _pack_scalar('uint16_t', 'maxThrottle', _v)
            _v = self.maxBankAngle
            out += _pack_scalar('uint8_t', 'maxBankAngle', _v)
            _v = self.maxClimbAngle
            out += _pack_scalar('uint8_t', 'maxClimbAngle', _v)
            _v = self.maxDiveAngle
            out += _pack_scalar('uint8_t', 'maxDiveAngle', _v)
            _v = self.pitchToThrottle
            out += _pack_scalar('uint8_t', 'pitchToThrottle', _v)
            _v = self.loiterRadius
            out += _pack_scalar('uint16_t', 'loiterRadius', _v)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Request', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _val, _data = _unpack_scalar('uint16_t', 'cruiseThrottle', _data)
            _kwargs['cruiseThrottle'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'minThrottle', _data)
            _kwargs['minThrottle'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'maxThrottle', _data)
            _kwargs['maxThrottle'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'maxBankAngle', _data)
            _kwargs['maxBankAngle'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'maxClimbAngle', _data)
            _kwargs['maxClimbAngle'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'maxDiveAngle', _data)
            _kwargs['maxDiveAngle'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'pitchToThrottle', _data)
            _kwargs['pitchToThrottle'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'loiterRadius', _data)
            _kwargs['loiterRadius'] = _val
            return cls(**_kwargs), _data


class MspModeRanges:
    CODE = 34
    MSPV = 1
    """Returns all defined mode activation ranges (aux channel assignments for flight modes)."""
    @dataclass
    class Reply:
        modePermanentId: int = 0
        auxChannelIndex: int = 0
        rangeStartStep: int = 0
        rangeEndStep: int = 0

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.modePermanentId
            out += _pack_scalar('uint8_t', 'modePermanentId', _v)
            _v = self.auxChannelIndex
            out += _pack_scalar('uint8_t', 'auxChannelIndex', _v)
            _v = self.rangeStartStep
            out += _pack_scalar('uint8_t', 'rangeStartStep', _v)
            _v = self.rangeEndStep
            out += _pack_scalar('uint8_t', 'rangeEndStep', _v)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Reply', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _val, _data = _unpack_scalar('uint8_t', 'modePermanentId', _data)
            _kwargs['modePermanentId'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'auxChannelIndex', _data)
            _kwargs['auxChannelIndex'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'rangeStartStep', _data)
            _kwargs['rangeStartStep'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'rangeEndStep', _data)
            _kwargs['rangeEndStep'] = _val
            return cls(**_kwargs), _data


class MspSetModeRange:
    CODE = 35
    MSPV = 1
    """Sets a single mode activation range by its index."""
    @dataclass
    class Request:
        rangeIndex: int = 0
        modePermanentId: int = 0
        auxChannelIndex: int = 0
        rangeStartStep: int = 0
        rangeEndStep: int = 0

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.rangeIndex
            out += _pack_scalar('uint8_t', 'rangeIndex', _v)
            _v = self.modePermanentId
            out += _pack_scalar('uint8_t', 'modePermanentId', _v)
            _v = self.auxChannelIndex
            out += _pack_scalar('uint8_t', 'auxChannelIndex', _v)
            _v = self.rangeStartStep
            out += _pack_scalar('uint8_t', 'rangeStartStep', _v)
            _v = self.rangeEndStep
            out += _pack_scalar('uint8_t', 'rangeEndStep', _v)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Request', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _val, _data = _unpack_scalar('uint8_t', 'rangeIndex', _data)
            _kwargs['rangeIndex'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'modePermanentId', _data)
            _kwargs['modePermanentId'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'auxChannelIndex', _data)
            _kwargs['auxChannelIndex'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'rangeStartStep', _data)
            _kwargs['rangeStartStep'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'rangeEndStep', _data)
            _kwargs['rangeEndStep'] = _val
            return cls(**_kwargs), _data


class MspFeature:
    CODE = 36
    MSPV = 1
    """Returns a bitmask of enabled features."""
    @dataclass
    class Reply:
        featureMask: int = 0

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.featureMask
            out += _pack_scalar('uint32_t', 'featureMask', _v)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Reply', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _val, _data = _unpack_scalar('uint32_t', 'featureMask', _data)
            _kwargs['featureMask'] = _val
            return cls(**_kwargs), _data


class MspSetFeature:
    CODE = 37
    MSPV = 1
    """Sets the enabled features using a bitmask. Clears all previous features first."""
    @dataclass
    class Request:
        featureMask: int = 0

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.featureMask
            out += _pack_scalar('uint32_t', 'featureMask', _v)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Request', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _val, _data = _unpack_scalar('uint32_t', 'featureMask', _data)
            _kwargs['featureMask'] = _val
            return cls(**_kwargs), _data


class MspBoardAlignment:
    CODE = 38
    MSPV = 1
    """Returns the sensor board alignment angles relative to the craft frame."""
    @dataclass
    class Reply:
        rollAlign: int = 0
        pitchAlign: int = 0
        yawAlign: int = 0

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.rollAlign
            out += _pack_scalar('int16_t', 'rollAlign', _v)
            _v = self.pitchAlign
            out += _pack_scalar('int16_t', 'pitchAlign', _v)
            _v = self.yawAlign
            out += _pack_scalar('int16_t', 'yawAlign', _v)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Reply', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _val, _data = _unpack_scalar('int16_t', 'rollAlign', _data)
            _kwargs['rollAlign'] = _val
            _val, _data = _unpack_scalar('int16_t', 'pitchAlign', _data)
            _kwargs['pitchAlign'] = _val
            _val, _data = _unpack_scalar('int16_t', 'yawAlign', _data)
            _kwargs['yawAlign'] = _val
            return cls(**_kwargs), _data


class MspSetBoardAlignment:
    CODE = 39
    MSPV = 1
    """Sets the sensor board alignment angles."""
    @dataclass
    class Request:
        rollAlign: int = 0
        pitchAlign: int = 0
        yawAlign: int = 0

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.rollAlign
            out += _pack_scalar('int16_t', 'rollAlign', _v)
            _v = self.pitchAlign
            out += _pack_scalar('int16_t', 'pitchAlign', _v)
            _v = self.yawAlign
            out += _pack_scalar('int16_t', 'yawAlign', _v)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Request', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _val, _data = _unpack_scalar('int16_t', 'rollAlign', _data)
            _kwargs['rollAlign'] = _val
            _val, _data = _unpack_scalar('int16_t', 'pitchAlign', _data)
            _kwargs['pitchAlign'] = _val
            _val, _data = _unpack_scalar('int16_t', 'yawAlign', _data)
            _kwargs['yawAlign'] = _val
            return cls(**_kwargs), _data


class MspCurrentMeterConfig:
    CODE = 40
    MSPV = 1
    """Retrieves the configuration for the current sensor."""
    @dataclass
    class Reply:
        scale: int = 0
        offset: int = 0
        type: int = 0
        capacity: int = 0

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.scale
            out += _pack_scalar('int16_t', 'scale', _v)
            _v = self.offset
            out += _pack_scalar('int16_t', 'offset', _v)
            _v = self.type
            out += _pack_scalar('uint8_t', 'type', _v)
            _v = self.capacity
            out += _pack_scalar('uint16_t', 'capacity', _v)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Reply', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _val, _data = _unpack_scalar('int16_t', 'scale', _data)
            _kwargs['scale'] = _val
            _val, _data = _unpack_scalar('int16_t', 'offset', _data)
            _kwargs['offset'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'type', _data)
            _kwargs['type'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'capacity', _data)
            _kwargs['capacity'] = _val
            return cls(**_kwargs), _data


class MspSetCurrentMeterConfig:
    CODE = 41
    MSPV = 1
    """Sets the configuration for the current sensor."""
    @dataclass
    class Request:
        scale: int = 0
        offset: int = 0
        type: int = 0
        capacity: int = 0

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.scale
            out += _pack_scalar('int16_t', 'scale', _v)
            _v = self.offset
            out += _pack_scalar('int16_t', 'offset', _v)
            _v = self.type
            out += _pack_scalar('uint8_t', 'type', _v)
            _v = self.capacity
            out += _pack_scalar('uint16_t', 'capacity', _v)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Request', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _val, _data = _unpack_scalar('int16_t', 'scale', _data)
            _kwargs['scale'] = _val
            _val, _data = _unpack_scalar('int16_t', 'offset', _data)
            _kwargs['offset'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'type', _data)
            _kwargs['type'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'capacity', _data)
            _kwargs['capacity'] = _val
            return cls(**_kwargs), _data


class MspMixer:
    CODE = 42
    MSPV = 1
    """Retrieves the mixer type (Legacy, INAV always returns QuadX)."""
    @dataclass
    class Reply:
        mixerMode: int = 0

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.mixerMode
            out += _pack_scalar('uint8_t', 'mixerMode', _v)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Reply', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _val, _data = _unpack_scalar('uint8_t', 'mixerMode', _data)
            _kwargs['mixerMode'] = _val
            return cls(**_kwargs), _data


class MspSetMixer:
    CODE = 43
    MSPV = 1
    """Sets the mixer type (Legacy, ignored by INAV)."""
    @dataclass
    class Request:
        mixerMode: int = 0

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.mixerMode
            out += _pack_scalar('uint8_t', 'mixerMode', _v)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Request', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _val, _data = _unpack_scalar('uint8_t', 'mixerMode', _data)
            _kwargs['mixerMode'] = _val
            return cls(**_kwargs), _data


class MspRxConfig:
    CODE = 44
    MSPV = 1
    """Retrieves receiver configuration settings. Some fields are Betaflight compatibility placeholders."""
    @dataclass
    class Reply:
        serialRxProvider: int = 0
        maxCheck: int = 0
        midRc: int = 0
        minCheck: int = 0
        spektrumSatBind: int = 0
        rxMinUsec: int = 0
        rxMaxUsec: int = 0
        bfCompatRcInterpolation: int = 0
        bfCompatRcInterpolationInt: int = 0
        bfCompatAirModeThreshold: int = 0
        reserved1: int = 0
        reserved2: int = 0
        reserved3: int = 0
        bfCompatFpvCamAngle: int = 0
        receiverType: int = 0

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.serialRxProvider
            out += _pack_scalar('uint8_t', 'serialRxProvider', _v)
            _v = self.maxCheck
            out += _pack_scalar('uint16_t', 'maxCheck', _v)
            _v = self.midRc
            out += _pack_scalar('uint16_t', 'midRc', _v)
            _v = self.minCheck
            out += _pack_scalar('uint16_t', 'minCheck', _v)
            _v = self.spektrumSatBind
            out += _pack_scalar('uint8_t', 'spektrumSatBind', _v)
            _v = self.rxMinUsec
            out += _pack_scalar('uint16_t', 'rxMinUsec', _v)
            _v = self.rxMaxUsec
            out += _pack_scalar('uint16_t', 'rxMaxUsec', _v)
            _v = self.bfCompatRcInterpolation
            out += _pack_scalar('uint8_t', 'bfCompatRcInterpolation', _v)
            _v = self.bfCompatRcInterpolationInt
            out += _pack_scalar('uint8_t', 'bfCompatRcInterpolationInt', _v)
            _v = self.bfCompatAirModeThreshold
            out += _pack_scalar('uint16_t', 'bfCompatAirModeThreshold', _v)
            _v = self.reserved1
            out += _pack_scalar('uint8_t', 'reserved1', _v)
            _v = self.reserved2
            out += _pack_scalar('uint32_t', 'reserved2', _v)
            _v = self.reserved3
            out += _pack_scalar('uint8_t', 'reserved3', _v)
            _v = self.bfCompatFpvCamAngle
            out += _pack_scalar('uint8_t', 'bfCompatFpvCamAngle', _v)
            _v = self.receiverType
            out += _pack_scalar('uint8_t', 'receiverType', _v)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Reply', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _val, _data = _unpack_scalar('uint8_t', 'serialRxProvider', _data)
            _kwargs['serialRxProvider'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'maxCheck', _data)
            _kwargs['maxCheck'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'midRc', _data)
            _kwargs['midRc'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'minCheck', _data)
            _kwargs['minCheck'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'spektrumSatBind', _data)
            _kwargs['spektrumSatBind'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'rxMinUsec', _data)
            _kwargs['rxMinUsec'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'rxMaxUsec', _data)
            _kwargs['rxMaxUsec'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'bfCompatRcInterpolation', _data)
            _kwargs['bfCompatRcInterpolation'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'bfCompatRcInterpolationInt', _data)
            _kwargs['bfCompatRcInterpolationInt'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'bfCompatAirModeThreshold', _data)
            _kwargs['bfCompatAirModeThreshold'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'reserved1', _data)
            _kwargs['reserved1'] = _val
            _val, _data = _unpack_scalar('uint32_t', 'reserved2', _data)
            _kwargs['reserved2'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'reserved3', _data)
            _kwargs['reserved3'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'bfCompatFpvCamAngle', _data)
            _kwargs['bfCompatFpvCamAngle'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'receiverType', _data)
            _kwargs['receiverType'] = _val
            return cls(**_kwargs), _data


class MspSetRxConfig:
    CODE = 45
    MSPV = 1
    """Sets receiver configuration settings."""
    @dataclass
    class Request:
        serialRxProvider: int = 0
        maxCheck: int = 0
        midRc: int = 0
        minCheck: int = 0
        spektrumSatBind: int = 0
        rxMinUsec: int = 0
        rxMaxUsec: int = 0
        bfCompatRcInterpolation: int = 0
        bfCompatRcInterpolationInt: int = 0
        bfCompatAirModeThreshold: int = 0
        reserved1: int = 0
        reserved2: int = 0
        reserved3: int = 0
        bfCompatFpvCamAngle: int = 0
        receiverType: int = 0

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.serialRxProvider
            out += _pack_scalar('uint8_t', 'serialRxProvider', _v)
            _v = self.maxCheck
            out += _pack_scalar('uint16_t', 'maxCheck', _v)
            _v = self.midRc
            out += _pack_scalar('uint16_t', 'midRc', _v)
            _v = self.minCheck
            out += _pack_scalar('uint16_t', 'minCheck', _v)
            _v = self.spektrumSatBind
            out += _pack_scalar('uint8_t', 'spektrumSatBind', _v)
            _v = self.rxMinUsec
            out += _pack_scalar('uint16_t', 'rxMinUsec', _v)
            _v = self.rxMaxUsec
            out += _pack_scalar('uint16_t', 'rxMaxUsec', _v)
            _v = self.bfCompatRcInterpolation
            out += _pack_scalar('uint8_t', 'bfCompatRcInterpolation', _v)
            _v = self.bfCompatRcInterpolationInt
            out += _pack_scalar('uint8_t', 'bfCompatRcInterpolationInt', _v)
            _v = self.bfCompatAirModeThreshold
            out += _pack_scalar('uint16_t', 'bfCompatAirModeThreshold', _v)
            _v = self.reserved1
            out += _pack_scalar('uint8_t', 'reserved1', _v)
            _v = self.reserved2
            out += _pack_scalar('uint32_t', 'reserved2', _v)
            _v = self.reserved3
            out += _pack_scalar('uint8_t', 'reserved3', _v)
            _v = self.bfCompatFpvCamAngle
            out += _pack_scalar('uint8_t', 'bfCompatFpvCamAngle', _v)
            _v = self.receiverType
            out += _pack_scalar('uint8_t', 'receiverType', _v)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Request', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _val, _data = _unpack_scalar('uint8_t', 'serialRxProvider', _data)
            _kwargs['serialRxProvider'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'maxCheck', _data)
            _kwargs['maxCheck'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'midRc', _data)
            _kwargs['midRc'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'minCheck', _data)
            _kwargs['minCheck'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'spektrumSatBind', _data)
            _kwargs['spektrumSatBind'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'rxMinUsec', _data)
            _kwargs['rxMinUsec'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'rxMaxUsec', _data)
            _kwargs['rxMaxUsec'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'bfCompatRcInterpolation', _data)
            _kwargs['bfCompatRcInterpolation'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'bfCompatRcInterpolationInt', _data)
            _kwargs['bfCompatRcInterpolationInt'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'bfCompatAirModeThreshold', _data)
            _kwargs['bfCompatAirModeThreshold'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'reserved1', _data)
            _kwargs['reserved1'] = _val
            _val, _data = _unpack_scalar('uint32_t', 'reserved2', _data)
            _kwargs['reserved2'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'reserved3', _data)
            _kwargs['reserved3'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'bfCompatFpvCamAngle', _data)
            _kwargs['bfCompatFpvCamAngle'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'receiverType', _data)
            _kwargs['receiverType'] = _val
            return cls(**_kwargs), _data


class MspLedColors:
    CODE = 46
    MSPV = 1
    """Retrieves the HSV color definitions for configurable LED colors."""
    @dataclass
    class Reply:
        hue: int = 0
        saturation: int = 0
        value: int = 0

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.hue
            out += _pack_scalar('uint16_t', 'hue', _v)
            _v = self.saturation
            out += _pack_scalar('uint8_t', 'saturation', _v)
            _v = self.value
            out += _pack_scalar('uint8_t', 'value', _v)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Reply', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _val, _data = _unpack_scalar('uint16_t', 'hue', _data)
            _kwargs['hue'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'saturation', _data)
            _kwargs['saturation'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'value', _data)
            _kwargs['value'] = _val
            return cls(**_kwargs), _data


class MspSetLedColors:
    CODE = 47
    MSPV = 1
    """Sets the HSV color definitions for configurable LED colors."""
    @dataclass
    class Request:
        hue: int = 0
        saturation: int = 0
        value: int = 0

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.hue
            out += _pack_scalar('uint16_t', 'hue', _v)
            _v = self.saturation
            out += _pack_scalar('uint8_t', 'saturation', _v)
            _v = self.value
            out += _pack_scalar('uint8_t', 'value', _v)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Request', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _val, _data = _unpack_scalar('uint16_t', 'hue', _data)
            _kwargs['hue'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'saturation', _data)
            _kwargs['saturation'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'value', _data)
            _kwargs['value'] = _val
            return cls(**_kwargs), _data


class MspLedStripConfig:
    CODE = 48
    MSPV = 1
    """Retrieves the configuration for each LED on the strip (legacy packed format)."""
    @dataclass
    class Reply:
        legacyLedConfig: int = 0

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.legacyLedConfig
            out += _pack_scalar('uint32_t', 'legacyLedConfig', _v)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Reply', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _val, _data = _unpack_scalar('uint32_t', 'legacyLedConfig', _data)
            _kwargs['legacyLedConfig'] = _val
            return cls(**_kwargs), _data


class MspSetLedStripConfig:
    CODE = 49
    MSPV = 1
    """Sets the configuration for a single LED on the strip using the legacy packed format."""
    @dataclass
    class Request:
        ledIndex: int = 0
        legacyLedConfig: int = 0

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.ledIndex
            out += _pack_scalar('uint8_t', 'ledIndex', _v)
            _v = self.legacyLedConfig
            out += _pack_scalar('uint32_t', 'legacyLedConfig', _v)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Request', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _val, _data = _unpack_scalar('uint8_t', 'ledIndex', _data)
            _kwargs['ledIndex'] = _val
            _val, _data = _unpack_scalar('uint32_t', 'legacyLedConfig', _data)
            _kwargs['legacyLedConfig'] = _val
            return cls(**_kwargs), _data


class MspRssiConfig:
    CODE = 50
    MSPV = 1
    """Retrieves the channel used for analog RSSI input."""
    @dataclass
    class Reply:
        rssiChannel: int = 0

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.rssiChannel
            out += _pack_scalar('uint8_t', 'rssiChannel', _v)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Reply', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _val, _data = _unpack_scalar('uint8_t', 'rssiChannel', _data)
            _kwargs['rssiChannel'] = _val
            return cls(**_kwargs), _data


class MspSetRssiConfig:
    CODE = 51
    MSPV = 1
    """Sets the channel used for analog RSSI input."""
    @dataclass
    class Request:
        rssiChannel: int = 0

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.rssiChannel
            out += _pack_scalar('uint8_t', 'rssiChannel', _v)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Request', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _val, _data = _unpack_scalar('uint8_t', 'rssiChannel', _data)
            _kwargs['rssiChannel'] = _val
            return cls(**_kwargs), _data


class MspAdjustmentRanges:
    CODE = 52
    MSPV = 1
    """Returns all defined RC adjustment ranges (tuning via aux channels)."""
    @dataclass
    class Reply:
        adjustmentIndex: int = 0
        auxChannelIndex: int = 0
        rangeStartStep: int = 0
        rangeEndStep: int = 0
        adjustmentFunction: int = 0
        auxSwitchChannelIndex: int = 0

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.adjustmentIndex
            out += _pack_scalar('uint8_t', 'adjustmentIndex', _v)
            _v = self.auxChannelIndex
            out += _pack_scalar('uint8_t', 'auxChannelIndex', _v)
            _v = self.rangeStartStep
            out += _pack_scalar('uint8_t', 'rangeStartStep', _v)
            _v = self.rangeEndStep
            out += _pack_scalar('uint8_t', 'rangeEndStep', _v)
            _v = self.adjustmentFunction
            out += _pack_scalar('uint8_t', 'adjustmentFunction', _v)
            _v = self.auxSwitchChannelIndex
            out += _pack_scalar('uint8_t', 'auxSwitchChannelIndex', _v)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Reply', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _val, _data = _unpack_scalar('uint8_t', 'adjustmentIndex', _data)
            _kwargs['adjustmentIndex'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'auxChannelIndex', _data)
            _kwargs['auxChannelIndex'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'rangeStartStep', _data)
            _kwargs['rangeStartStep'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'rangeEndStep', _data)
            _kwargs['rangeEndStep'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'adjustmentFunction', _data)
            _kwargs['adjustmentFunction'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'auxSwitchChannelIndex', _data)
            _kwargs['auxSwitchChannelIndex'] = _val
            return cls(**_kwargs), _data


class MspSetAdjustmentRange:
    CODE = 53
    MSPV = 1
    """Sets a single RC adjustment range configuration by its index."""
    @dataclass
    class Request:
        rangeIndex: int = 0
        adjustmentIndex: int = 0
        auxChannelIndex: int = 0
        rangeStartStep: int = 0
        rangeEndStep: int = 0
        adjustmentFunction: int = 0
        auxSwitchChannelIndex: int = 0

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.rangeIndex
            out += _pack_scalar('uint8_t', 'rangeIndex', _v)
            _v = self.adjustmentIndex
            out += _pack_scalar('uint8_t', 'adjustmentIndex', _v)
            _v = self.auxChannelIndex
            out += _pack_scalar('uint8_t', 'auxChannelIndex', _v)
            _v = self.rangeStartStep
            out += _pack_scalar('uint8_t', 'rangeStartStep', _v)
            _v = self.rangeEndStep
            out += _pack_scalar('uint8_t', 'rangeEndStep', _v)
            _v = self.adjustmentFunction
            out += _pack_scalar('uint8_t', 'adjustmentFunction', _v)
            _v = self.auxSwitchChannelIndex
            out += _pack_scalar('uint8_t', 'auxSwitchChannelIndex', _v)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Request', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _val, _data = _unpack_scalar('uint8_t', 'rangeIndex', _data)
            _kwargs['rangeIndex'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'adjustmentIndex', _data)
            _kwargs['adjustmentIndex'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'auxChannelIndex', _data)
            _kwargs['auxChannelIndex'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'rangeStartStep', _data)
            _kwargs['rangeStartStep'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'rangeEndStep', _data)
            _kwargs['rangeEndStep'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'adjustmentFunction', _data)
            _kwargs['adjustmentFunction'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'auxSwitchChannelIndex', _data)
            _kwargs['auxSwitchChannelIndex'] = _val
            return cls(**_kwargs), _data


class MspCfSerialConfig:
    CODE = 54
    MSPV = 1
    """Deprecated command to get serial port configuration."""
    pass

class MspSetCfSerialConfig:
    CODE = 55
    MSPV = 1
    """Deprecated command to set serial port configuration."""
    pass

class MspVoltageMeterConfig:
    CODE = 56
    MSPV = 1
    """Retrieves legacy voltage meter configuration (scaled values)."""
    @dataclass
    class Reply:
        vbatScale: int = 0
        vbatMinCell: int = 0
        vbatMaxCell: int = 0
        vbatWarningCell: int = 0

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.vbatScale
            out += _pack_scalar('uint8_t', 'vbatScale', _v)
            _v = self.vbatMinCell
            out += _pack_scalar('uint8_t', 'vbatMinCell', _v)
            _v = self.vbatMaxCell
            out += _pack_scalar('uint8_t', 'vbatMaxCell', _v)
            _v = self.vbatWarningCell
            out += _pack_scalar('uint8_t', 'vbatWarningCell', _v)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Reply', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _val, _data = _unpack_scalar('uint8_t', 'vbatScale', _data)
            _kwargs['vbatScale'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'vbatMinCell', _data)
            _kwargs['vbatMinCell'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'vbatMaxCell', _data)
            _kwargs['vbatMaxCell'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'vbatWarningCell', _data)
            _kwargs['vbatWarningCell'] = _val
            return cls(**_kwargs), _data


class MspSetVoltageMeterConfig:
    CODE = 57
    MSPV = 1
    """Sets legacy voltage meter configuration (scaled values)."""
    @dataclass
    class Request:
        vbatScale: int = 0
        vbatMinCell: int = 0
        vbatMaxCell: int = 0
        vbatWarningCell: int = 0

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.vbatScale
            out += _pack_scalar('uint8_t', 'vbatScale', _v)
            _v = self.vbatMinCell
            out += _pack_scalar('uint8_t', 'vbatMinCell', _v)
            _v = self.vbatMaxCell
            out += _pack_scalar('uint8_t', 'vbatMaxCell', _v)
            _v = self.vbatWarningCell
            out += _pack_scalar('uint8_t', 'vbatWarningCell', _v)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Request', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _val, _data = _unpack_scalar('uint8_t', 'vbatScale', _data)
            _kwargs['vbatScale'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'vbatMinCell', _data)
            _kwargs['vbatMinCell'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'vbatMaxCell', _data)
            _kwargs['vbatMaxCell'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'vbatWarningCell', _data)
            _kwargs['vbatWarningCell'] = _val
            return cls(**_kwargs), _data


class MspSonarAltitude:
    CODE = 58
    MSPV = 1
    """Retrieves the altitude measured by the primary rangefinder (sonar or lidar)."""
    @dataclass
    class Reply:
        rangefinderAltitude: int = 0

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.rangefinderAltitude
            out += _pack_scalar('int32_t', 'rangefinderAltitude', _v)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Reply', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _val, _data = _unpack_scalar('int32_t', 'rangefinderAltitude', _data)
            _kwargs['rangefinderAltitude'] = _val
            return cls(**_kwargs), _data


class MspRxMap:
    CODE = 64
    MSPV = 1
    """Retrieves the RC channel mapping array (AETR, etc.)."""
    @dataclass
    class Reply:
        rcMap: List[int] = field(default_factory=list)

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.rcMap
            if not isinstance(_v, list):
                raise TypeError('rcMap must be list')
            if len(_v) != 4:
                raise ValueError('rcMap must have exactly 4 elements')
            for i, _e in enumerate(_v):
                out += _pack_scalar('uint8_t', 'rcMap[{}]'.format(i), _e)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Reply', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            if len(_data) < 4:
                raise ValueError('not enough data to unpack rcMap')
            _tmp_v = []
            _tmp = _data[:4]
            for _i in range(4):
                _val, _tmp = _unpack_scalar('uint8_t', 'rcMap[{}]'.format(_i), _tmp)
                _tmp_v.append(_val)
            _kwargs['rcMap'] = _tmp_v
            _data = _data[4:]
            return cls(**_kwargs), _data


class MspSetRxMap:
    CODE = 65
    MSPV = 1
    """Sets the RC channel mapping array."""
    @dataclass
    class Request:
        rcMap: List[int] = field(default_factory=list)

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.rcMap
            if not isinstance(_v, list):
                raise TypeError('rcMap must be list')
            if len(_v) != 4:
                raise ValueError('rcMap must have exactly 4 elements')
            for i, _e in enumerate(_v):
                out += _pack_scalar('uint8_t', 'rcMap[{}]'.format(i), _e)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Request', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            if len(_data) < 4:
                raise ValueError('not enough data to unpack rcMap')
            _tmp_v = []
            _tmp = _data[:4]
            for _i in range(4):
                _val, _tmp = _unpack_scalar('uint8_t', 'rcMap[{}]'.format(_i), _tmp)
                _tmp_v.append(_val)
            _kwargs['rcMap'] = _tmp_v
            _data = _data[4:]
            return cls(**_kwargs), _data


class MspReboot:
    CODE = 68
    MSPV = 1
    """Commands the flight controller to reboot."""
    pass

class MspDataflashSummary:
    CODE = 70
    MSPV = 1
    """Retrieves summary information about the onboard dataflash chip (if present and used for Blackbox via FlashFS)."""
    @dataclass
    class Reply:
        flashReady: int = 0
        sectorCount: int = 0
        totalSize: int = 0
        usedSize: int = 0

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.flashReady
            out += _pack_scalar('uint8_t', 'flashReady', _v)
            _v = self.sectorCount
            out += _pack_scalar('uint32_t', 'sectorCount', _v)
            _v = self.totalSize
            out += _pack_scalar('uint32_t', 'totalSize', _v)
            _v = self.usedSize
            out += _pack_scalar('uint32_t', 'usedSize', _v)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Reply', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _val, _data = _unpack_scalar('uint8_t', 'flashReady', _data)
            _kwargs['flashReady'] = _val
            _val, _data = _unpack_scalar('uint32_t', 'sectorCount', _data)
            _kwargs['sectorCount'] = _val
            _val, _data = _unpack_scalar('uint32_t', 'totalSize', _data)
            _kwargs['totalSize'] = _val
            _val, _data = _unpack_scalar('uint32_t', 'usedSize', _data)
            _kwargs['usedSize'] = _val
            return cls(**_kwargs), _data


class MspDataflashRead:
    CODE = 71
    MSPV = 1
    """Reads a block of data from the onboard dataflash (FlashFS)."""
    @dataclass
    class Request:
        address: int = 0
        size: Optional[int] = None

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.address
            out += _pack_scalar('uint32_t', 'address', _v)
            if self.size is None:
                pass
            else:
                _v = self.size
                out += _pack_scalar('uint16_t', 'size', _v)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Request', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _val, _data = _unpack_scalar('uint32_t', 'address', _data)
            _kwargs['address'] = _val
            if len(_data) == 0:
                _kwargs['size'] = None
            else:
                _val, _data = _unpack_scalar('uint16_t', 'size', _data)
                _kwargs['size'] = _val
            return cls(**_kwargs), _data

    @dataclass
    class Reply:
        address: int = 0
        data: List[int] = field(default_factory=list)

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.address
            out += _pack_scalar('uint32_t', 'address', _v)
            _v = self.data
            if not isinstance(_v, list):
                raise TypeError('data must be list')
            for i, _e in enumerate(_v):
                out += _pack_scalar('uint8_t', 'data[{}]'.format(i), _e)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Reply', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _val, _data = _unpack_scalar('uint32_t', 'address', _data)
            _kwargs['address'] = _val
            _alen = hints.get('data_len')
            if _alen is None:
                raise ValueError('missing hint: data_len for variable length array')
            elem_size = 1
            total = int(_alen) * elem_size
            if len(_data) < total:
                raise ValueError('not enough data to unpack data')
            _tmp_v = []
            _tmp = _data[:total]
            for _i in range(int(_alen)):
                _val, _tmp = _unpack_scalar('uint8_t', 'data[{}]'.format(_i), _tmp)
                _tmp_v.append(_val)
            _kwargs['data'] = _tmp_v
            _data = _data[total:]
            return cls(**_kwargs), _data


class MspDataflashErase:
    CODE = 72
    MSPV = 1
    """Erases the entire onboard dataflash chip (FlashFS volume)."""
    pass

class MspLoopTime:
    CODE = 73
    MSPV = 1
    """Retrieves the configured loop time (PID loop frequency denominator)."""
    @dataclass
    class Reply:
        looptime: int = 0

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.looptime
            out += _pack_scalar('uint16_t', 'looptime', _v)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Reply', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _val, _data = _unpack_scalar('uint16_t', 'looptime', _data)
            _kwargs['looptime'] = _val
            return cls(**_kwargs), _data


class MspSetLoopTime:
    CODE = 74
    MSPV = 1
    """Sets the configured loop time."""
    @dataclass
    class Request:
        looptime: int = 0

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.looptime
            out += _pack_scalar('uint16_t', 'looptime', _v)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Request', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _val, _data = _unpack_scalar('uint16_t', 'looptime', _data)
            _kwargs['looptime'] = _val
            return cls(**_kwargs), _data


class MspFailsafeConfig:
    CODE = 75
    MSPV = 1
    """Retrieves the failsafe configuration settings."""
    @dataclass
    class Reply:
        failsafeDelay: int = 0
        failsafeOffDelay: int = 0
        failsafeThrottle: int = 0
        legacyKillSwitch: int = 0
        failsafeThrottleLowDelay: int = 0
        failsafeProcedure: int = 0
        failsafeRecoveryDelay: int = 0
        failsafeFWRollAngle: int = 0
        failsafeFWPitchAngle: int = 0
        failsafeFWYawRate: int = 0
        failsafeStickThreshold: int = 0
        failsafeMinDistance: int = 0
        failsafeMinDistanceProc: int = 0

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.failsafeDelay
            out += _pack_scalar('uint8_t', 'failsafeDelay', _v)
            _v = self.failsafeOffDelay
            out += _pack_scalar('uint8_t', 'failsafeOffDelay', _v)
            _v = self.failsafeThrottle
            out += _pack_scalar('uint16_t', 'failsafeThrottle', _v)
            _v = self.legacyKillSwitch
            out += _pack_scalar('uint8_t', 'legacyKillSwitch', _v)
            _v = self.failsafeThrottleLowDelay
            out += _pack_scalar('uint16_t', 'failsafeThrottleLowDelay', _v)
            _v = self.failsafeProcedure
            out += _pack_scalar('uint8_t', 'failsafeProcedure', _v)
            _v = self.failsafeRecoveryDelay
            out += _pack_scalar('uint8_t', 'failsafeRecoveryDelay', _v)
            _v = self.failsafeFWRollAngle
            out += _pack_scalar('int16_t', 'failsafeFWRollAngle', _v)
            _v = self.failsafeFWPitchAngle
            out += _pack_scalar('int16_t', 'failsafeFWPitchAngle', _v)
            _v = self.failsafeFWYawRate
            out += _pack_scalar('int16_t', 'failsafeFWYawRate', _v)
            _v = self.failsafeStickThreshold
            out += _pack_scalar('uint16_t', 'failsafeStickThreshold', _v)
            _v = self.failsafeMinDistance
            out += _pack_scalar('uint16_t', 'failsafeMinDistance', _v)
            _v = self.failsafeMinDistanceProc
            out += _pack_scalar('uint8_t', 'failsafeMinDistanceProc', _v)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Reply', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _val, _data = _unpack_scalar('uint8_t', 'failsafeDelay', _data)
            _kwargs['failsafeDelay'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'failsafeOffDelay', _data)
            _kwargs['failsafeOffDelay'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'failsafeThrottle', _data)
            _kwargs['failsafeThrottle'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'legacyKillSwitch', _data)
            _kwargs['legacyKillSwitch'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'failsafeThrottleLowDelay', _data)
            _kwargs['failsafeThrottleLowDelay'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'failsafeProcedure', _data)
            _kwargs['failsafeProcedure'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'failsafeRecoveryDelay', _data)
            _kwargs['failsafeRecoveryDelay'] = _val
            _val, _data = _unpack_scalar('int16_t', 'failsafeFWRollAngle', _data)
            _kwargs['failsafeFWRollAngle'] = _val
            _val, _data = _unpack_scalar('int16_t', 'failsafeFWPitchAngle', _data)
            _kwargs['failsafeFWPitchAngle'] = _val
            _val, _data = _unpack_scalar('int16_t', 'failsafeFWYawRate', _data)
            _kwargs['failsafeFWYawRate'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'failsafeStickThreshold', _data)
            _kwargs['failsafeStickThreshold'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'failsafeMinDistance', _data)
            _kwargs['failsafeMinDistance'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'failsafeMinDistanceProc', _data)
            _kwargs['failsafeMinDistanceProc'] = _val
            return cls(**_kwargs), _data


class MspSetFailsafeConfig:
    CODE = 76
    MSPV = 1
    """Sets the failsafe configuration settings."""
    @dataclass
    class Request:
        failsafeDelay: int = 0
        failsafeOffDelay: int = 0
        failsafeThrottle: int = 0
        legacyKillSwitch: int = 0
        failsafeThrottleLowDelay: int = 0
        failsafeProcedure: int = 0
        failsafeRecoveryDelay: int = 0
        failsafeFWRollAngle: int = 0
        failsafeFWPitchAngle: int = 0
        failsafeFWYawRate: int = 0
        failsafeStickThreshold: int = 0
        failsafeMinDistance: int = 0
        failsafeMinDistanceProc: int = 0

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.failsafeDelay
            out += _pack_scalar('uint8_t', 'failsafeDelay', _v)
            _v = self.failsafeOffDelay
            out += _pack_scalar('uint8_t', 'failsafeOffDelay', _v)
            _v = self.failsafeThrottle
            out += _pack_scalar('uint16_t', 'failsafeThrottle', _v)
            _v = self.legacyKillSwitch
            out += _pack_scalar('uint8_t', 'legacyKillSwitch', _v)
            _v = self.failsafeThrottleLowDelay
            out += _pack_scalar('uint16_t', 'failsafeThrottleLowDelay', _v)
            _v = self.failsafeProcedure
            out += _pack_scalar('uint8_t', 'failsafeProcedure', _v)
            _v = self.failsafeRecoveryDelay
            out += _pack_scalar('uint8_t', 'failsafeRecoveryDelay', _v)
            _v = self.failsafeFWRollAngle
            out += _pack_scalar('int16_t', 'failsafeFWRollAngle', _v)
            _v = self.failsafeFWPitchAngle
            out += _pack_scalar('int16_t', 'failsafeFWPitchAngle', _v)
            _v = self.failsafeFWYawRate
            out += _pack_scalar('int16_t', 'failsafeFWYawRate', _v)
            _v = self.failsafeStickThreshold
            out += _pack_scalar('uint16_t', 'failsafeStickThreshold', _v)
            _v = self.failsafeMinDistance
            out += _pack_scalar('uint16_t', 'failsafeMinDistance', _v)
            _v = self.failsafeMinDistanceProc
            out += _pack_scalar('uint8_t', 'failsafeMinDistanceProc', _v)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Request', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _val, _data = _unpack_scalar('uint8_t', 'failsafeDelay', _data)
            _kwargs['failsafeDelay'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'failsafeOffDelay', _data)
            _kwargs['failsafeOffDelay'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'failsafeThrottle', _data)
            _kwargs['failsafeThrottle'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'legacyKillSwitch', _data)
            _kwargs['legacyKillSwitch'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'failsafeThrottleLowDelay', _data)
            _kwargs['failsafeThrottleLowDelay'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'failsafeProcedure', _data)
            _kwargs['failsafeProcedure'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'failsafeRecoveryDelay', _data)
            _kwargs['failsafeRecoveryDelay'] = _val
            _val, _data = _unpack_scalar('int16_t', 'failsafeFWRollAngle', _data)
            _kwargs['failsafeFWRollAngle'] = _val
            _val, _data = _unpack_scalar('int16_t', 'failsafeFWPitchAngle', _data)
            _kwargs['failsafeFWPitchAngle'] = _val
            _val, _data = _unpack_scalar('int16_t', 'failsafeFWYawRate', _data)
            _kwargs['failsafeFWYawRate'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'failsafeStickThreshold', _data)
            _kwargs['failsafeStickThreshold'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'failsafeMinDistance', _data)
            _kwargs['failsafeMinDistance'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'failsafeMinDistanceProc', _data)
            _kwargs['failsafeMinDistanceProc'] = _val
            return cls(**_kwargs), _data


class MspSdcardSummary:
    CODE = 79
    MSPV = 1
    """Retrieves summary information about the SD card status and filesystem."""
    @dataclass
    class Reply:
        sdCardSupported: int = 0
        sdCardState: int = 0
        fsError: int = 0
        freeSpaceKB: int = 0
        totalSpaceKB: int = 0

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.sdCardSupported
            out += _pack_scalar('uint8_t', 'sdCardSupported', _v)
            _v = self.sdCardState
            out += _pack_scalar('uint8_t', 'sdCardState', _v)
            _v = self.fsError
            out += _pack_scalar('uint8_t', 'fsError', _v)
            _v = self.freeSpaceKB
            out += _pack_scalar('uint32_t', 'freeSpaceKB', _v)
            _v = self.totalSpaceKB
            out += _pack_scalar('uint32_t', 'totalSpaceKB', _v)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Reply', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _val, _data = _unpack_scalar('uint8_t', 'sdCardSupported', _data)
            _kwargs['sdCardSupported'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'sdCardState', _data)
            _kwargs['sdCardState'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'fsError', _data)
            _kwargs['fsError'] = _val
            _val, _data = _unpack_scalar('uint32_t', 'freeSpaceKB', _data)
            _kwargs['freeSpaceKB'] = _val
            _val, _data = _unpack_scalar('uint32_t', 'totalSpaceKB', _data)
            _kwargs['totalSpaceKB'] = _val
            return cls(**_kwargs), _data


class MspBlackboxConfig:
    CODE = 80
    MSPV = 1
    """Legacy command to retrieve Blackbox configuration. Superseded by `MSP2_BLACKBOX_CONFIG`."""
    @dataclass
    class Reply:
        blackboxDevice: int = 0
        blackboxRateNum: int = 0
        blackboxRateDenom: int = 0
        blackboxPDenom: int = 0

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.blackboxDevice
            out += _pack_scalar('uint8_t', 'blackboxDevice', _v)
            _v = self.blackboxRateNum
            out += _pack_scalar('uint8_t', 'blackboxRateNum', _v)
            _v = self.blackboxRateDenom
            out += _pack_scalar('uint8_t', 'blackboxRateDenom', _v)
            _v = self.blackboxPDenom
            out += _pack_scalar('uint8_t', 'blackboxPDenom', _v)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Reply', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _val, _data = _unpack_scalar('uint8_t', 'blackboxDevice', _data)
            _kwargs['blackboxDevice'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'blackboxRateNum', _data)
            _kwargs['blackboxRateNum'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'blackboxRateDenom', _data)
            _kwargs['blackboxRateDenom'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'blackboxPDenom', _data)
            _kwargs['blackboxPDenom'] = _val
            return cls(**_kwargs), _data


class MspSetBlackboxConfig:
    CODE = 81
    MSPV = 1
    """Legacy command to set Blackbox configuration. Superseded by `MSP2_SET_BLACKBOX_CONFIG`."""
    pass

class MspTransponderConfig:
    CODE = 82
    MSPV = 1
    """Get VTX Transponder settings (likely specific to RaceFlight/Betaflight, not standard INAV VTX)."""
    pass

class MspSetTransponderConfig:
    CODE = 83
    MSPV = 1
    """Set VTX Transponder settings."""
    pass

class MspOsdConfig:
    CODE = 84
    MSPV = 1
    """Retrieves OSD configuration settings and layout for screen 0. Coordinates are packed as `(Y << 8) | X`. When `USE_OSD` is not compiled in, only `osdDriverType` = `OSD_DRIVER_NONE` is returned."""
    @dataclass
    class Reply:
        osdDriverType: int = 0
        videoSystem: int = 0
        units: int = 0
        rssiAlarm: int = 0
        capAlarm: int = 0
        timerAlarm: int = 0
        altAlarm: int = 0
        distAlarm: int = 0
        negAltAlarm: int = 0
        itemPositions: List[int] = field(default_factory=list)

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.osdDriverType
            out += _pack_scalar('uint8_t', 'osdDriverType', _v)
            _v = self.videoSystem
            out += _pack_scalar('uint8_t', 'videoSystem', _v)
            _v = self.units
            out += _pack_scalar('uint8_t', 'units', _v)
            _v = self.rssiAlarm
            out += _pack_scalar('uint8_t', 'rssiAlarm', _v)
            _v = self.capAlarm
            out += _pack_scalar('uint16_t', 'capAlarm', _v)
            _v = self.timerAlarm
            out += _pack_scalar('uint16_t', 'timerAlarm', _v)
            _v = self.altAlarm
            out += _pack_scalar('uint16_t', 'altAlarm', _v)
            _v = self.distAlarm
            out += _pack_scalar('uint16_t', 'distAlarm', _v)
            _v = self.negAltAlarm
            out += _pack_scalar('uint16_t', 'negAltAlarm', _v)
            _v = self.itemPositions
            if not isinstance(_v, list):
                raise TypeError('itemPositions must be list')
            for i, _e in enumerate(_v):
                out += _pack_scalar('uint16_t', 'itemPositions[{}]'.format(i), _e)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Reply', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _val, _data = _unpack_scalar('uint8_t', 'osdDriverType', _data)
            _kwargs['osdDriverType'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'videoSystem', _data)
            _kwargs['videoSystem'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'units', _data)
            _kwargs['units'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'rssiAlarm', _data)
            _kwargs['rssiAlarm'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'capAlarm', _data)
            _kwargs['capAlarm'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'timerAlarm', _data)
            _kwargs['timerAlarm'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'altAlarm', _data)
            _kwargs['altAlarm'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'distAlarm', _data)
            _kwargs['distAlarm'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'negAltAlarm', _data)
            _kwargs['negAltAlarm'] = _val
            _alen = hints.get('itemPositions_len')
            if _alen is None:
                raise ValueError('missing hint: itemPositions_len for variable length array')
            elem_size = 2
            total = int(_alen) * elem_size
            if len(_data) < total:
                raise ValueError('not enough data to unpack itemPositions')
            _tmp_v = []
            _tmp = _data[:total]
            for _i in range(int(_alen)):
                _val, _tmp = _unpack_scalar('uint16_t', 'itemPositions[{}]'.format(_i), _tmp)
                _tmp_v.append(_val)
            _kwargs['itemPositions'] = _tmp_v
            _data = _data[total:]
            return cls(**_kwargs), _data


class MspSetOsdConfig:
    CODE = 85
    MSPV = 1
    """Sets OSD configuration or a single item's position on screen 0."""
    pass

class MspOsdCharRead:
    CODE = 86
    MSPV = 1
    """Reads character data from the OSD font memory."""
    pass

class MspOsdCharWrite:
    CODE = 87
    MSPV = 1
    """Writes character data to the OSD font memory."""
    pass

class MspVtxConfig:
    CODE = 88
    MSPV = 1
    """Retrieves the current VTX (Video Transmitter) configuration and capabilities."""
    @dataclass
    class Reply:
        vtxDeviceType: int = 0
        band: int = 0
        channel: int = 0
        power: int = 0
        pitMode: int = 0
        vtxReady: int = 0
        lowPowerDisarm: int = 0
        vtxTableAvailable: int = 0
        bandCount: int = 0
        channelCount: int = 0
        powerCount: int = 0

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.vtxDeviceType
            out += _pack_scalar('uint8_t', 'vtxDeviceType', _v)
            _v = self.band
            out += _pack_scalar('uint8_t', 'band', _v)
            _v = self.channel
            out += _pack_scalar('uint8_t', 'channel', _v)
            _v = self.power
            out += _pack_scalar('uint8_t', 'power', _v)
            _v = self.pitMode
            out += _pack_scalar('uint8_t', 'pitMode', _v)
            _v = self.vtxReady
            out += _pack_scalar('uint8_t', 'vtxReady', _v)
            _v = self.lowPowerDisarm
            out += _pack_scalar('uint8_t', 'lowPowerDisarm', _v)
            _v = self.vtxTableAvailable
            out += _pack_scalar('uint8_t', 'vtxTableAvailable', _v)
            _v = self.bandCount
            out += _pack_scalar('uint8_t', 'bandCount', _v)
            _v = self.channelCount
            out += _pack_scalar('uint8_t', 'channelCount', _v)
            _v = self.powerCount
            out += _pack_scalar('uint8_t', 'powerCount', _v)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Reply', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _val, _data = _unpack_scalar('uint8_t', 'vtxDeviceType', _data)
            _kwargs['vtxDeviceType'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'band', _data)
            _kwargs['band'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'channel', _data)
            _kwargs['channel'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'power', _data)
            _kwargs['power'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'pitMode', _data)
            _kwargs['pitMode'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'vtxReady', _data)
            _kwargs['vtxReady'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'lowPowerDisarm', _data)
            _kwargs['lowPowerDisarm'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'vtxTableAvailable', _data)
            _kwargs['vtxTableAvailable'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'bandCount', _data)
            _kwargs['bandCount'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'channelCount', _data)
            _kwargs['channelCount'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'powerCount', _data)
            _kwargs['powerCount'] = _val
            return cls(**_kwargs), _data


class MspSetVtxConfig:
    CODE = 89
    MSPV = 1
    """Sets VTX band/channel and related options. Fields are a progressive superset based on payload length."""
    pass

class MspAdvancedConfig:
    CODE = 90
    MSPV = 1
    """Retrieves advanced hardware-related configuration (PWM protocols, rates). Some fields are BF compatibility placeholders."""
    @dataclass
    class Reply:
        gyroSyncDenom: int = 0
        pidProcessDenom: int = 0
        useUnsyncedPwm: int = 0
        motorPwmProtocol: int = 0
        motorPwmRate: int = 0
        servoPwmRate: int = 0
        legacyGyroSync: int = 0

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.gyroSyncDenom
            out += _pack_scalar('uint8_t', 'gyroSyncDenom', _v)
            _v = self.pidProcessDenom
            out += _pack_scalar('uint8_t', 'pidProcessDenom', _v)
            _v = self.useUnsyncedPwm
            out += _pack_scalar('uint8_t', 'useUnsyncedPwm', _v)
            _v = self.motorPwmProtocol
            out += _pack_scalar('uint8_t', 'motorPwmProtocol', _v)
            _v = self.motorPwmRate
            out += _pack_scalar('uint16_t', 'motorPwmRate', _v)
            _v = self.servoPwmRate
            out += _pack_scalar('uint16_t', 'servoPwmRate', _v)
            _v = self.legacyGyroSync
            out += _pack_scalar('uint8_t', 'legacyGyroSync', _v)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Reply', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _val, _data = _unpack_scalar('uint8_t', 'gyroSyncDenom', _data)
            _kwargs['gyroSyncDenom'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'pidProcessDenom', _data)
            _kwargs['pidProcessDenom'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'useUnsyncedPwm', _data)
            _kwargs['useUnsyncedPwm'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'motorPwmProtocol', _data)
            _kwargs['motorPwmProtocol'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'motorPwmRate', _data)
            _kwargs['motorPwmRate'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'servoPwmRate', _data)
            _kwargs['servoPwmRate'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'legacyGyroSync', _data)
            _kwargs['legacyGyroSync'] = _val
            return cls(**_kwargs), _data


class MspSetAdvancedConfig:
    CODE = 91
    MSPV = 1
    """Sets advanced hardware-related configuration (PWM protocols, rates)."""
    @dataclass
    class Request:
        gyroSyncDenom: int = 0
        pidProcessDenom: int = 0
        useUnsyncedPwm: int = 0
        motorPwmProtocol: int = 0
        motorPwmRate: int = 0
        servoPwmRate: int = 0
        legacyGyroSync: int = 0

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.gyroSyncDenom
            out += _pack_scalar('uint8_t', 'gyroSyncDenom', _v)
            _v = self.pidProcessDenom
            out += _pack_scalar('uint8_t', 'pidProcessDenom', _v)
            _v = self.useUnsyncedPwm
            out += _pack_scalar('uint8_t', 'useUnsyncedPwm', _v)
            _v = self.motorPwmProtocol
            out += _pack_scalar('uint8_t', 'motorPwmProtocol', _v)
            _v = self.motorPwmRate
            out += _pack_scalar('uint16_t', 'motorPwmRate', _v)
            _v = self.servoPwmRate
            out += _pack_scalar('uint16_t', 'servoPwmRate', _v)
            _v = self.legacyGyroSync
            out += _pack_scalar('uint8_t', 'legacyGyroSync', _v)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Request', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _val, _data = _unpack_scalar('uint8_t', 'gyroSyncDenom', _data)
            _kwargs['gyroSyncDenom'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'pidProcessDenom', _data)
            _kwargs['pidProcessDenom'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'useUnsyncedPwm', _data)
            _kwargs['useUnsyncedPwm'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'motorPwmProtocol', _data)
            _kwargs['motorPwmProtocol'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'motorPwmRate', _data)
            _kwargs['motorPwmRate'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'servoPwmRate', _data)
            _kwargs['servoPwmRate'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'legacyGyroSync', _data)
            _kwargs['legacyGyroSync'] = _val
            return cls(**_kwargs), _data


class MspFilterConfig:
    CODE = 92
    MSPV = 1
    """Retrieves filter configuration settings (Gyro, D-term, Yaw, Accel). Some fields are BF compatibility placeholders or legacy."""
    @dataclass
    class Reply:
        gyroMainLpfHz: int = 0
        dtermLpfHz: int = 0
        yawLpfHz: int = 0
        legacyGyroNotchHz: int = 0
        legacyGyroNotchCutoff: int = 0
        bfCompatDtermNotchHz: int = 0
        bfCompatDtermNotchCutoff: int = 0
        bfCompatGyroNotch2Hz: int = 0
        bfCompatGyroNotch2Cutoff: int = 0
        accNotchHz: int = 0
        accNotchCutoff: int = 0
        legacyGyroStage2LpfHz: int = 0

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.gyroMainLpfHz
            out += _pack_scalar('uint8_t', 'gyroMainLpfHz', _v)
            _v = self.dtermLpfHz
            out += _pack_scalar('uint16_t', 'dtermLpfHz', _v)
            _v = self.yawLpfHz
            out += _pack_scalar('uint16_t', 'yawLpfHz', _v)
            _v = self.legacyGyroNotchHz
            out += _pack_scalar('uint16_t', 'legacyGyroNotchHz', _v)
            _v = self.legacyGyroNotchCutoff
            out += _pack_scalar('uint16_t', 'legacyGyroNotchCutoff', _v)
            _v = self.bfCompatDtermNotchHz
            out += _pack_scalar('uint16_t', 'bfCompatDtermNotchHz', _v)
            _v = self.bfCompatDtermNotchCutoff
            out += _pack_scalar('uint16_t', 'bfCompatDtermNotchCutoff', _v)
            _v = self.bfCompatGyroNotch2Hz
            out += _pack_scalar('uint16_t', 'bfCompatGyroNotch2Hz', _v)
            _v = self.bfCompatGyroNotch2Cutoff
            out += _pack_scalar('uint16_t', 'bfCompatGyroNotch2Cutoff', _v)
            _v = self.accNotchHz
            out += _pack_scalar('uint16_t', 'accNotchHz', _v)
            _v = self.accNotchCutoff
            out += _pack_scalar('uint16_t', 'accNotchCutoff', _v)
            _v = self.legacyGyroStage2LpfHz
            out += _pack_scalar('uint16_t', 'legacyGyroStage2LpfHz', _v)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Reply', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _val, _data = _unpack_scalar('uint8_t', 'gyroMainLpfHz', _data)
            _kwargs['gyroMainLpfHz'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'dtermLpfHz', _data)
            _kwargs['dtermLpfHz'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'yawLpfHz', _data)
            _kwargs['yawLpfHz'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'legacyGyroNotchHz', _data)
            _kwargs['legacyGyroNotchHz'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'legacyGyroNotchCutoff', _data)
            _kwargs['legacyGyroNotchCutoff'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'bfCompatDtermNotchHz', _data)
            _kwargs['bfCompatDtermNotchHz'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'bfCompatDtermNotchCutoff', _data)
            _kwargs['bfCompatDtermNotchCutoff'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'bfCompatGyroNotch2Hz', _data)
            _kwargs['bfCompatGyroNotch2Hz'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'bfCompatGyroNotch2Cutoff', _data)
            _kwargs['bfCompatGyroNotch2Cutoff'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'accNotchHz', _data)
            _kwargs['accNotchHz'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'accNotchCutoff', _data)
            _kwargs['accNotchCutoff'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'legacyGyroStage2LpfHz', _data)
            _kwargs['legacyGyroStage2LpfHz'] = _val
            return cls(**_kwargs), _data


class MspSetFilterConfig:
    CODE = 93
    MSPV = 1
    """Sets filter configuration settings. Handles different payload lengths for backward compatibility."""
    @dataclass
    class Request:
        gyroMainLpfHz: int = 0
        dtermLpfHz: int = 0
        yawLpfHz: int = 0
        legacyGyroNotchHz: int = 0
        legacyGyroNotchCutoff: int = 0
        bfCompatDtermNotchHz: int = 0
        bfCompatDtermNotchCutoff: int = 0
        bfCompatGyroNotch2Hz: int = 0
        bfCompatGyroNotch2Cutoff: int = 0
        accNotchHz: int = 0
        accNotchCutoff: int = 0
        legacyGyroStage2LpfHz: int = 0

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.gyroMainLpfHz
            out += _pack_scalar('uint8_t', 'gyroMainLpfHz', _v)
            _v = self.dtermLpfHz
            out += _pack_scalar('uint16_t', 'dtermLpfHz', _v)
            _v = self.yawLpfHz
            out += _pack_scalar('uint16_t', 'yawLpfHz', _v)
            _v = self.legacyGyroNotchHz
            out += _pack_scalar('uint16_t', 'legacyGyroNotchHz', _v)
            _v = self.legacyGyroNotchCutoff
            out += _pack_scalar('uint16_t', 'legacyGyroNotchCutoff', _v)
            _v = self.bfCompatDtermNotchHz
            out += _pack_scalar('uint16_t', 'bfCompatDtermNotchHz', _v)
            _v = self.bfCompatDtermNotchCutoff
            out += _pack_scalar('uint16_t', 'bfCompatDtermNotchCutoff', _v)
            _v = self.bfCompatGyroNotch2Hz
            out += _pack_scalar('uint16_t', 'bfCompatGyroNotch2Hz', _v)
            _v = self.bfCompatGyroNotch2Cutoff
            out += _pack_scalar('uint16_t', 'bfCompatGyroNotch2Cutoff', _v)
            _v = self.accNotchHz
            out += _pack_scalar('uint16_t', 'accNotchHz', _v)
            _v = self.accNotchCutoff
            out += _pack_scalar('uint16_t', 'accNotchCutoff', _v)
            _v = self.legacyGyroStage2LpfHz
            out += _pack_scalar('uint16_t', 'legacyGyroStage2LpfHz', _v)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Request', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _val, _data = _unpack_scalar('uint8_t', 'gyroMainLpfHz', _data)
            _kwargs['gyroMainLpfHz'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'dtermLpfHz', _data)
            _kwargs['dtermLpfHz'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'yawLpfHz', _data)
            _kwargs['yawLpfHz'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'legacyGyroNotchHz', _data)
            _kwargs['legacyGyroNotchHz'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'legacyGyroNotchCutoff', _data)
            _kwargs['legacyGyroNotchCutoff'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'bfCompatDtermNotchHz', _data)
            _kwargs['bfCompatDtermNotchHz'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'bfCompatDtermNotchCutoff', _data)
            _kwargs['bfCompatDtermNotchCutoff'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'bfCompatGyroNotch2Hz', _data)
            _kwargs['bfCompatGyroNotch2Hz'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'bfCompatGyroNotch2Cutoff', _data)
            _kwargs['bfCompatGyroNotch2Cutoff'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'accNotchHz', _data)
            _kwargs['accNotchHz'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'accNotchCutoff', _data)
            _kwargs['accNotchCutoff'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'legacyGyroStage2LpfHz', _data)
            _kwargs['legacyGyroStage2LpfHz'] = _val
            return cls(**_kwargs), _data


class MspPidAdvanced:
    CODE = 94
    MSPV = 1
    """Retrieves advanced PID tuning parameters. Many fields are BF compatibility placeholders."""
    @dataclass
    class Reply:
        legacyRollPitchItermIgnore: int = 0
        legacyYawItermIgnore: int = 0
        legacyYawPLimit: int = 0
        bfCompatDeltaMethod: int = 0
        bfCompatVbatPidComp: int = 0
        bfCompatSetpointRelaxRatio: int = 0
        reserved1: int = 0
        legacyPidSumLimit: int = 0
        bfCompatItermThrottleGain: int = 0
        accelLimitRollPitch: int = 0
        accelLimitYaw: int = 0

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.legacyRollPitchItermIgnore
            out += _pack_scalar('uint16_t', 'legacyRollPitchItermIgnore', _v)
            _v = self.legacyYawItermIgnore
            out += _pack_scalar('uint16_t', 'legacyYawItermIgnore', _v)
            _v = self.legacyYawPLimit
            out += _pack_scalar('uint16_t', 'legacyYawPLimit', _v)
            _v = self.bfCompatDeltaMethod
            out += _pack_scalar('uint8_t', 'bfCompatDeltaMethod', _v)
            _v = self.bfCompatVbatPidComp
            out += _pack_scalar('uint8_t', 'bfCompatVbatPidComp', _v)
            _v = self.bfCompatSetpointRelaxRatio
            out += _pack_scalar('uint8_t', 'bfCompatSetpointRelaxRatio', _v)
            _v = self.reserved1
            out += _pack_scalar('uint8_t', 'reserved1', _v)
            _v = self.legacyPidSumLimit
            out += _pack_scalar('uint16_t', 'legacyPidSumLimit', _v)
            _v = self.bfCompatItermThrottleGain
            out += _pack_scalar('uint8_t', 'bfCompatItermThrottleGain', _v)
            _v = self.accelLimitRollPitch
            out += _pack_scalar('uint16_t', 'accelLimitRollPitch', _v)
            _v = self.accelLimitYaw
            out += _pack_scalar('uint16_t', 'accelLimitYaw', _v)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Reply', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _val, _data = _unpack_scalar('uint16_t', 'legacyRollPitchItermIgnore', _data)
            _kwargs['legacyRollPitchItermIgnore'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'legacyYawItermIgnore', _data)
            _kwargs['legacyYawItermIgnore'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'legacyYawPLimit', _data)
            _kwargs['legacyYawPLimit'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'bfCompatDeltaMethod', _data)
            _kwargs['bfCompatDeltaMethod'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'bfCompatVbatPidComp', _data)
            _kwargs['bfCompatVbatPidComp'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'bfCompatSetpointRelaxRatio', _data)
            _kwargs['bfCompatSetpointRelaxRatio'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'reserved1', _data)
            _kwargs['reserved1'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'legacyPidSumLimit', _data)
            _kwargs['legacyPidSumLimit'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'bfCompatItermThrottleGain', _data)
            _kwargs['bfCompatItermThrottleGain'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'accelLimitRollPitch', _data)
            _kwargs['accelLimitRollPitch'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'accelLimitYaw', _data)
            _kwargs['accelLimitYaw'] = _val
            return cls(**_kwargs), _data


class MspSetPidAdvanced:
    CODE = 95
    MSPV = 1
    """Sets advanced PID tuning parameters."""
    @dataclass
    class Request:
        legacyRollPitchItermIgnore: int = 0
        legacyYawItermIgnore: int = 0
        legacyYawPLimit: int = 0
        bfCompatDeltaMethod: int = 0
        bfCompatVbatPidComp: int = 0
        bfCompatSetpointRelaxRatio: int = 0
        reserved1: int = 0
        legacyPidSumLimit: int = 0
        bfCompatItermThrottleGain: int = 0
        accelLimitRollPitch: int = 0
        accelLimitYaw: int = 0

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.legacyRollPitchItermIgnore
            out += _pack_scalar('uint16_t', 'legacyRollPitchItermIgnore', _v)
            _v = self.legacyYawItermIgnore
            out += _pack_scalar('uint16_t', 'legacyYawItermIgnore', _v)
            _v = self.legacyYawPLimit
            out += _pack_scalar('uint16_t', 'legacyYawPLimit', _v)
            _v = self.bfCompatDeltaMethod
            out += _pack_scalar('uint8_t', 'bfCompatDeltaMethod', _v)
            _v = self.bfCompatVbatPidComp
            out += _pack_scalar('uint8_t', 'bfCompatVbatPidComp', _v)
            _v = self.bfCompatSetpointRelaxRatio
            out += _pack_scalar('uint8_t', 'bfCompatSetpointRelaxRatio', _v)
            _v = self.reserved1
            out += _pack_scalar('uint8_t', 'reserved1', _v)
            _v = self.legacyPidSumLimit
            out += _pack_scalar('uint16_t', 'legacyPidSumLimit', _v)
            _v = self.bfCompatItermThrottleGain
            out += _pack_scalar('uint8_t', 'bfCompatItermThrottleGain', _v)
            _v = self.accelLimitRollPitch
            out += _pack_scalar('uint16_t', 'accelLimitRollPitch', _v)
            _v = self.accelLimitYaw
            out += _pack_scalar('uint16_t', 'accelLimitYaw', _v)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Request', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _val, _data = _unpack_scalar('uint16_t', 'legacyRollPitchItermIgnore', _data)
            _kwargs['legacyRollPitchItermIgnore'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'legacyYawItermIgnore', _data)
            _kwargs['legacyYawItermIgnore'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'legacyYawPLimit', _data)
            _kwargs['legacyYawPLimit'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'bfCompatDeltaMethod', _data)
            _kwargs['bfCompatDeltaMethod'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'bfCompatVbatPidComp', _data)
            _kwargs['bfCompatVbatPidComp'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'bfCompatSetpointRelaxRatio', _data)
            _kwargs['bfCompatSetpointRelaxRatio'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'reserved1', _data)
            _kwargs['reserved1'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'legacyPidSumLimit', _data)
            _kwargs['legacyPidSumLimit'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'bfCompatItermThrottleGain', _data)
            _kwargs['bfCompatItermThrottleGain'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'accelLimitRollPitch', _data)
            _kwargs['accelLimitRollPitch'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'accelLimitYaw', _data)
            _kwargs['accelLimitYaw'] = _val
            return cls(**_kwargs), _data


class MspSensorConfig:
    CODE = 96
    MSPV = 1
    """Retrieves the configured hardware type for various sensors."""
    @dataclass
    class Reply:
        accHardware: int = 0
        baroHardware: int = 0
        magHardware: int = 0
        pitotHardware: int = 0
        rangefinderHardware: int = 0
        opflowHardware: int = 0

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.accHardware
            out += _pack_scalar('uint8_t', 'accHardware', _v)
            _v = self.baroHardware
            out += _pack_scalar('uint8_t', 'baroHardware', _v)
            _v = self.magHardware
            out += _pack_scalar('uint8_t', 'magHardware', _v)
            _v = self.pitotHardware
            out += _pack_scalar('uint8_t', 'pitotHardware', _v)
            _v = self.rangefinderHardware
            out += _pack_scalar('uint8_t', 'rangefinderHardware', _v)
            _v = self.opflowHardware
            out += _pack_scalar('uint8_t', 'opflowHardware', _v)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Reply', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _val, _data = _unpack_scalar('uint8_t', 'accHardware', _data)
            _kwargs['accHardware'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'baroHardware', _data)
            _kwargs['baroHardware'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'magHardware', _data)
            _kwargs['magHardware'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'pitotHardware', _data)
            _kwargs['pitotHardware'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'rangefinderHardware', _data)
            _kwargs['rangefinderHardware'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'opflowHardware', _data)
            _kwargs['opflowHardware'] = _val
            return cls(**_kwargs), _data


class MspSetSensorConfig:
    CODE = 97
    MSPV = 1
    """Sets the configured hardware type for various sensors."""
    @dataclass
    class Request:
        accHardware: int = 0
        baroHardware: int = 0
        magHardware: int = 0
        pitotHardware: int = 0
        rangefinderHardware: int = 0
        opflowHardware: int = 0

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.accHardware
            out += _pack_scalar('uint8_t', 'accHardware', _v)
            _v = self.baroHardware
            out += _pack_scalar('uint8_t', 'baroHardware', _v)
            _v = self.magHardware
            out += _pack_scalar('uint8_t', 'magHardware', _v)
            _v = self.pitotHardware
            out += _pack_scalar('uint8_t', 'pitotHardware', _v)
            _v = self.rangefinderHardware
            out += _pack_scalar('uint8_t', 'rangefinderHardware', _v)
            _v = self.opflowHardware
            out += _pack_scalar('uint8_t', 'opflowHardware', _v)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Request', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _val, _data = _unpack_scalar('uint8_t', 'accHardware', _data)
            _kwargs['accHardware'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'baroHardware', _data)
            _kwargs['baroHardware'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'magHardware', _data)
            _kwargs['magHardware'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'pitotHardware', _data)
            _kwargs['pitotHardware'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'rangefinderHardware', _data)
            _kwargs['rangefinderHardware'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'opflowHardware', _data)
            _kwargs['opflowHardware'] = _val
            return cls(**_kwargs), _data


class MspSpecialParameters:
    CODE = 98
    MSPV = 1
    """Betaflight specific"""
    pass

class MspSetSpecialParameters:
    CODE = 99
    MSPV = 1
    """Betaflight specific"""
    pass

class MspIdent:
    CODE = 100
    MSPV = 1
    """Provides basic flight controller identity information. Not implemented in modern INAV, but used by legacy versions and MultiWii."""
    @dataclass
    class Reply:
        MultiWii version: int = 0
        Mixer Mode: int = 0
        MSP Version: int = 0
        Platform Capability: int = 0

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.MultiWii version
            out += _pack_scalar('uint8_t', 'MultiWii version', _v)
            _v = self.Mixer Mode
            out += _pack_scalar('uint8_t', 'Mixer Mode', _v)
            _v = self.MSP Version
            out += _pack_scalar('uint8_t', 'MSP Version', _v)
            _v = self.Platform Capability
            out += _pack_scalar('uint32_t', 'Platform Capability', _v)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Reply', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _val, _data = _unpack_scalar('uint8_t', 'MultiWii version', _data)
            _kwargs['MultiWii version'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'Mixer Mode', _data)
            _kwargs['Mixer Mode'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'MSP Version', _data)
            _kwargs['MSP Version'] = _val
            _val, _data = _unpack_scalar('uint32_t', 'Platform Capability', _data)
            _kwargs['Platform Capability'] = _val
            return cls(**_kwargs), _data


class MspStatus:
    CODE = 101
    MSPV = 1
    """Provides basic flight controller status including cycle time, errors, sensor status, active modes (first 32), and the current configuration profile."""
    @dataclass
    class Reply:
        cycleTime: int = 0
        i2cErrors: int = 0
        sensorStatus: int = 0
        activeModesLow: int = 0
        profile: int = 0

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.cycleTime
            out += _pack_scalar('uint16_t', 'cycleTime', _v)
            _v = self.i2cErrors
            out += _pack_scalar('uint16_t', 'i2cErrors', _v)
            _v = self.sensorStatus
            out += _pack_scalar('uint16_t', 'sensorStatus', _v)
            _v = self.activeModesLow
            out += _pack_scalar('uint32_t', 'activeModesLow', _v)
            _v = self.profile
            out += _pack_scalar('uint8_t', 'profile', _v)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Reply', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _val, _data = _unpack_scalar('uint16_t', 'cycleTime', _data)
            _kwargs['cycleTime'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'i2cErrors', _data)
            _kwargs['i2cErrors'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'sensorStatus', _data)
            _kwargs['sensorStatus'] = _val
            _val, _data = _unpack_scalar('uint32_t', 'activeModesLow', _data)
            _kwargs['activeModesLow'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'profile', _data)
            _kwargs['profile'] = _val
            return cls(**_kwargs), _data


class MspRawImu:
    CODE = 102
    MSPV = 1
    """Provides raw sensor readings from the IMU (Accelerometer, Gyroscope, Magnetometer)."""
    @dataclass
    class Reply:
        accX: int = 0
        accY: int = 0
        accZ: int = 0
        gyroX: int = 0
        gyroY: int = 0
        gyroZ: int = 0
        magX: int = 0
        magY: int = 0
        magZ: int = 0

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.accX
            out += _pack_scalar('int16_t', 'accX', _v)
            _v = self.accY
            out += _pack_scalar('int16_t', 'accY', _v)
            _v = self.accZ
            out += _pack_scalar('int16_t', 'accZ', _v)
            _v = self.gyroX
            out += _pack_scalar('int16_t', 'gyroX', _v)
            _v = self.gyroY
            out += _pack_scalar('int16_t', 'gyroY', _v)
            _v = self.gyroZ
            out += _pack_scalar('int16_t', 'gyroZ', _v)
            _v = self.magX
            out += _pack_scalar('int16_t', 'magX', _v)
            _v = self.magY
            out += _pack_scalar('int16_t', 'magY', _v)
            _v = self.magZ
            out += _pack_scalar('int16_t', 'magZ', _v)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Reply', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _val, _data = _unpack_scalar('int16_t', 'accX', _data)
            _kwargs['accX'] = _val
            _val, _data = _unpack_scalar('int16_t', 'accY', _data)
            _kwargs['accY'] = _val
            _val, _data = _unpack_scalar('int16_t', 'accZ', _data)
            _kwargs['accZ'] = _val
            _val, _data = _unpack_scalar('int16_t', 'gyroX', _data)
            _kwargs['gyroX'] = _val
            _val, _data = _unpack_scalar('int16_t', 'gyroY', _data)
            _kwargs['gyroY'] = _val
            _val, _data = _unpack_scalar('int16_t', 'gyroZ', _data)
            _kwargs['gyroZ'] = _val
            _val, _data = _unpack_scalar('int16_t', 'magX', _data)
            _kwargs['magX'] = _val
            _val, _data = _unpack_scalar('int16_t', 'magY', _data)
            _kwargs['magY'] = _val
            _val, _data = _unpack_scalar('int16_t', 'magZ', _data)
            _kwargs['magZ'] = _val
            return cls(**_kwargs), _data


class MspServo:
    CODE = 103
    MSPV = 1
    """Provides the current output values for all supported servos."""
    @dataclass
    class Reply:
        servoOutputs: List[int] = field(default_factory=list)

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.servoOutputs
            if not isinstance(_v, list):
                raise TypeError('servoOutputs must be list')
            if len(_v) != 18:
                raise ValueError('servoOutputs must have exactly 18 elements')
            for i, _e in enumerate(_v):
                out += _pack_scalar('int16_t', 'servoOutputs[{}]'.format(i), _e)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Reply', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            if len(_data) < 36:
                raise ValueError('not enough data to unpack servoOutputs')
            _tmp_v = []
            _tmp = _data[:36]
            for _i in range(18):
                _val, _tmp = _unpack_scalar('int16_t', 'servoOutputs[{}]'.format(_i), _tmp)
                _tmp_v.append(_val)
            _kwargs['servoOutputs'] = _tmp_v
            _data = _data[36:]
            return cls(**_kwargs), _data


class MspMotor:
    CODE = 104
    MSPV = 1
    """Provides the current output values for the first 8 motors."""
    @dataclass
    class Reply:
        motorOutputs: List[int] = field(default_factory=list)

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.motorOutputs
            if not isinstance(_v, list):
                raise TypeError('motorOutputs must be list')
            if len(_v) != 8:
                raise ValueError('motorOutputs must have exactly 8 elements')
            for i, _e in enumerate(_v):
                out += _pack_scalar('int16_t', 'motorOutputs[{}]'.format(i), _e)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Reply', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            if len(_data) < 16:
                raise ValueError('not enough data to unpack motorOutputs')
            _tmp_v = []
            _tmp = _data[:16]
            for _i in range(8):
                _val, _tmp = _unpack_scalar('int16_t', 'motorOutputs[{}]'.format(_i), _tmp)
                _tmp_v.append(_val)
            _kwargs['motorOutputs'] = _tmp_v
            _data = _data[16:]
            return cls(**_kwargs), _data


class MspRc:
    CODE = 105
    MSPV = 1
    """Provides the current values of the received RC channels."""
    @dataclass
    class Reply:
        rcChannels: List[int] = field(default_factory=list)

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.rcChannels
            if not isinstance(_v, list):
                raise TypeError('rcChannels must be list')
            for i, _e in enumerate(_v):
                out += _pack_scalar('int16_t', 'rcChannels[{}]'.format(i), _e)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Reply', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _alen = hints.get('rcChannels_len')
            if _alen is None:
                raise ValueError('missing hint: rcChannels_len for variable length array')
            elem_size = 2
            total = int(_alen) * elem_size
            if len(_data) < total:
                raise ValueError('not enough data to unpack rcChannels')
            _tmp_v = []
            _tmp = _data[:total]
            for _i in range(int(_alen)):
                _val, _tmp = _unpack_scalar('int16_t', 'rcChannels[{}]'.format(_i), _tmp)
                _tmp_v.append(_val)
            _kwargs['rcChannels'] = _tmp_v
            _data = _data[total:]
            return cls(**_kwargs), _data


class MspRawGps:
    CODE = 106
    MSPV = 1
    """Provides raw GPS data (fix status, coordinates, altitude, speed, course)."""
    @dataclass
    class Reply:
        fixType: int = 0
        numSat: int = 0
        latitude: int = 0
        longitude: int = 0
        altitude: int = 0
        speed: int = 0
        groundCourse: int = 0
        hdop: int = 0

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.fixType
            out += _pack_scalar('uint8_t', 'fixType', _v)
            _v = self.numSat
            out += _pack_scalar('uint8_t', 'numSat', _v)
            _v = self.latitude
            out += _pack_scalar('int32_t', 'latitude', _v)
            _v = self.longitude
            out += _pack_scalar('int32_t', 'longitude', _v)
            _v = self.altitude
            out += _pack_scalar('int16_t', 'altitude', _v)
            _v = self.speed
            out += _pack_scalar('int16_t', 'speed', _v)
            _v = self.groundCourse
            out += _pack_scalar('int16_t', 'groundCourse', _v)
            _v = self.hdop
            out += _pack_scalar('uint16_t', 'hdop', _v)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Reply', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _val, _data = _unpack_scalar('uint8_t', 'fixType', _data)
            _kwargs['fixType'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'numSat', _data)
            _kwargs['numSat'] = _val
            _val, _data = _unpack_scalar('int32_t', 'latitude', _data)
            _kwargs['latitude'] = _val
            _val, _data = _unpack_scalar('int32_t', 'longitude', _data)
            _kwargs['longitude'] = _val
            _val, _data = _unpack_scalar('int16_t', 'altitude', _data)
            _kwargs['altitude'] = _val
            _val, _data = _unpack_scalar('int16_t', 'speed', _data)
            _kwargs['speed'] = _val
            _val, _data = _unpack_scalar('int16_t', 'groundCourse', _data)
            _kwargs['groundCourse'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'hdop', _data)
            _kwargs['hdop'] = _val
            return cls(**_kwargs), _data


class MspCompGps:
    CODE = 107
    MSPV = 1
    """Provides computed GPS values: distance and direction to home."""
    @dataclass
    class Reply:
        distanceToHome: int = 0
        directionToHome: int = 0
        gpsHeartbeat: int = 0

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.distanceToHome
            out += _pack_scalar('uint16_t', 'distanceToHome', _v)
            _v = self.directionToHome
            out += _pack_scalar('int16_t', 'directionToHome', _v)
            _v = self.gpsHeartbeat
            out += _pack_scalar('uint8_t', 'gpsHeartbeat', _v)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Reply', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _val, _data = _unpack_scalar('uint16_t', 'distanceToHome', _data)
            _kwargs['distanceToHome'] = _val
            _val, _data = _unpack_scalar('int16_t', 'directionToHome', _data)
            _kwargs['directionToHome'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'gpsHeartbeat', _data)
            _kwargs['gpsHeartbeat'] = _val
            return cls(**_kwargs), _data


class MspAttitude:
    CODE = 108
    MSPV = 1
    """Provides the current attitude estimate (roll, pitch, yaw)."""
    @dataclass
    class Reply:
        roll: int = 0
        pitch: int = 0
        yaw: int = 0

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.roll
            out += _pack_scalar('int16_t', 'roll', _v)
            _v = self.pitch
            out += _pack_scalar('int16_t', 'pitch', _v)
            _v = self.yaw
            out += _pack_scalar('uint16_t', 'yaw', _v)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Reply', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _val, _data = _unpack_scalar('int16_t', 'roll', _data)
            _kwargs['roll'] = _val
            _val, _data = _unpack_scalar('int16_t', 'pitch', _data)
            _kwargs['pitch'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'yaw', _data)
            _kwargs['yaw'] = _val
            return cls(**_kwargs), _data


class MspAltitude:
    CODE = 109
    MSPV = 1
    """Provides estimated altitude, vertical speed (variometer), and raw barometric altitude."""
    @dataclass
    class Reply:
        estimatedAltitude: int = 0
        variometer: int = 0
        baroAltitude: int = 0

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.estimatedAltitude
            out += _pack_scalar('int32_t', 'estimatedAltitude', _v)
            _v = self.variometer
            out += _pack_scalar('int16_t', 'variometer', _v)
            _v = self.baroAltitude
            out += _pack_scalar('int32_t', 'baroAltitude', _v)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Reply', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _val, _data = _unpack_scalar('int32_t', 'estimatedAltitude', _data)
            _kwargs['estimatedAltitude'] = _val
            _val, _data = _unpack_scalar('int16_t', 'variometer', _data)
            _kwargs['variometer'] = _val
            _val, _data = _unpack_scalar('int32_t', 'baroAltitude', _data)
            _kwargs['baroAltitude'] = _val
            return cls(**_kwargs), _data


class MspAnalog:
    CODE = 110
    MSPV = 1
    """Provides analog sensor readings: battery voltage, current consumption (mAh), RSSI, and current draw (Amps)."""
    @dataclass
    class Reply:
        vbat: int = 0
        mAhDrawn: int = 0
        rssi: int = 0
        amperage: int = 0

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.vbat
            out += _pack_scalar('uint8_t', 'vbat', _v)
            _v = self.mAhDrawn
            out += _pack_scalar('uint16_t', 'mAhDrawn', _v)
            _v = self.rssi
            out += _pack_scalar('uint16_t', 'rssi', _v)
            _v = self.amperage
            out += _pack_scalar('int16_t', 'amperage', _v)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Reply', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _val, _data = _unpack_scalar('uint8_t', 'vbat', _data)
            _kwargs['vbat'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'mAhDrawn', _data)
            _kwargs['mAhDrawn'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'rssi', _data)
            _kwargs['rssi'] = _val
            _val, _data = _unpack_scalar('int16_t', 'amperage', _data)
            _kwargs['amperage'] = _val
            return cls(**_kwargs), _data


class MspRcTuning:
    CODE = 111
    MSPV = 1
    """Retrieves RC tuning parameters (rates, expos, TPA) for the current control rate profile."""
    @dataclass
    class Reply:
        legacyRcRate: int = 0
        rcExpo: int = 0
        rollRate: int = 0
        pitchRate: int = 0
        yawRate: int = 0
        dynamicThrottlePID: int = 0
        throttleMid: int = 0
        throttleExpo: int = 0
        tpaBreakpoint: int = 0
        rcYawExpo: int = 0

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.legacyRcRate
            out += _pack_scalar('uint8_t', 'legacyRcRate', _v)
            _v = self.rcExpo
            out += _pack_scalar('uint8_t', 'rcExpo', _v)
            _v = self.rollRate
            out += _pack_scalar('uint8_t', 'rollRate', _v)
            _v = self.pitchRate
            out += _pack_scalar('uint8_t', 'pitchRate', _v)
            _v = self.yawRate
            out += _pack_scalar('uint8_t', 'yawRate', _v)
            _v = self.dynamicThrottlePID
            out += _pack_scalar('uint8_t', 'dynamicThrottlePID', _v)
            _v = self.throttleMid
            out += _pack_scalar('uint8_t', 'throttleMid', _v)
            _v = self.throttleExpo
            out += _pack_scalar('uint8_t', 'throttleExpo', _v)
            _v = self.tpaBreakpoint
            out += _pack_scalar('uint16_t', 'tpaBreakpoint', _v)
            _v = self.rcYawExpo
            out += _pack_scalar('uint8_t', 'rcYawExpo', _v)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Reply', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _val, _data = _unpack_scalar('uint8_t', 'legacyRcRate', _data)
            _kwargs['legacyRcRate'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'rcExpo', _data)
            _kwargs['rcExpo'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'rollRate', _data)
            _kwargs['rollRate'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'pitchRate', _data)
            _kwargs['pitchRate'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'yawRate', _data)
            _kwargs['yawRate'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'dynamicThrottlePID', _data)
            _kwargs['dynamicThrottlePID'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'throttleMid', _data)
            _kwargs['throttleMid'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'throttleExpo', _data)
            _kwargs['throttleExpo'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'tpaBreakpoint', _data)
            _kwargs['tpaBreakpoint'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'rcYawExpo', _data)
            _kwargs['rcYawExpo'] = _val
            return cls(**_kwargs), _data


class MspActiveboxes:
    CODE = 113
    MSPV = 1
    """Provides the full bitmask of currently active flight modes (boxes)."""
    @dataclass
    class Reply:
        activeModes: int = 0

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.activeModes
            out += _pack_scalar('boxBitmask_t', 'activeModes', _v)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Reply', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _val, _data = _unpack_scalar('boxBitmask_t', 'activeModes', _data)
            _kwargs['activeModes'] = _val
            return cls(**_kwargs), _data


class MspMisc:
    CODE = 114
    MSPV = 1
    """Retrieves miscellaneous configuration settings, mostly related to RC, GPS, Mag, and Battery voltage (legacy formats)."""
    @dataclass
    class Reply:
        midRc: int = 0
        legacyMinThrottle: int = 0
        maxThrottle: int = 0
        minCommand: int = 0
        failsafeThrottle: int = 0
        gpsType: int = 0
        legacyGpsBaud: int = 0
        gpsSbasMode: int = 0
        legacyMwCurrentOut: int = 0
        rssiChannel: int = 0
        reserved1: int = 0
        magDeclination: int = 0
        vbatScale: int = 0
        vbatMinCell: int = 0
        vbatMaxCell: int = 0
        vbatWarningCell: int = 0

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.midRc
            out += _pack_scalar('uint16_t', 'midRc', _v)
            _v = self.legacyMinThrottle
            out += _pack_scalar('uint16_t', 'legacyMinThrottle', _v)
            _v = self.maxThrottle
            out += _pack_scalar('uint16_t', 'maxThrottle', _v)
            _v = self.minCommand
            out += _pack_scalar('uint16_t', 'minCommand', _v)
            _v = self.failsafeThrottle
            out += _pack_scalar('uint16_t', 'failsafeThrottle', _v)
            _v = self.gpsType
            out += _pack_scalar('uint8_t', 'gpsType', _v)
            _v = self.legacyGpsBaud
            out += _pack_scalar('uint8_t', 'legacyGpsBaud', _v)
            _v = self.gpsSbasMode
            out += _pack_scalar('uint8_t', 'gpsSbasMode', _v)
            _v = self.legacyMwCurrentOut
            out += _pack_scalar('uint8_t', 'legacyMwCurrentOut', _v)
            _v = self.rssiChannel
            out += _pack_scalar('uint8_t', 'rssiChannel', _v)
            _v = self.reserved1
            out += _pack_scalar('uint8_t', 'reserved1', _v)
            _v = self.magDeclination
            out += _pack_scalar('uint16_t', 'magDeclination', _v)
            _v = self.vbatScale
            out += _pack_scalar('uint8_t', 'vbatScale', _v)
            _v = self.vbatMinCell
            out += _pack_scalar('uint8_t', 'vbatMinCell', _v)
            _v = self.vbatMaxCell
            out += _pack_scalar('uint8_t', 'vbatMaxCell', _v)
            _v = self.vbatWarningCell
            out += _pack_scalar('uint8_t', 'vbatWarningCell', _v)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Reply', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _val, _data = _unpack_scalar('uint16_t', 'midRc', _data)
            _kwargs['midRc'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'legacyMinThrottle', _data)
            _kwargs['legacyMinThrottle'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'maxThrottle', _data)
            _kwargs['maxThrottle'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'minCommand', _data)
            _kwargs['minCommand'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'failsafeThrottle', _data)
            _kwargs['failsafeThrottle'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'gpsType', _data)
            _kwargs['gpsType'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'legacyGpsBaud', _data)
            _kwargs['legacyGpsBaud'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'gpsSbasMode', _data)
            _kwargs['gpsSbasMode'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'legacyMwCurrentOut', _data)
            _kwargs['legacyMwCurrentOut'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'rssiChannel', _data)
            _kwargs['rssiChannel'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'reserved1', _data)
            _kwargs['reserved1'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'magDeclination', _data)
            _kwargs['magDeclination'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'vbatScale', _data)
            _kwargs['vbatScale'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'vbatMinCell', _data)
            _kwargs['vbatMinCell'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'vbatMaxCell', _data)
            _kwargs['vbatMaxCell'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'vbatWarningCell', _data)
            _kwargs['vbatWarningCell'] = _val
            return cls(**_kwargs), _data


class MspBoxnames:
    CODE = 116
    MSPV = 1
    """Provides a semicolon-separated string containing the names of all available flight modes (boxes)."""
    @dataclass
    class Reply:
        boxNamesString: bytes = b''

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.boxNamesString
            if not isinstance(_v, (bytes, bytearray)):
                raise TypeError('boxNamesString must be bytes for variable length char array')
            out += _v
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Reply', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _len = hints.get('boxNamesString_len', len(_data))
            if len(_data) < _len:
                raise ValueError('not enough data to unpack boxNamesString variable bytes')
            _kwargs['boxNamesString'] = _data[:_len]
            _data = _data[_len:]
            return cls(**_kwargs), _data


class MspPidnames:
    CODE = 117
    MSPV = 1
    """Provides a semicolon-separated string containing the names of the PID controllers."""
    @dataclass
    class Reply:
        pidNamesString: bytes = b''

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.pidNamesString
            if not isinstance(_v, (bytes, bytearray)):
                raise TypeError('pidNamesString must be bytes for variable length char array')
            out += _v
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Reply', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _len = hints.get('pidNamesString_len', len(_data))
            if len(_data) < _len:
                raise ValueError('not enough data to unpack pidNamesString variable bytes')
            _kwargs['pidNamesString'] = _data[:_len]
            _data = _data[_len:]
            return cls(**_kwargs), _data


class MspWp:
    CODE = 118
    MSPV = 1
    """Get/Set a single waypoint from the mission plan."""
    @dataclass
    class Request:
        waypointIndex: int = 0

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.waypointIndex
            out += _pack_scalar('uint8_t', 'waypointIndex', _v)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Request', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _val, _data = _unpack_scalar('uint8_t', 'waypointIndex', _data)
            _kwargs['waypointIndex'] = _val
            return cls(**_kwargs), _data

    @dataclass
    class Reply:
        waypointIndex: int = 0
        action: int = 0
        latitude: int = 0
        longitude: int = 0
        altitude: int = 0
        param1: int = 0
        param2: int = 0
        param3: int = 0
        flag: int = 0

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.waypointIndex
            out += _pack_scalar('uint8_t', 'waypointIndex', _v)
            _v = self.action
            out += _pack_scalar('uint8_t', 'action', _v)
            _v = self.latitude
            out += _pack_scalar('int32_t', 'latitude', _v)
            _v = self.longitude
            out += _pack_scalar('int32_t', 'longitude', _v)
            _v = self.altitude
            out += _pack_scalar('int32_t', 'altitude', _v)
            _v = self.param1
            out += _pack_scalar('int16_t', 'param1', _v)
            _v = self.param2
            out += _pack_scalar('int16_t', 'param2', _v)
            _v = self.param3
            out += _pack_scalar('int16_t', 'param3', _v)
            _v = self.flag
            out += _pack_scalar('uint8_t', 'flag', _v)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Reply', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _val, _data = _unpack_scalar('uint8_t', 'waypointIndex', _data)
            _kwargs['waypointIndex'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'action', _data)
            _kwargs['action'] = _val
            _val, _data = _unpack_scalar('int32_t', 'latitude', _data)
            _kwargs['latitude'] = _val
            _val, _data = _unpack_scalar('int32_t', 'longitude', _data)
            _kwargs['longitude'] = _val
            _val, _data = _unpack_scalar('int32_t', 'altitude', _data)
            _kwargs['altitude'] = _val
            _val, _data = _unpack_scalar('int16_t', 'param1', _data)
            _kwargs['param1'] = _val
            _val, _data = _unpack_scalar('int16_t', 'param2', _data)
            _kwargs['param2'] = _val
            _val, _data = _unpack_scalar('int16_t', 'param3', _data)
            _kwargs['param3'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'flag', _data)
            _kwargs['flag'] = _val
            return cls(**_kwargs), _data


class MspBoxids:
    CODE = 119
    MSPV = 1
    """Provides a list of permanent IDs associated with the available flight modes (boxes)."""
    @dataclass
    class Reply:
        boxIds: List[int] = field(default_factory=list)

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.boxIds
            if not isinstance(_v, list):
                raise TypeError('boxIds must be list')
            for i, _e in enumerate(_v):
                out += _pack_scalar('uint8_t', 'boxIds[{}]'.format(i), _e)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Reply', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _alen = hints.get('boxIds_len')
            if _alen is None:
                raise ValueError('missing hint: boxIds_len for variable length array')
            elem_size = 1
            total = int(_alen) * elem_size
            if len(_data) < total:
                raise ValueError('not enough data to unpack boxIds')
            _tmp_v = []
            _tmp = _data[:total]
            for _i in range(int(_alen)):
                _val, _tmp = _unpack_scalar('uint8_t', 'boxIds[{}]'.format(_i), _tmp)
                _tmp_v.append(_val)
            _kwargs['boxIds'] = _tmp_v
            _data = _data[total:]
            return cls(**_kwargs), _data


class MspServoConfigurations:
    CODE = 120
    MSPV = 1
    """Retrieves the configuration parameters for all supported servos (min, max, middle, rate). Legacy format with unused fields."""
    @dataclass
    class Reply:
        min: int = 0
        max: int = 0
        middle: int = 0
        rate: int = 0
        reserved1: int = 0
        reserved2: int = 0
        legacyForwardChan: int = 0
        legacyReversedSources: int = 0

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.min
            out += _pack_scalar('int16_t', 'min', _v)
            _v = self.max
            out += _pack_scalar('int16_t', 'max', _v)
            _v = self.middle
            out += _pack_scalar('int16_t', 'middle', _v)
            _v = self.rate
            out += _pack_scalar('int8_t', 'rate', _v)
            _v = self.reserved1
            out += _pack_scalar('uint8_t', 'reserved1', _v)
            _v = self.reserved2
            out += _pack_scalar('uint8_t', 'reserved2', _v)
            _v = self.legacyForwardChan
            out += _pack_scalar('uint8_t', 'legacyForwardChan', _v)
            _v = self.legacyReversedSources
            out += _pack_scalar('uint32_t', 'legacyReversedSources', _v)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Reply', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _val, _data = _unpack_scalar('int16_t', 'min', _data)
            _kwargs['min'] = _val
            _val, _data = _unpack_scalar('int16_t', 'max', _data)
            _kwargs['max'] = _val
            _val, _data = _unpack_scalar('int16_t', 'middle', _data)
            _kwargs['middle'] = _val
            _val, _data = _unpack_scalar('int8_t', 'rate', _data)
            _kwargs['rate'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'reserved1', _data)
            _kwargs['reserved1'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'reserved2', _data)
            _kwargs['reserved2'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'legacyForwardChan', _data)
            _kwargs['legacyForwardChan'] = _val
            _val, _data = _unpack_scalar('uint32_t', 'legacyReversedSources', _data)
            _kwargs['legacyReversedSources'] = _val
            return cls(**_kwargs), _data


class MspNavStatus:
    CODE = 121
    MSPV = 1
    """Retrieves the current status of the navigation system."""
    @dataclass
    class Reply:
        navMode: int = 0
        navState: int = 0
        activeWpAction: int = 0
        activeWpNumber: int = 0
        navError: int = 0
        targetHeading: int = 0

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.navMode
            out += _pack_scalar('uint8_t', 'navMode', _v)
            _v = self.navState
            out += _pack_scalar('uint8_t', 'navState', _v)
            _v = self.activeWpAction
            out += _pack_scalar('uint8_t', 'activeWpAction', _v)
            _v = self.activeWpNumber
            out += _pack_scalar('uint8_t', 'activeWpNumber', _v)
            _v = self.navError
            out += _pack_scalar('uint8_t', 'navError', _v)
            _v = self.targetHeading
            out += _pack_scalar('int16_t', 'targetHeading', _v)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Reply', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _val, _data = _unpack_scalar('uint8_t', 'navMode', _data)
            _kwargs['navMode'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'navState', _data)
            _kwargs['navState'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'activeWpAction', _data)
            _kwargs['activeWpAction'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'activeWpNumber', _data)
            _kwargs['activeWpNumber'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'navError', _data)
            _kwargs['navError'] = _val
            _val, _data = _unpack_scalar('int16_t', 'targetHeading', _data)
            _kwargs['targetHeading'] = _val
            return cls(**_kwargs), _data


class MspNavConfig:
    CODE = 122
    MSPV = 1
    """"""
    pass

class Msp3d:
    CODE = 124
    MSPV = 1
    """Retrieves settings related to 3D/reversible motor operation."""
    @dataclass
    class Reply:
        deadbandLow: int = 0
        deadbandHigh: int = 0
        neutral: int = 0

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.deadbandLow
            out += _pack_scalar('uint16_t', 'deadbandLow', _v)
            _v = self.deadbandHigh
            out += _pack_scalar('uint16_t', 'deadbandHigh', _v)
            _v = self.neutral
            out += _pack_scalar('uint16_t', 'neutral', _v)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Reply', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _val, _data = _unpack_scalar('uint16_t', 'deadbandLow', _data)
            _kwargs['deadbandLow'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'deadbandHigh', _data)
            _kwargs['deadbandHigh'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'neutral', _data)
            _kwargs['neutral'] = _val
            return cls(**_kwargs), _data


class MspRcDeadband:
    CODE = 125
    MSPV = 1
    """Retrieves RC input deadband settings."""
    @dataclass
    class Reply:
        deadband: int = 0
        yawDeadband: int = 0
        altHoldDeadband: int = 0
        throttleDeadband: int = 0

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.deadband
            out += _pack_scalar('uint8_t', 'deadband', _v)
            _v = self.yawDeadband
            out += _pack_scalar('uint8_t', 'yawDeadband', _v)
            _v = self.altHoldDeadband
            out += _pack_scalar('uint8_t', 'altHoldDeadband', _v)
            _v = self.throttleDeadband
            out += _pack_scalar('uint16_t', 'throttleDeadband', _v)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Reply', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _val, _data = _unpack_scalar('uint8_t', 'deadband', _data)
            _kwargs['deadband'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'yawDeadband', _data)
            _kwargs['yawDeadband'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'altHoldDeadband', _data)
            _kwargs['altHoldDeadband'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'throttleDeadband', _data)
            _kwargs['throttleDeadband'] = _val
            return cls(**_kwargs), _data


class MspSensorAlignment:
    CODE = 126
    MSPV = 1
    """Retrieves sensor alignment settings (legacy format)."""
    @dataclass
    class Reply:
        gyroAlign: int = 0
        accAlign: int = 0
        magAlign: int = 0
        opflowAlign: int = 0

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.gyroAlign
            out += _pack_scalar('uint8_t', 'gyroAlign', _v)
            _v = self.accAlign
            out += _pack_scalar('uint8_t', 'accAlign', _v)
            _v = self.magAlign
            out += _pack_scalar('uint8_t', 'magAlign', _v)
            _v = self.opflowAlign
            out += _pack_scalar('uint8_t', 'opflowAlign', _v)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Reply', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _val, _data = _unpack_scalar('uint8_t', 'gyroAlign', _data)
            _kwargs['gyroAlign'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'accAlign', _data)
            _kwargs['accAlign'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'magAlign', _data)
            _kwargs['magAlign'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'opflowAlign', _data)
            _kwargs['opflowAlign'] = _val
            return cls(**_kwargs), _data


class MspLedStripModecolor:
    CODE = 127
    MSPV = 1
    """Retrieves the color index assigned to each LED mode and function/direction combination, including special colors."""
    @dataclass
    class Reply:
        modeIndex: int = 0
        directionOrSpecialIndex: int = 0
        colorIndex: int = 0

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.modeIndex
            out += _pack_scalar('uint8_t', 'modeIndex', _v)
            _v = self.directionOrSpecialIndex
            out += _pack_scalar('uint8_t', 'directionOrSpecialIndex', _v)
            _v = self.colorIndex
            out += _pack_scalar('uint8_t', 'colorIndex', _v)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Reply', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _val, _data = _unpack_scalar('uint8_t', 'modeIndex', _data)
            _kwargs['modeIndex'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'directionOrSpecialIndex', _data)
            _kwargs['directionOrSpecialIndex'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'colorIndex', _data)
            _kwargs['colorIndex'] = _val
            return cls(**_kwargs), _data


class MspBatteryState:
    CODE = 130
    MSPV = 1
    """Provides battery state information, formatted primarily for DJI FPV Goggles compatibility."""
    @dataclass
    class Reply:
        cellCount: int = 0
        capacity: int = 0
        vbatScaled: int = 0
        mAhDrawn: int = 0
        amperage: int = 0
        batteryState: int = 0
        vbatActual: int = 0

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.cellCount
            out += _pack_scalar('uint8_t', 'cellCount', _v)
            _v = self.capacity
            out += _pack_scalar('uint16_t', 'capacity', _v)
            _v = self.vbatScaled
            out += _pack_scalar('uint8_t', 'vbatScaled', _v)
            _v = self.mAhDrawn
            out += _pack_scalar('uint16_t', 'mAhDrawn', _v)
            _v = self.amperage
            out += _pack_scalar('int16_t', 'amperage', _v)
            _v = self.batteryState
            out += _pack_scalar('uint8_t', 'batteryState', _v)
            _v = self.vbatActual
            out += _pack_scalar('uint16_t', 'vbatActual', _v)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Reply', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _val, _data = _unpack_scalar('uint8_t', 'cellCount', _data)
            _kwargs['cellCount'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'capacity', _data)
            _kwargs['capacity'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'vbatScaled', _data)
            _kwargs['vbatScaled'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'mAhDrawn', _data)
            _kwargs['mAhDrawn'] = _val
            _val, _data = _unpack_scalar('int16_t', 'amperage', _data)
            _kwargs['amperage'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'batteryState', _data)
            _kwargs['batteryState'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'vbatActual', _data)
            _kwargs['vbatActual'] = _val
            return cls(**_kwargs), _data


class MspVtxtableBand:
    CODE = 137
    MSPV = 1
    """Retrieves information about a specific VTX band from the VTX table. (Implementation missing in provided `fc_msp.c`)"""
    pass

class MspVtxtablePowerlevel:
    CODE = 138
    MSPV = 1
    """Retrieves information about a specific VTX power level from the VTX table."""
    @dataclass
    class Request:
        powerLevelIndex: int = 0

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.powerLevelIndex
            out += _pack_scalar('uint8_t', 'powerLevelIndex', _v)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Request', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _val, _data = _unpack_scalar('uint8_t', 'powerLevelIndex', _data)
            _kwargs['powerLevelIndex'] = _val
            return cls(**_kwargs), _data

    @dataclass
    class Reply:
        powerLevelIndex: int = 0
        powerValue: int = 0
        labelLength: int = 0
        label: bytes = b''

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.powerLevelIndex
            out += _pack_scalar('uint8_t', 'powerLevelIndex', _v)
            _v = self.powerValue
            out += _pack_scalar('uint16_t', 'powerValue', _v)
            _v = self.labelLength
            out += _pack_scalar('uint8_t', 'labelLength', _v)
            _v = self.label
            if not isinstance(_v, (bytes, bytearray)):
                raise TypeError('label must be bytes for variable length char array')
            out += _v
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Reply', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _val, _data = _unpack_scalar('uint8_t', 'powerLevelIndex', _data)
            _kwargs['powerLevelIndex'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'powerValue', _data)
            _kwargs['powerValue'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'labelLength', _data)
            _kwargs['labelLength'] = _val
            _len = hints.get('label_len', len(_data))
            if len(_data) < _len:
                raise ValueError('not enough data to unpack label variable bytes')
            _kwargs['label'] = _data[:_len]
            _data = _data[_len:]
            return cls(**_kwargs), _data


class MspStatusEx:
    CODE = 150
    MSPV = 1
    """Provides extended flight controller status, including CPU load, arming flags, and calibration status, in addition to `MSP_STATUS` fields."""
    @dataclass
    class Reply:
        cycleTime: int = 0
        i2cErrors: int = 0
        sensorStatus: int = 0
        activeModesLow: int = 0
        profile: int = 0
        cpuLoad: int = 0
        armingFlags: int = 0
        accCalibAxisFlags: int = 0

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.cycleTime
            out += _pack_scalar('uint16_t', 'cycleTime', _v)
            _v = self.i2cErrors
            out += _pack_scalar('uint16_t', 'i2cErrors', _v)
            _v = self.sensorStatus
            out += _pack_scalar('uint16_t', 'sensorStatus', _v)
            _v = self.activeModesLow
            out += _pack_scalar('uint32_t', 'activeModesLow', _v)
            _v = self.profile
            out += _pack_scalar('uint8_t', 'profile', _v)
            _v = self.cpuLoad
            out += _pack_scalar('uint16_t', 'cpuLoad', _v)
            _v = self.armingFlags
            out += _pack_scalar('uint16_t', 'armingFlags', _v)
            _v = self.accCalibAxisFlags
            out += _pack_scalar('uint8_t', 'accCalibAxisFlags', _v)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Reply', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _val, _data = _unpack_scalar('uint16_t', 'cycleTime', _data)
            _kwargs['cycleTime'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'i2cErrors', _data)
            _kwargs['i2cErrors'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'sensorStatus', _data)
            _kwargs['sensorStatus'] = _val
            _val, _data = _unpack_scalar('uint32_t', 'activeModesLow', _data)
            _kwargs['activeModesLow'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'profile', _data)
            _kwargs['profile'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'cpuLoad', _data)
            _kwargs['cpuLoad'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'armingFlags', _data)
            _kwargs['armingFlags'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'accCalibAxisFlags', _data)
            _kwargs['accCalibAxisFlags'] = _val
            return cls(**_kwargs), _data


class MspSensorStatus:
    CODE = 151
    MSPV = 1
    """Provides the hardware status for each individual sensor system."""
    @dataclass
    class Reply:
        overallHealth: int = 0
        gyroStatus: int = 0
        accStatus: int = 0
        magStatus: int = 0
        baroStatus: int = 0
        gpsStatus: int = 0
        rangefinderStatus: int = 0
        pitotStatus: int = 0
        opflowStatus: int = 0

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.overallHealth
            out += _pack_scalar('uint8_t', 'overallHealth', _v)
            _v = self.gyroStatus
            out += _pack_scalar('uint8_t', 'gyroStatus', _v)
            _v = self.accStatus
            out += _pack_scalar('uint8_t', 'accStatus', _v)
            _v = self.magStatus
            out += _pack_scalar('uint8_t', 'magStatus', _v)
            _v = self.baroStatus
            out += _pack_scalar('uint8_t', 'baroStatus', _v)
            _v = self.gpsStatus
            out += _pack_scalar('uint8_t', 'gpsStatus', _v)
            _v = self.rangefinderStatus
            out += _pack_scalar('uint8_t', 'rangefinderStatus', _v)
            _v = self.pitotStatus
            out += _pack_scalar('uint8_t', 'pitotStatus', _v)
            _v = self.opflowStatus
            out += _pack_scalar('uint8_t', 'opflowStatus', _v)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Reply', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _val, _data = _unpack_scalar('uint8_t', 'overallHealth', _data)
            _kwargs['overallHealth'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'gyroStatus', _data)
            _kwargs['gyroStatus'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'accStatus', _data)
            _kwargs['accStatus'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'magStatus', _data)
            _kwargs['magStatus'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'baroStatus', _data)
            _kwargs['baroStatus'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'gpsStatus', _data)
            _kwargs['gpsStatus'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'rangefinderStatus', _data)
            _kwargs['rangefinderStatus'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'pitotStatus', _data)
            _kwargs['pitotStatus'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'opflowStatus', _data)
            _kwargs['opflowStatus'] = _val
            return cls(**_kwargs), _data


class MspUid:
    CODE = 160
    MSPV = 1
    """Provides the unique identifier of the microcontroller."""
    @dataclass
    class Reply:
        uid0: int = 0
        uid1: int = 0
        uid2: int = 0

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.uid0
            out += _pack_scalar('uint32_t', 'uid0', _v)
            _v = self.uid1
            out += _pack_scalar('uint32_t', 'uid1', _v)
            _v = self.uid2
            out += _pack_scalar('uint32_t', 'uid2', _v)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Reply', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _val, _data = _unpack_scalar('uint32_t', 'uid0', _data)
            _kwargs['uid0'] = _val
            _val, _data = _unpack_scalar('uint32_t', 'uid1', _data)
            _kwargs['uid1'] = _val
            _val, _data = _unpack_scalar('uint32_t', 'uid2', _data)
            _kwargs['uid2'] = _val
            return cls(**_kwargs), _data


class MspGpssvinfo:
    CODE = 164
    MSPV = 1
    """Provides satellite signal strength information (legacy U-Blox compatibility stub)."""
    @dataclass
    class Reply:
        protocolVersion: int = 0
        numChannels: int = 0
        hdopHundredsDigit: int = 0
        hdopTensDigit: int = 0
        hdopUnitsDigit: int = 0

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.protocolVersion
            out += _pack_scalar('uint8_t', 'protocolVersion', _v)
            _v = self.numChannels
            out += _pack_scalar('uint8_t', 'numChannels', _v)
            _v = self.hdopHundredsDigit
            out += _pack_scalar('uint8_t', 'hdopHundredsDigit', _v)
            _v = self.hdopTensDigit
            out += _pack_scalar('uint8_t', 'hdopTensDigit', _v)
            _v = self.hdopUnitsDigit
            out += _pack_scalar('uint8_t', 'hdopUnitsDigit', _v)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Reply', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _val, _data = _unpack_scalar('uint8_t', 'protocolVersion', _data)
            _kwargs['protocolVersion'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'numChannels', _data)
            _kwargs['numChannels'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'hdopHundredsDigit', _data)
            _kwargs['hdopHundredsDigit'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'hdopTensDigit', _data)
            _kwargs['hdopTensDigit'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'hdopUnitsDigit', _data)
            _kwargs['hdopUnitsDigit'] = _val
            return cls(**_kwargs), _data


class MspGpsstatistics:
    CODE = 166
    MSPV = 1
    """Provides debugging statistics for the GPS communication link."""
    @dataclass
    class Reply:
        lastMessageDt: int = 0
        errors: int = 0
        timeouts: int = 0
        packetCount: int = 0
        hdop: int = 0
        eph: int = 0
        epv: int = 0

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.lastMessageDt
            out += _pack_scalar('uint16_t', 'lastMessageDt', _v)
            _v = self.errors
            out += _pack_scalar('uint32_t', 'errors', _v)
            _v = self.timeouts
            out += _pack_scalar('uint32_t', 'timeouts', _v)
            _v = self.packetCount
            out += _pack_scalar('uint32_t', 'packetCount', _v)
            _v = self.hdop
            out += _pack_scalar('uint16_t', 'hdop', _v)
            _v = self.eph
            out += _pack_scalar('uint16_t', 'eph', _v)
            _v = self.epv
            out += _pack_scalar('uint16_t', 'epv', _v)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Reply', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _val, _data = _unpack_scalar('uint16_t', 'lastMessageDt', _data)
            _kwargs['lastMessageDt'] = _val
            _val, _data = _unpack_scalar('uint32_t', 'errors', _data)
            _kwargs['errors'] = _val
            _val, _data = _unpack_scalar('uint32_t', 'timeouts', _data)
            _kwargs['timeouts'] = _val
            _val, _data = _unpack_scalar('uint32_t', 'packetCount', _data)
            _kwargs['packetCount'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'hdop', _data)
            _kwargs['hdop'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'eph', _data)
            _kwargs['eph'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'epv', _data)
            _kwargs['epv'] = _val
            return cls(**_kwargs), _data


class MspOsdVideoConfig:
    CODE = 180
    MSPV = 1
    """"""
    pass

class MspSetOsdVideoConfig:
    CODE = 181
    MSPV = 1
    """"""
    pass

class MspDisplayport:
    CODE = 182
    MSPV = 1
    """"""
    pass

class MspSetTxInfo:
    CODE = 186
    MSPV = 1
    """Allows a transmitter LUA script (or similar) to send runtime information (currently only RSSI) to the firmware."""
    @dataclass
    class Request:
        rssi: int = 0

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.rssi
            out += _pack_scalar('uint8_t', 'rssi', _v)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Request', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _val, _data = _unpack_scalar('uint8_t', 'rssi', _data)
            _kwargs['rssi'] = _val
            return cls(**_kwargs), _data


class MspTxInfo:
    CODE = 187
    MSPV = 1
    """Provides information potentially useful for transmitter LUA scripts."""
    @dataclass
    class Reply:
        rssiSource: int = 0
        rtcDateTimeIsSet: int = 0

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.rssiSource
            out += _pack_scalar('uint8_t', 'rssiSource', _v)
            _v = self.rtcDateTimeIsSet
            out += _pack_scalar('uint8_t', 'rtcDateTimeIsSet', _v)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Reply', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _val, _data = _unpack_scalar('uint8_t', 'rssiSource', _data)
            _kwargs['rssiSource'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'rtcDateTimeIsSet', _data)
            _kwargs['rtcDateTimeIsSet'] = _val
            return cls(**_kwargs), _data


class MspSetRawRc:
    CODE = 200
    MSPV = 1
    """Provides raw RC channel data to the flight controller, typically used when the receiver is connected via MSP (e.g., MSP RX feature)."""
    @dataclass
    class Request:
        rcChannels: List[int] = field(default_factory=list)

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.rcChannels
            if not isinstance(_v, list):
                raise TypeError('rcChannels must be list')
            for i, _e in enumerate(_v):
                out += _pack_scalar('uint16_t', 'rcChannels[{}]'.format(i), _e)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Request', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _alen = hints.get('rcChannels_len')
            if _alen is None:
                raise ValueError('missing hint: rcChannels_len for variable length array')
            elem_size = 2
            total = int(_alen) * elem_size
            if len(_data) < total:
                raise ValueError('not enough data to unpack rcChannels')
            _tmp_v = []
            _tmp = _data[:total]
            for _i in range(int(_alen)):
                _val, _tmp = _unpack_scalar('uint16_t', 'rcChannels[{}]'.format(_i), _tmp)
                _tmp_v.append(_val)
            _kwargs['rcChannels'] = _tmp_v
            _data = _data[total:]
            return cls(**_kwargs), _data


class MspSetRawGps:
    CODE = 201
    MSPV = 1
    """Provides raw GPS data to the flight controller, typically for simulation or external GPS injection."""
    @dataclass
    class Request:
        fixType: int = 0
        numSat: int = 0
        latitude: int = 0
        longitude: int = 0
        altitude: int = 0
        speed: int = 0

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.fixType
            out += _pack_scalar('uint8_t', 'fixType', _v)
            _v = self.numSat
            out += _pack_scalar('uint8_t', 'numSat', _v)
            _v = self.latitude
            out += _pack_scalar('int32_t', 'latitude', _v)
            _v = self.longitude
            out += _pack_scalar('int32_t', 'longitude', _v)
            _v = self.altitude
            out += _pack_scalar('uint16_t', 'altitude', _v)
            _v = self.speed
            out += _pack_scalar('uint16_t', 'speed', _v)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Request', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _val, _data = _unpack_scalar('uint8_t', 'fixType', _data)
            _kwargs['fixType'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'numSat', _data)
            _kwargs['numSat'] = _val
            _val, _data = _unpack_scalar('int32_t', 'latitude', _data)
            _kwargs['latitude'] = _val
            _val, _data = _unpack_scalar('int32_t', 'longitude', _data)
            _kwargs['longitude'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'altitude', _data)
            _kwargs['altitude'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'speed', _data)
            _kwargs['speed'] = _val
            return cls(**_kwargs), _data


class MspSetBox:
    CODE = 203
    MSPV = 1
    """Sets the state of flight modes (boxes). (Likely unused/obsolete in INAV)."""
    pass

class MspSetRcTuning:
    CODE = 204
    MSPV = 1
    """Sets RC tuning parameters (rates, expos, TPA) for the current control rate profile."""
    @dataclass
    class Request:
        legacyRcRate: int = 0
        rcExpo: int = 0
        rollRate: int = 0
        pitchRate: int = 0
        yawRate: int = 0
        dynamicThrottlePID: int = 0
        throttleMid: int = 0
        throttleExpo: int = 0
        tpaBreakpoint: int = 0
        rcYawExpo: Optional[int] = None

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.legacyRcRate
            out += _pack_scalar('uint8_t', 'legacyRcRate', _v)
            _v = self.rcExpo
            out += _pack_scalar('uint8_t', 'rcExpo', _v)
            _v = self.rollRate
            out += _pack_scalar('uint8_t', 'rollRate', _v)
            _v = self.pitchRate
            out += _pack_scalar('uint8_t', 'pitchRate', _v)
            _v = self.yawRate
            out += _pack_scalar('uint8_t', 'yawRate', _v)
            _v = self.dynamicThrottlePID
            out += _pack_scalar('uint8_t', 'dynamicThrottlePID', _v)
            _v = self.throttleMid
            out += _pack_scalar('uint8_t', 'throttleMid', _v)
            _v = self.throttleExpo
            out += _pack_scalar('uint8_t', 'throttleExpo', _v)
            _v = self.tpaBreakpoint
            out += _pack_scalar('uint16_t', 'tpaBreakpoint', _v)
            if self.rcYawExpo is None:
                pass
            else:
                _v = self.rcYawExpo
                out += _pack_scalar('uint8_t', 'rcYawExpo', _v)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Request', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _val, _data = _unpack_scalar('uint8_t', 'legacyRcRate', _data)
            _kwargs['legacyRcRate'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'rcExpo', _data)
            _kwargs['rcExpo'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'rollRate', _data)
            _kwargs['rollRate'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'pitchRate', _data)
            _kwargs['pitchRate'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'yawRate', _data)
            _kwargs['yawRate'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'dynamicThrottlePID', _data)
            _kwargs['dynamicThrottlePID'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'throttleMid', _data)
            _kwargs['throttleMid'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'throttleExpo', _data)
            _kwargs['throttleExpo'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'tpaBreakpoint', _data)
            _kwargs['tpaBreakpoint'] = _val
            if len(_data) == 0:
                _kwargs['rcYawExpo'] = None
            else:
                _val, _data = _unpack_scalar('uint8_t', 'rcYawExpo', _data)
                _kwargs['rcYawExpo'] = _val
            return cls(**_kwargs), _data


class MspAccCalibration:
    CODE = 205
    MSPV = 1
    """Starts the accelerometer calibration procedure."""
    pass

class MspMagCalibration:
    CODE = 206
    MSPV = 1
    """Starts the magnetometer calibration procedure."""
    pass

class MspSetMisc:
    CODE = 207
    MSPV = 1
    """Sets miscellaneous configuration settings (legacy formats/scaling)."""
    @dataclass
    class Request:
        midRc: int = 0
        legacyMinThrottle: int = 0
        legacyMaxThrottle: int = 0
        minCommand: int = 0
        failsafeThrottle: int = 0
        gpsType: int = 0
        legacyGpsBaud: int = 0
        gpsSbasMode: int = 0
        legacyMwCurrentOut: int = 0
        rssiChannel: int = 0
        reserved1: int = 0
        magDeclination: int = 0
        vbatScale: int = 0
        vbatMinCell: int = 0
        vbatMaxCell: int = 0
        vbatWarningCell: int = 0

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.midRc
            out += _pack_scalar('uint16_t', 'midRc', _v)
            _v = self.legacyMinThrottle
            out += _pack_scalar('uint16_t', 'legacyMinThrottle', _v)
            _v = self.legacyMaxThrottle
            out += _pack_scalar('uint16_t', 'legacyMaxThrottle', _v)
            _v = self.minCommand
            out += _pack_scalar('uint16_t', 'minCommand', _v)
            _v = self.failsafeThrottle
            out += _pack_scalar('uint16_t', 'failsafeThrottle', _v)
            _v = self.gpsType
            out += _pack_scalar('uint8_t', 'gpsType', _v)
            _v = self.legacyGpsBaud
            out += _pack_scalar('uint8_t', 'legacyGpsBaud', _v)
            _v = self.gpsSbasMode
            out += _pack_scalar('uint8_t', 'gpsSbasMode', _v)
            _v = self.legacyMwCurrentOut
            out += _pack_scalar('uint8_t', 'legacyMwCurrentOut', _v)
            _v = self.rssiChannel
            out += _pack_scalar('uint8_t', 'rssiChannel', _v)
            _v = self.reserved1
            out += _pack_scalar('uint8_t', 'reserved1', _v)
            _v = self.magDeclination
            out += _pack_scalar('uint16_t', 'magDeclination', _v)
            _v = self.vbatScale
            out += _pack_scalar('uint8_t', 'vbatScale', _v)
            _v = self.vbatMinCell
            out += _pack_scalar('uint8_t', 'vbatMinCell', _v)
            _v = self.vbatMaxCell
            out += _pack_scalar('uint8_t', 'vbatMaxCell', _v)
            _v = self.vbatWarningCell
            out += _pack_scalar('uint8_t', 'vbatWarningCell', _v)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Request', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _val, _data = _unpack_scalar('uint16_t', 'midRc', _data)
            _kwargs['midRc'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'legacyMinThrottle', _data)
            _kwargs['legacyMinThrottle'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'legacyMaxThrottle', _data)
            _kwargs['legacyMaxThrottle'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'minCommand', _data)
            _kwargs['minCommand'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'failsafeThrottle', _data)
            _kwargs['failsafeThrottle'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'gpsType', _data)
            _kwargs['gpsType'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'legacyGpsBaud', _data)
            _kwargs['legacyGpsBaud'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'gpsSbasMode', _data)
            _kwargs['gpsSbasMode'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'legacyMwCurrentOut', _data)
            _kwargs['legacyMwCurrentOut'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'rssiChannel', _data)
            _kwargs['rssiChannel'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'reserved1', _data)
            _kwargs['reserved1'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'magDeclination', _data)
            _kwargs['magDeclination'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'vbatScale', _data)
            _kwargs['vbatScale'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'vbatMinCell', _data)
            _kwargs['vbatMinCell'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'vbatMaxCell', _data)
            _kwargs['vbatMaxCell'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'vbatWarningCell', _data)
            _kwargs['vbatWarningCell'] = _val
            return cls(**_kwargs), _data


class MspResetConf:
    CODE = 208
    MSPV = 1
    """Resets all configuration settings to their default values and saves to EEPROM."""
    pass

class MspSetWp:
    CODE = 209
    MSPV = 1
    """Sets a single waypoint in the mission plan."""
    @dataclass
    class Request:
        waypointIndex: int = 0
        action: int = 0
        latitude: int = 0
        longitude: int = 0
        altitude: int = 0
        param1: int = 0
        param2: int = 0
        param3: int = 0
        flag: int = 0

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.waypointIndex
            out += _pack_scalar('uint8_t', 'waypointIndex', _v)
            _v = self.action
            out += _pack_scalar('uint8_t', 'action', _v)
            _v = self.latitude
            out += _pack_scalar('int32_t', 'latitude', _v)
            _v = self.longitude
            out += _pack_scalar('int32_t', 'longitude', _v)
            _v = self.altitude
            out += _pack_scalar('int32_t', 'altitude', _v)
            _v = self.param1
            out += _pack_scalar('uint16_t', 'param1', _v)
            _v = self.param2
            out += _pack_scalar('uint16_t', 'param2', _v)
            _v = self.param3
            out += _pack_scalar('uint16_t', 'param3', _v)
            _v = self.flag
            out += _pack_scalar('uint8_t', 'flag', _v)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Request', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _val, _data = _unpack_scalar('uint8_t', 'waypointIndex', _data)
            _kwargs['waypointIndex'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'action', _data)
            _kwargs['action'] = _val
            _val, _data = _unpack_scalar('int32_t', 'latitude', _data)
            _kwargs['latitude'] = _val
            _val, _data = _unpack_scalar('int32_t', 'longitude', _data)
            _kwargs['longitude'] = _val
            _val, _data = _unpack_scalar('int32_t', 'altitude', _data)
            _kwargs['altitude'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'param1', _data)
            _kwargs['param1'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'param2', _data)
            _kwargs['param2'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'param3', _data)
            _kwargs['param3'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'flag', _data)
            _kwargs['flag'] = _val
            return cls(**_kwargs), _data


class MspSelectSetting:
    CODE = 210
    MSPV = 1
    """Selects the active configuration profile and saves it."""
    @dataclass
    class Request:
        profileIndex: int = 0

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.profileIndex
            out += _pack_scalar('uint8_t', 'profileIndex', _v)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Request', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _val, _data = _unpack_scalar('uint8_t', 'profileIndex', _data)
            _kwargs['profileIndex'] = _val
            return cls(**_kwargs), _data


class MspSetHead:
    CODE = 211
    MSPV = 1
    """Sets the target heading for the heading hold controller (e.g., during MAG mode)."""
    @dataclass
    class Request:
        heading: int = 0

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.heading
            out += _pack_scalar('uint16_t', 'heading', _v)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Request', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _val, _data = _unpack_scalar('uint16_t', 'heading', _data)
            _kwargs['heading'] = _val
            return cls(**_kwargs), _data


class MspSetServoConfiguration:
    CODE = 212
    MSPV = 1
    """Sets the configuration for a single servo (legacy format)."""
    @dataclass
    class Request:
        servoIndex: int = 0
        min: int = 0
        max: int = 0
        middle: int = 0
        rate: int = 0
        reserved1: int = 0
        reserved2: int = 0
        legacyForwardChan: int = 0
        legacyReversedSources: int = 0

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.servoIndex
            out += _pack_scalar('uint8_t', 'servoIndex', _v)
            _v = self.min
            out += _pack_scalar('uint16_t', 'min', _v)
            _v = self.max
            out += _pack_scalar('uint16_t', 'max', _v)
            _v = self.middle
            out += _pack_scalar('uint16_t', 'middle', _v)
            _v = self.rate
            out += _pack_scalar('uint8_t', 'rate', _v)
            _v = self.reserved1
            out += _pack_scalar('uint8_t', 'reserved1', _v)
            _v = self.reserved2
            out += _pack_scalar('uint8_t', 'reserved2', _v)
            _v = self.legacyForwardChan
            out += _pack_scalar('uint8_t', 'legacyForwardChan', _v)
            _v = self.legacyReversedSources
            out += _pack_scalar('uint32_t', 'legacyReversedSources', _v)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Request', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _val, _data = _unpack_scalar('uint8_t', 'servoIndex', _data)
            _kwargs['servoIndex'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'min', _data)
            _kwargs['min'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'max', _data)
            _kwargs['max'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'middle', _data)
            _kwargs['middle'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'rate', _data)
            _kwargs['rate'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'reserved1', _data)
            _kwargs['reserved1'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'reserved2', _data)
            _kwargs['reserved2'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'legacyForwardChan', _data)
            _kwargs['legacyForwardChan'] = _val
            _val, _data = _unpack_scalar('uint32_t', 'legacyReversedSources', _data)
            _kwargs['legacyReversedSources'] = _val
            return cls(**_kwargs), _data


class MspSetMotor:
    CODE = 214
    MSPV = 1
    """Sets the disarmed motor values, typically used for motor testing or propeller balancing functions in a configurator."""
    @dataclass
    class Request:
        motorValues: List[int] = field(default_factory=list)

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.motorValues
            if not isinstance(_v, list):
                raise TypeError('motorValues must be list')
            if len(_v) != 8:
                raise ValueError('motorValues must have exactly 8 elements')
            for i, _e in enumerate(_v):
                out += _pack_scalar('uint16_t', 'motorValues[{}]'.format(i), _e)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Request', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            if len(_data) < 16:
                raise ValueError('not enough data to unpack motorValues')
            _tmp_v = []
            _tmp = _data[:16]
            for _i in range(8):
                _val, _tmp = _unpack_scalar('uint16_t', 'motorValues[{}]'.format(_i), _tmp)
                _tmp_v.append(_val)
            _kwargs['motorValues'] = _tmp_v
            _data = _data[16:]
            return cls(**_kwargs), _data


class MspSetNavConfig:
    CODE = 215
    MSPV = 1
    """"""
    pass

class MspSet3d:
    CODE = 217
    MSPV = 1
    """Sets parameters related to 3D/reversible motor operation."""
    @dataclass
    class Request:
        deadbandLow: int = 0
        deadbandHigh: int = 0
        neutral: int = 0

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.deadbandLow
            out += _pack_scalar('uint16_t', 'deadbandLow', _v)
            _v = self.deadbandHigh
            out += _pack_scalar('uint16_t', 'deadbandHigh', _v)
            _v = self.neutral
            out += _pack_scalar('uint16_t', 'neutral', _v)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Request', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _val, _data = _unpack_scalar('uint16_t', 'deadbandLow', _data)
            _kwargs['deadbandLow'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'deadbandHigh', _data)
            _kwargs['deadbandHigh'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'neutral', _data)
            _kwargs['neutral'] = _val
            return cls(**_kwargs), _data


class MspSetRcDeadband:
    CODE = 218
    MSPV = 1
    """Sets RC input deadband values."""
    @dataclass
    class Request:
        deadband: int = 0
        yawDeadband: int = 0
        altHoldDeadband: int = 0
        throttleDeadband: int = 0

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.deadband
            out += _pack_scalar('uint8_t', 'deadband', _v)
            _v = self.yawDeadband
            out += _pack_scalar('uint8_t', 'yawDeadband', _v)
            _v = self.altHoldDeadband
            out += _pack_scalar('uint8_t', 'altHoldDeadband', _v)
            _v = self.throttleDeadband
            out += _pack_scalar('uint16_t', 'throttleDeadband', _v)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Request', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _val, _data = _unpack_scalar('uint8_t', 'deadband', _data)
            _kwargs['deadband'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'yawDeadband', _data)
            _kwargs['yawDeadband'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'altHoldDeadband', _data)
            _kwargs['altHoldDeadband'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'throttleDeadband', _data)
            _kwargs['throttleDeadband'] = _val
            return cls(**_kwargs), _data


class MspSetResetCurrPid:
    CODE = 219
    MSPV = 1
    """Resets the PIDs of the *current* profile to their default values. Does not save."""
    pass

class MspSetSensorAlignment:
    CODE = 220
    MSPV = 1
    """Sets sensor alignment (legacy format)."""
    @dataclass
    class Request:
        gyroAlign: int = 0
        accAlign: int = 0
        magAlign: int = 0
        opflowAlign: int = 0

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.gyroAlign
            out += _pack_scalar('uint8_t', 'gyroAlign', _v)
            _v = self.accAlign
            out += _pack_scalar('uint8_t', 'accAlign', _v)
            _v = self.magAlign
            out += _pack_scalar('uint8_t', 'magAlign', _v)
            _v = self.opflowAlign
            out += _pack_scalar('uint8_t', 'opflowAlign', _v)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Request', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _val, _data = _unpack_scalar('uint8_t', 'gyroAlign', _data)
            _kwargs['gyroAlign'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'accAlign', _data)
            _kwargs['accAlign'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'magAlign', _data)
            _kwargs['magAlign'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'opflowAlign', _data)
            _kwargs['opflowAlign'] = _val
            return cls(**_kwargs), _data


class MspSetLedStripModecolor:
    CODE = 221
    MSPV = 1
    """Sets the color index for a specific LED mode/function combination."""
    @dataclass
    class Request:
        modeIndex: int = 0
        directionOrSpecialIndex: int = 0
        colorIndex: int = 0

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.modeIndex
            out += _pack_scalar('uint8_t', 'modeIndex', _v)
            _v = self.directionOrSpecialIndex
            out += _pack_scalar('uint8_t', 'directionOrSpecialIndex', _v)
            _v = self.colorIndex
            out += _pack_scalar('uint8_t', 'colorIndex', _v)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Request', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _val, _data = _unpack_scalar('uint8_t', 'modeIndex', _data)
            _kwargs['modeIndex'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'directionOrSpecialIndex', _data)
            _kwargs['directionOrSpecialIndex'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'colorIndex', _data)
            _kwargs['colorIndex'] = _val
            return cls(**_kwargs), _data


class MspSetAccTrim:
    CODE = 239
    MSPV = 1
    """Sets the accelerometer trim values (leveling calibration)."""
    pass

class MspAccTrim:
    CODE = 240
    MSPV = 1
    """Gets the accelerometer trim values."""
    pass

class MspServoMixRules:
    CODE = 241
    MSPV = 1
    """Retrieves the custom servo mixer rules (legacy format)."""
    @dataclass
    class Reply:
        targetChannel: int = 0
        inputSource: int = 0
        rate: int = 0
        speed: int = 0
        reserved1: int = 0
        legacyMax: int = 0
        legacyBox: int = 0

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.targetChannel
            out += _pack_scalar('uint8_t', 'targetChannel', _v)
            _v = self.inputSource
            out += _pack_scalar('uint8_t', 'inputSource', _v)
            _v = self.rate
            out += _pack_scalar('int16_t', 'rate', _v)
            _v = self.speed
            out += _pack_scalar('uint8_t', 'speed', _v)
            _v = self.reserved1
            out += _pack_scalar('uint8_t', 'reserved1', _v)
            _v = self.legacyMax
            out += _pack_scalar('uint8_t', 'legacyMax', _v)
            _v = self.legacyBox
            out += _pack_scalar('uint8_t', 'legacyBox', _v)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Reply', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _val, _data = _unpack_scalar('uint8_t', 'targetChannel', _data)
            _kwargs['targetChannel'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'inputSource', _data)
            _kwargs['inputSource'] = _val
            _val, _data = _unpack_scalar('int16_t', 'rate', _data)
            _kwargs['rate'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'speed', _data)
            _kwargs['speed'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'reserved1', _data)
            _kwargs['reserved1'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'legacyMax', _data)
            _kwargs['legacyMax'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'legacyBox', _data)
            _kwargs['legacyBox'] = _val
            return cls(**_kwargs), _data


class MspSetServoMixRule:
    CODE = 242
    MSPV = 1
    """Sets a single custom servo mixer rule (legacy format)."""
    @dataclass
    class Request:
        ruleIndex: int = 0
        targetChannel: int = 0
        inputSource: int = 0
        rate: int = 0
        speed: int = 0
        legacyMinMax: int = 0
        legacyBox: int = 0

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.ruleIndex
            out += _pack_scalar('uint8_t', 'ruleIndex', _v)
            _v = self.targetChannel
            out += _pack_scalar('uint8_t', 'targetChannel', _v)
            _v = self.inputSource
            out += _pack_scalar('uint8_t', 'inputSource', _v)
            _v = self.rate
            out += _pack_scalar('int16_t', 'rate', _v)
            _v = self.speed
            out += _pack_scalar('uint8_t', 'speed', _v)
            _v = self.legacyMinMax
            out += _pack_scalar('uint16_t', 'legacyMinMax', _v)
            _v = self.legacyBox
            out += _pack_scalar('uint8_t', 'legacyBox', _v)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Request', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _val, _data = _unpack_scalar('uint8_t', 'ruleIndex', _data)
            _kwargs['ruleIndex'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'targetChannel', _data)
            _kwargs['targetChannel'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'inputSource', _data)
            _kwargs['inputSource'] = _val
            _val, _data = _unpack_scalar('int16_t', 'rate', _data)
            _kwargs['rate'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'speed', _data)
            _kwargs['speed'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'legacyMinMax', _data)
            _kwargs['legacyMinMax'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'legacyBox', _data)
            _kwargs['legacyBox'] = _val
            return cls(**_kwargs), _data


class MspSetPassthrough:
    CODE = 245
    MSPV = 1
    """Enables serial passthrough mode to peripherals like ESCs (BLHeli 4-way) or other serial devices."""
    @dataclass
    class Reply:
        status: int = 0

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.status
            out += _pack_scalar('uint8_t', 'status', _v)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Reply', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _val, _data = _unpack_scalar('uint8_t', 'status', _data)
            _kwargs['status'] = _val
            return cls(**_kwargs), _data


class MspRtc:
    CODE = 246
    MSPV = 1
    """Retrieves the current Real-Time Clock time."""
    @dataclass
    class Reply:
        seconds: int = 0
        millis: int = 0

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.seconds
            out += _pack_scalar('int32_t', 'seconds', _v)
            _v = self.millis
            out += _pack_scalar('uint16_t', 'millis', _v)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Reply', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _val, _data = _unpack_scalar('int32_t', 'seconds', _data)
            _kwargs['seconds'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'millis', _data)
            _kwargs['millis'] = _val
            return cls(**_kwargs), _data


class MspSetRtc:
    CODE = 247
    MSPV = 1
    """Sets the Real-Time Clock time."""
    @dataclass
    class Request:
        seconds: int = 0
        millis: int = 0

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.seconds
            out += _pack_scalar('int32_t', 'seconds', _v)
            _v = self.millis
            out += _pack_scalar('uint16_t', 'millis', _v)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Request', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _val, _data = _unpack_scalar('int32_t', 'seconds', _data)
            _kwargs['seconds'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'millis', _data)
            _kwargs['millis'] = _val
            return cls(**_kwargs), _data


class MspEepromWrite:
    CODE = 250
    MSPV = 1
    """Saves the current configuration from RAM to non-volatile memory (EEPROM/Flash)."""
    pass

class MspReserve1:
    CODE = 251
    MSPV = 1
    """"""
    pass

class MspReserve2:
    CODE = 252
    MSPV = 1
    """"""
    pass

class MspDebugmsg:
    CODE = 253
    MSPV = 1
    """Retrieves debug ("serial printf") messages from the firmware."""
    @dataclass
    class Reply:
        Message Text: bytes = b''

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.Message Text
            if not isinstance(_v, (bytes, bytearray)):
                raise TypeError('Message Text must be bytes for variable length char array')
            out += _v
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Reply', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _len = hints.get('Message Text_len', len(_data))
            if len(_data) < _len:
                raise ValueError('not enough data to unpack Message Text variable bytes')
            _kwargs['Message Text'] = _data[:_len]
            _data = _data[_len:]
            return cls(**_kwargs), _data


class MspDebug:
    CODE = 254
    MSPV = 1
    """Retrieves values from the firmware's `debug[]` array (legacy 16-bit version)."""
    @dataclass
    class Reply:
        debugValues: List[int] = field(default_factory=list)

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.debugValues
            if not isinstance(_v, list):
                raise TypeError('debugValues must be list')
            if len(_v) != 4:
                raise ValueError('debugValues must have exactly 4 elements')
            for i, _e in enumerate(_v):
                out += _pack_scalar('uint16_t', 'debugValues[{}]'.format(i), _e)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Reply', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            if len(_data) < 8:
                raise ValueError('not enough data to unpack debugValues')
            _tmp_v = []
            _tmp = _data[:8]
            for _i in range(4):
                _val, _tmp = _unpack_scalar('uint16_t', 'debugValues[{}]'.format(_i), _tmp)
                _tmp_v.append(_val)
            _kwargs['debugValues'] = _tmp_v
            _data = _data[8:]
            return cls(**_kwargs), _data


class MspV2Frame:
    CODE = 255
    MSPV = 1
    """This ID is used as a *payload indicator* within an MSPv1 message structure (`$M>`) to signify that the following payload conforms to the MSPv2 format. It's not a command itself."""
    pass

class Msp2CommonTz:
    CODE = 4097
    MSPV = 2
    """Gets the time zone offset configuration."""
    @dataclass
    class Reply:
        tzOffsetMinutes: int = 0
        tzAutoDst: int = 0

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.tzOffsetMinutes
            out += _pack_scalar('int16_t', 'tzOffsetMinutes', _v)
            _v = self.tzAutoDst
            out += _pack_scalar('uint8_t', 'tzAutoDst', _v)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Reply', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _val, _data = _unpack_scalar('int16_t', 'tzOffsetMinutes', _data)
            _kwargs['tzOffsetMinutes'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'tzAutoDst', _data)
            _kwargs['tzAutoDst'] = _val
            return cls(**_kwargs), _data


class Msp2CommonSetTz:
    CODE = 4098
    MSPV = 2
    """Sets the time zone offset configuration."""
    pass

class Msp2CommonSetting:
    CODE = 4099
    MSPV = 2
    """Gets the value of a specific configuration setting, identified by name or index."""
    @dataclass
    class Request:
        settingIdentifier: int = 0

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.settingIdentifier
            out += _pack_scalar('Varies', 'settingIdentifier', _v)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Request', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _val, _data = _unpack_scalar('Varies', 'settingIdentifier', _data)
            _kwargs['settingIdentifier'] = _val
            return cls(**_kwargs), _data

    @dataclass
    class Reply:
        settingValue: List[int] = field(default_factory=list)

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.settingValue
            if not isinstance(_v, list):
                raise TypeError('settingValue must be list')
            for i, _e in enumerate(_v):
                out += _pack_scalar('uint8_t', 'settingValue[{}]'.format(i), _e)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Reply', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _alen = hints.get('settingValue_len')
            if _alen is None:
                raise ValueError('missing hint: settingValue_len for variable length array')
            elem_size = 1
            total = int(_alen) * elem_size
            if len(_data) < total:
                raise ValueError('not enough data to unpack settingValue')
            _tmp_v = []
            _tmp = _data[:total]
            for _i in range(int(_alen)):
                _val, _tmp = _unpack_scalar('uint8_t', 'settingValue[{}]'.format(_i), _tmp)
                _tmp_v.append(_val)
            _kwargs['settingValue'] = _tmp_v
            _data = _data[total:]
            return cls(**_kwargs), _data


class Msp2CommonSetSetting:
    CODE = 4100
    MSPV = 2
    """Sets the value of a specific configuration setting, identified by name or index."""
    @dataclass
    class Request:
        settingIdentifier: int = 0
        settingValue: List[int] = field(default_factory=list)

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.settingIdentifier
            out += _pack_scalar('Varies', 'settingIdentifier', _v)
            _v = self.settingValue
            if not isinstance(_v, list):
                raise TypeError('settingValue must be list')
            for i, _e in enumerate(_v):
                out += _pack_scalar('uint8_t', 'settingValue[{}]'.format(i), _e)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Request', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _val, _data = _unpack_scalar('Varies', 'settingIdentifier', _data)
            _kwargs['settingIdentifier'] = _val
            _alen = hints.get('settingValue_len')
            if _alen is None:
                raise ValueError('missing hint: settingValue_len for variable length array')
            elem_size = 1
            total = int(_alen) * elem_size
            if len(_data) < total:
                raise ValueError('not enough data to unpack settingValue')
            _tmp_v = []
            _tmp = _data[:total]
            for _i in range(int(_alen)):
                _val, _tmp = _unpack_scalar('uint8_t', 'settingValue[{}]'.format(_i), _tmp)
                _tmp_v.append(_val)
            _kwargs['settingValue'] = _tmp_v
            _data = _data[total:]
            return cls(**_kwargs), _data


class Msp2CommonMotorMixer:
    CODE = 4101
    MSPV = 2
    """Retrieves the current motor mixer configuration (throttle, roll, pitch, yaw weights) for each motor."""
    @dataclass
    class Reply:
        motorMix: List[int] = field(default_factory=list)

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.motorMix
            if not isinstance(_v, list):
                raise TypeError('motorMix must be list')
            if len(_v) != 4:
                raise ValueError('motorMix must have exactly 4 elements')
            for i, _e in enumerate(_v):
                out += _pack_scalar('uint16_t', 'motorMix[{}]'.format(i), _e)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Reply', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            if len(_data) < 8:
                raise ValueError('not enough data to unpack motorMix')
            _tmp_v = []
            _tmp = _data[:8]
            for _i in range(4):
                _val, _tmp = _unpack_scalar('uint16_t', 'motorMix[{}]'.format(_i), _tmp)
                _tmp_v.append(_val)
            _kwargs['motorMix'] = _tmp_v
            _data = _data[8:]
            return cls(**_kwargs), _data


class Msp2CommonSetMotorMixer:
    CODE = 4102
    MSPV = 2
    """Sets the motor mixer weights for a single motor in the primary mixer profile."""
    @dataclass
    class Request:
        motorIndex: int = 0
        throttleWeight: int = 0
        rollWeight: int = 0
        pitchWeight: int = 0
        yawWeight: int = 0

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.motorIndex
            out += _pack_scalar('uint8_t', 'motorIndex', _v)
            _v = self.throttleWeight
            out += _pack_scalar('uint16_t', 'throttleWeight', _v)
            _v = self.rollWeight
            out += _pack_scalar('uint16_t', 'rollWeight', _v)
            _v = self.pitchWeight
            out += _pack_scalar('uint16_t', 'pitchWeight', _v)
            _v = self.yawWeight
            out += _pack_scalar('uint16_t', 'yawWeight', _v)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Request', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _val, _data = _unpack_scalar('uint8_t', 'motorIndex', _data)
            _kwargs['motorIndex'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'throttleWeight', _data)
            _kwargs['throttleWeight'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'rollWeight', _data)
            _kwargs['rollWeight'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'pitchWeight', _data)
            _kwargs['pitchWeight'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'yawWeight', _data)
            _kwargs['yawWeight'] = _val
            return cls(**_kwargs), _data


class Msp2CommonSettingInfo:
    CODE = 4103
    MSPV = 2
    """Gets detailed information about a specific configuration setting (name, type, range, flags, current value, etc.)."""
    @dataclass
    class Reply:
        settingName: bytes = b''
        pgn: int = 0
        type: int = 0
        section: int = 0
        mode: int = 0
        minValue: int = 0
        maxValue: int = 0
        settingIndex: int = 0
        profileIndex: int = 0
        profileCount: int = 0
        lookupNames: bytes = b''
        settingValue: List[int] = field(default_factory=list)

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.settingName
            if not isinstance(_v, (bytes, bytearray)):
                raise TypeError('settingName must be bytes for variable length char array')
            out += _v
            _v = self.pgn
            out += _pack_scalar('uint16_t', 'pgn', _v)
            _v = self.type
            out += _pack_scalar('uint8_t', 'type', _v)
            _v = self.section
            out += _pack_scalar('uint8_t', 'section', _v)
            _v = self.mode
            out += _pack_scalar('uint8_t', 'mode', _v)
            _v = self.minValue
            out += _pack_scalar('int32_t', 'minValue', _v)
            _v = self.maxValue
            out += _pack_scalar('uint32_t', 'maxValue', _v)
            _v = self.settingIndex
            out += _pack_scalar('uint16_t', 'settingIndex', _v)
            _v = self.profileIndex
            out += _pack_scalar('uint8_t', 'profileIndex', _v)
            _v = self.profileCount
            out += _pack_scalar('uint8_t', 'profileCount', _v)
            _v = self.lookupNames
            if not isinstance(_v, (bytes, bytearray)):
                raise TypeError('lookupNames must be bytes for variable length char array')
            out += _v
            _v = self.settingValue
            if not isinstance(_v, list):
                raise TypeError('settingValue must be list')
            for i, _e in enumerate(_v):
                out += _pack_scalar('uint8_t', 'settingValue[{}]'.format(i), _e)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Reply', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _len = hints.get('settingName_len', len(_data))
            if len(_data) < _len:
                raise ValueError('not enough data to unpack settingName variable bytes')
            _kwargs['settingName'] = _data[:_len]
            _data = _data[_len:]
            _val, _data = _unpack_scalar('uint16_t', 'pgn', _data)
            _kwargs['pgn'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'type', _data)
            _kwargs['type'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'section', _data)
            _kwargs['section'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'mode', _data)
            _kwargs['mode'] = _val
            _val, _data = _unpack_scalar('int32_t', 'minValue', _data)
            _kwargs['minValue'] = _val
            _val, _data = _unpack_scalar('uint32_t', 'maxValue', _data)
            _kwargs['maxValue'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'settingIndex', _data)
            _kwargs['settingIndex'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'profileIndex', _data)
            _kwargs['profileIndex'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'profileCount', _data)
            _kwargs['profileCount'] = _val
            _len = hints.get('lookupNames_len', len(_data))
            if len(_data) < _len:
                raise ValueError('not enough data to unpack lookupNames variable bytes')
            _kwargs['lookupNames'] = _data[:_len]
            _data = _data[_len:]
            _alen = hints.get('settingValue_len')
            if _alen is None:
                raise ValueError('missing hint: settingValue_len for variable length array')
            elem_size = 1
            total = int(_alen) * elem_size
            if len(_data) < total:
                raise ValueError('not enough data to unpack settingValue')
            _tmp_v = []
            _tmp = _data[:total]
            for _i in range(int(_alen)):
                _val, _tmp = _unpack_scalar('uint8_t', 'settingValue[{}]'.format(_i), _tmp)
                _tmp_v.append(_val)
            _kwargs['settingValue'] = _tmp_v
            _data = _data[total:]
            return cls(**_kwargs), _data


class Msp2CommonPgList:
    CODE = 4104
    MSPV = 2
    """Gets a list of Parameter Group Numbers (PGNs) used by settings, along with the start and end setting indexes for each group. Can request info for a single PGN."""
    @dataclass
    class Request:
        pgn: Optional[int] = None

        def pack(self) -> bytes:
            out = bytearray()
            if self.pgn is None:
                pass
            else:
                _v = self.pgn
                out += _pack_scalar('uint16_t', 'pgn', _v)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Request', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            if len(_data) == 0:
                _kwargs['pgn'] = None
            else:
                _val, _data = _unpack_scalar('uint16_t', 'pgn', _data)
                _kwargs['pgn'] = _val
            return cls(**_kwargs), _data

    @dataclass
    class Reply:
        pgn: int = 0
        startIndex: int = 0
        endIndex: int = 0

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.pgn
            out += _pack_scalar('uint16_t', 'pgn', _v)
            _v = self.startIndex
            out += _pack_scalar('uint16_t', 'startIndex', _v)
            _v = self.endIndex
            out += _pack_scalar('uint16_t', 'endIndex', _v)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Reply', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _val, _data = _unpack_scalar('uint16_t', 'pgn', _data)
            _kwargs['pgn'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'startIndex', _data)
            _kwargs['startIndex'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'endIndex', _data)
            _kwargs['endIndex'] = _val
            return cls(**_kwargs), _data


class Msp2CommonSerialConfig:
    CODE = 4105
    MSPV = 2
    """Retrieves the configuration for all available serial ports."""
    @dataclass
    class Reply:
        identifier: int = 0
        functionMask: int = 0
        mspBaudIndex: int = 0
        gpsBaudIndex: int = 0
        telemetryBaudIndex: int = 0
        peripheralBaudIndex: int = 0

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.identifier
            out += _pack_scalar('uint8_t', 'identifier', _v)
            _v = self.functionMask
            out += _pack_scalar('uint32_t', 'functionMask', _v)
            _v = self.mspBaudIndex
            out += _pack_scalar('uint8_t', 'mspBaudIndex', _v)
            _v = self.gpsBaudIndex
            out += _pack_scalar('uint8_t', 'gpsBaudIndex', _v)
            _v = self.telemetryBaudIndex
            out += _pack_scalar('uint8_t', 'telemetryBaudIndex', _v)
            _v = self.peripheralBaudIndex
            out += _pack_scalar('uint8_t', 'peripheralBaudIndex', _v)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Reply', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _val, _data = _unpack_scalar('uint8_t', 'identifier', _data)
            _kwargs['identifier'] = _val
            _val, _data = _unpack_scalar('uint32_t', 'functionMask', _data)
            _kwargs['functionMask'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'mspBaudIndex', _data)
            _kwargs['mspBaudIndex'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'gpsBaudIndex', _data)
            _kwargs['gpsBaudIndex'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'telemetryBaudIndex', _data)
            _kwargs['telemetryBaudIndex'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'peripheralBaudIndex', _data)
            _kwargs['peripheralBaudIndex'] = _val
            return cls(**_kwargs), _data


class Msp2CommonSetSerialConfig:
    CODE = 4106
    MSPV = 2
    """Sets the configuration for one or more serial ports."""
    @dataclass
    class Request:
        identifier: int = 0
        functionMask: int = 0
        mspBaudIndex: int = 0
        gpsBaudIndex: int = 0
        telemetryBaudIndex: int = 0
        peripheralBaudIndex: int = 0

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.identifier
            out += _pack_scalar('uint8_t', 'identifier', _v)
            _v = self.functionMask
            out += _pack_scalar('uint32_t', 'functionMask', _v)
            _v = self.mspBaudIndex
            out += _pack_scalar('uint8_t', 'mspBaudIndex', _v)
            _v = self.gpsBaudIndex
            out += _pack_scalar('uint8_t', 'gpsBaudIndex', _v)
            _v = self.telemetryBaudIndex
            out += _pack_scalar('uint8_t', 'telemetryBaudIndex', _v)
            _v = self.peripheralBaudIndex
            out += _pack_scalar('uint8_t', 'peripheralBaudIndex', _v)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Request', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _val, _data = _unpack_scalar('uint8_t', 'identifier', _data)
            _kwargs['identifier'] = _val
            _val, _data = _unpack_scalar('uint32_t', 'functionMask', _data)
            _kwargs['functionMask'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'mspBaudIndex', _data)
            _kwargs['mspBaudIndex'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'gpsBaudIndex', _data)
            _kwargs['gpsBaudIndex'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'telemetryBaudIndex', _data)
            _kwargs['telemetryBaudIndex'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'peripheralBaudIndex', _data)
            _kwargs['peripheralBaudIndex'] = _val
            return cls(**_kwargs), _data


class Msp2CommonSetRadarPos:
    CODE = 4107
    MSPV = 2
    """Sets the position and status information for a "radar" Point of Interest (POI). Used for displaying other craft/objects on the OSD map."""
    @dataclass
    class Request:
        poiIndex: int = 0
        state: int = 0
        latitude: int = 0
        longitude: int = 0
        altitude: int = 0
        heading: int = 0
        speed: int = 0
        linkQuality: int = 0

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.poiIndex
            out += _pack_scalar('uint8_t', 'poiIndex', _v)
            _v = self.state
            out += _pack_scalar('uint8_t', 'state', _v)
            _v = self.latitude
            out += _pack_scalar('int32_t', 'latitude', _v)
            _v = self.longitude
            out += _pack_scalar('int32_t', 'longitude', _v)
            _v = self.altitude
            out += _pack_scalar('int32_t', 'altitude', _v)
            _v = self.heading
            out += _pack_scalar('uint16_t', 'heading', _v)
            _v = self.speed
            out += _pack_scalar('uint16_t', 'speed', _v)
            _v = self.linkQuality
            out += _pack_scalar('uint8_t', 'linkQuality', _v)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Request', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _val, _data = _unpack_scalar('uint8_t', 'poiIndex', _data)
            _kwargs['poiIndex'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'state', _data)
            _kwargs['state'] = _val
            _val, _data = _unpack_scalar('int32_t', 'latitude', _data)
            _kwargs['latitude'] = _val
            _val, _data = _unpack_scalar('int32_t', 'longitude', _data)
            _kwargs['longitude'] = _val
            _val, _data = _unpack_scalar('int32_t', 'altitude', _data)
            _kwargs['altitude'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'heading', _data)
            _kwargs['heading'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'speed', _data)
            _kwargs['speed'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'linkQuality', _data)
            _kwargs['linkQuality'] = _val
            return cls(**_kwargs), _data


class Msp2CommonSetRadarItd:
    CODE = 4108
    MSPV = 2
    """Sets radar information to display (likely internal/unused)."""
    pass

class Msp2CommonSetMspRcLinkStats:
    CODE = 4109
    MSPV = 2
    """Provides RC link statistics (RSSI, LQ) to the FC, typically from an MSP-based RC link (like ExpressLRS). Sent periodically by the RC link."""
    @dataclass
    class Request:
        sublinkID: int = 0
        validLink: int = 0
        rssiPercent: int = 0
        uplinkRSSI_dBm: int = 0
        downlinkLQ: int = 0
        uplinkLQ: int = 0
        uplinkSNR: int = 0

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.sublinkID
            out += _pack_scalar('uint8_t', 'sublinkID', _v)
            _v = self.validLink
            out += _pack_scalar('uint8_t', 'validLink', _v)
            _v = self.rssiPercent
            out += _pack_scalar('uint8_t', 'rssiPercent', _v)
            _v = self.uplinkRSSI_dBm
            out += _pack_scalar('uint8_t', 'uplinkRSSI_dBm', _v)
            _v = self.downlinkLQ
            out += _pack_scalar('uint8_t', 'downlinkLQ', _v)
            _v = self.uplinkLQ
            out += _pack_scalar('uint8_t', 'uplinkLQ', _v)
            _v = self.uplinkSNR
            out += _pack_scalar('int8_t', 'uplinkSNR', _v)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Request', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _val, _data = _unpack_scalar('uint8_t', 'sublinkID', _data)
            _kwargs['sublinkID'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'validLink', _data)
            _kwargs['validLink'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'rssiPercent', _data)
            _kwargs['rssiPercent'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'uplinkRSSI_dBm', _data)
            _kwargs['uplinkRSSI_dBm'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'downlinkLQ', _data)
            _kwargs['downlinkLQ'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'uplinkLQ', _data)
            _kwargs['uplinkLQ'] = _val
            _val, _data = _unpack_scalar('int8_t', 'uplinkSNR', _data)
            _kwargs['uplinkSNR'] = _val
            return cls(**_kwargs), _data


class Msp2CommonSetMspRcInfo:
    CODE = 4110
    MSPV = 2
    """Provides additional RC link information (power levels, band, mode) to the FC from an MSP-based RC link. Sent less frequently than link stats."""
    @dataclass
    class Request:
        sublinkID: int = 0
        uplinkTxPower: int = 0
        downlinkTxPower: int = 0
        band: str = ''
        mode: str = ''

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.sublinkID
            out += _pack_scalar('uint8_t', 'sublinkID', _v)
            _v = self.uplinkTxPower
            out += _pack_scalar('uint16_t', 'uplinkTxPower', _v)
            _v = self.downlinkTxPower
            out += _pack_scalar('uint16_t', 'downlinkTxPower', _v)
            _v = self.band
            if not isinstance(_v, str):
                raise TypeError('band must be str')
            _b = _v.encode('ascii', errors='ignore')
            if len(_b) > 4:
                raise ValueError('band length {} > 4'.format(len(_b)))
            out += _b.ljust(4, b'\x00')
            _v = self.mode
            if not isinstance(_v, str):
                raise TypeError('mode must be str')
            _b = _v.encode('ascii', errors='ignore')
            if len(_b) > 6:
                raise ValueError('mode length {} > 6'.format(len(_b)))
            out += _b.ljust(6, b'\x00')
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Request', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _val, _data = _unpack_scalar('uint8_t', 'sublinkID', _data)
            _kwargs['sublinkID'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'uplinkTxPower', _data)
            _kwargs['uplinkTxPower'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'downlinkTxPower', _data)
            _kwargs['downlinkTxPower'] = _val
            if len(_data) < 4:
                raise ValueError('not enough data to unpack band')
            _raw = _data[:4]
            _kwargs['band'] = _raw.split(b'\x00', 1)[0].decode('ascii', errors='ignore')
            _data = _data[4:]
            if len(_data) < 6:
                raise ValueError('not enough data to unpack mode')
            _raw = _data[:6]
            _kwargs['mode'] = _raw.split(b'\x00', 1)[0].decode('ascii', errors='ignore')
            _data = _data[6:]
            return cls(**_kwargs), _data


class Msp2CommonGetRadarGps:
    CODE = 4111
    MSPV = 2
    """Provides the GPS positions (latitude, longitude, altitude) for each radar point of interest."""
    @dataclass
    class Reply:
        poiLatitude: int = 0
        poiLongitude: int = 0
        poiAltitude: int = 0

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.poiLatitude
            out += _pack_scalar('int32_t', 'poiLatitude', _v)
            _v = self.poiLongitude
            out += _pack_scalar('int32_t', 'poiLongitude', _v)
            _v = self.poiAltitude
            out += _pack_scalar('int32_t', 'poiAltitude', _v)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Reply', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _val, _data = _unpack_scalar('int32_t', 'poiLatitude', _data)
            _kwargs['poiLatitude'] = _val
            _val, _data = _unpack_scalar('int32_t', 'poiLongitude', _data)
            _kwargs['poiLongitude'] = _val
            _val, _data = _unpack_scalar('int32_t', 'poiAltitude', _data)
            _kwargs['poiAltitude'] = _val
            return cls(**_kwargs), _data


class Msp2SensorRangefinder:
    CODE = 7937
    MSPV = 2
    """Provides rangefinder data (distance, quality) from an external MSP-based sensor."""
    @dataclass
    class Request:
        quality: int = 0
        distanceMm: int = 0

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.quality
            out += _pack_scalar('uint8_t', 'quality', _v)
            _v = self.distanceMm
            out += _pack_scalar('int32_t', 'distanceMm', _v)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Request', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _val, _data = _unpack_scalar('uint8_t', 'quality', _data)
            _kwargs['quality'] = _val
            _val, _data = _unpack_scalar('int32_t', 'distanceMm', _data)
            _kwargs['distanceMm'] = _val
            return cls(**_kwargs), _data


class Msp2SensorOpticFlow:
    CODE = 7938
    MSPV = 2
    """Provides optical flow data (motion, quality) from an external MSP-based sensor."""
    @dataclass
    class Request:
        quality: int = 0
        motionX: int = 0
        motionY: int = 0

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.quality
            out += _pack_scalar('uint8_t', 'quality', _v)
            _v = self.motionX
            out += _pack_scalar('int32_t', 'motionX', _v)
            _v = self.motionY
            out += _pack_scalar('int32_t', 'motionY', _v)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Request', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _val, _data = _unpack_scalar('uint8_t', 'quality', _data)
            _kwargs['quality'] = _val
            _val, _data = _unpack_scalar('int32_t', 'motionX', _data)
            _kwargs['motionX'] = _val
            _val, _data = _unpack_scalar('int32_t', 'motionY', _data)
            _kwargs['motionY'] = _val
            return cls(**_kwargs), _data


class Msp2SensorGps:
    CODE = 7939
    MSPV = 2
    """Provides detailed GPS data from an external MSP-based GPS module."""
    @dataclass
    class Request:
        instance: int = 0
        gpsWeek: int = 0
        msTOW: int = 0
        fixType: int = 0
        satellitesInView: int = 0
        hPosAccuracy: int = 0
        vPosAccuracy: int = 0
        hVelAccuracy: int = 0
        hdop: int = 0
        longitude: int = 0
        latitude: int = 0
        mslAltitude: int = 0
        nedVelNorth: int = 0
        nedVelEast: int = 0
        nedVelDown: int = 0
        groundCourse: int = 0
        trueYaw: int = 0
        year: int = 0
        month: int = 0
        day: int = 0
        hour: int = 0
        min: int = 0
        sec: int = 0

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.instance
            out += _pack_scalar('uint8_t', 'instance', _v)
            _v = self.gpsWeek
            out += _pack_scalar('uint16_t', 'gpsWeek', _v)
            _v = self.msTOW
            out += _pack_scalar('uint32_t', 'msTOW', _v)
            _v = self.fixType
            out += _pack_scalar('uint8_t', 'fixType', _v)
            _v = self.satellitesInView
            out += _pack_scalar('uint8_t', 'satellitesInView', _v)
            _v = self.hPosAccuracy
            out += _pack_scalar('uint16_t', 'hPosAccuracy', _v)
            _v = self.vPosAccuracy
            out += _pack_scalar('uint16_t', 'vPosAccuracy', _v)
            _v = self.hVelAccuracy
            out += _pack_scalar('uint16_t', 'hVelAccuracy', _v)
            _v = self.hdop
            out += _pack_scalar('uint16_t', 'hdop', _v)
            _v = self.longitude
            out += _pack_scalar('int32_t', 'longitude', _v)
            _v = self.latitude
            out += _pack_scalar('int32_t', 'latitude', _v)
            _v = self.mslAltitude
            out += _pack_scalar('int32_t', 'mslAltitude', _v)
            _v = self.nedVelNorth
            out += _pack_scalar('int32_t', 'nedVelNorth', _v)
            _v = self.nedVelEast
            out += _pack_scalar('int32_t', 'nedVelEast', _v)
            _v = self.nedVelDown
            out += _pack_scalar('int32_t', 'nedVelDown', _v)
            _v = self.groundCourse
            out += _pack_scalar('uint16_t', 'groundCourse', _v)
            _v = self.trueYaw
            out += _pack_scalar('uint16_t', 'trueYaw', _v)
            _v = self.year
            out += _pack_scalar('uint16_t', 'year', _v)
            _v = self.month
            out += _pack_scalar('uint8_t', 'month', _v)
            _v = self.day
            out += _pack_scalar('uint8_t', 'day', _v)
            _v = self.hour
            out += _pack_scalar('uint8_t', 'hour', _v)
            _v = self.min
            out += _pack_scalar('uint8_t', 'min', _v)
            _v = self.sec
            out += _pack_scalar('uint8_t', 'sec', _v)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Request', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _val, _data = _unpack_scalar('uint8_t', 'instance', _data)
            _kwargs['instance'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'gpsWeek', _data)
            _kwargs['gpsWeek'] = _val
            _val, _data = _unpack_scalar('uint32_t', 'msTOW', _data)
            _kwargs['msTOW'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'fixType', _data)
            _kwargs['fixType'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'satellitesInView', _data)
            _kwargs['satellitesInView'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'hPosAccuracy', _data)
            _kwargs['hPosAccuracy'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'vPosAccuracy', _data)
            _kwargs['vPosAccuracy'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'hVelAccuracy', _data)
            _kwargs['hVelAccuracy'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'hdop', _data)
            _kwargs['hdop'] = _val
            _val, _data = _unpack_scalar('int32_t', 'longitude', _data)
            _kwargs['longitude'] = _val
            _val, _data = _unpack_scalar('int32_t', 'latitude', _data)
            _kwargs['latitude'] = _val
            _val, _data = _unpack_scalar('int32_t', 'mslAltitude', _data)
            _kwargs['mslAltitude'] = _val
            _val, _data = _unpack_scalar('int32_t', 'nedVelNorth', _data)
            _kwargs['nedVelNorth'] = _val
            _val, _data = _unpack_scalar('int32_t', 'nedVelEast', _data)
            _kwargs['nedVelEast'] = _val
            _val, _data = _unpack_scalar('int32_t', 'nedVelDown', _data)
            _kwargs['nedVelDown'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'groundCourse', _data)
            _kwargs['groundCourse'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'trueYaw', _data)
            _kwargs['trueYaw'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'year', _data)
            _kwargs['year'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'month', _data)
            _kwargs['month'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'day', _data)
            _kwargs['day'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'hour', _data)
            _kwargs['hour'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'min', _data)
            _kwargs['min'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'sec', _data)
            _kwargs['sec'] = _val
            return cls(**_kwargs), _data


class Msp2SensorCompass:
    CODE = 7940
    MSPV = 2
    """Provides magnetometer data from an external MSP-based compass module."""
    @dataclass
    class Request:
        instance: int = 0
        timeMs: int = 0
        magX: int = 0
        magY: int = 0
        magZ: int = 0

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.instance
            out += _pack_scalar('uint8_t', 'instance', _v)
            _v = self.timeMs
            out += _pack_scalar('uint32_t', 'timeMs', _v)
            _v = self.magX
            out += _pack_scalar('int16_t', 'magX', _v)
            _v = self.magY
            out += _pack_scalar('int16_t', 'magY', _v)
            _v = self.magZ
            out += _pack_scalar('int16_t', 'magZ', _v)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Request', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _val, _data = _unpack_scalar('uint8_t', 'instance', _data)
            _kwargs['instance'] = _val
            _val, _data = _unpack_scalar('uint32_t', 'timeMs', _data)
            _kwargs['timeMs'] = _val
            _val, _data = _unpack_scalar('int16_t', 'magX', _data)
            _kwargs['magX'] = _val
            _val, _data = _unpack_scalar('int16_t', 'magY', _data)
            _kwargs['magY'] = _val
            _val, _data = _unpack_scalar('int16_t', 'magZ', _data)
            _kwargs['magZ'] = _val
            return cls(**_kwargs), _data


class Msp2SensorBarometer:
    CODE = 7941
    MSPV = 2
    """Provides barometer data from an external MSP-based barometer module."""
    @dataclass
    class Request:
        instance: int = 0
        timeMs: int = 0
        pressurePa: float = 0.0
        temp: int = 0

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.instance
            out += _pack_scalar('uint8_t', 'instance', _v)
            _v = self.timeMs
            out += _pack_scalar('uint32_t', 'timeMs', _v)
            _v = self.pressurePa
            out += _pack_scalar('float', 'pressurePa', _v)
            _v = self.temp
            out += _pack_scalar('int16_t', 'temp', _v)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Request', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _val, _data = _unpack_scalar('uint8_t', 'instance', _data)
            _kwargs['instance'] = _val
            _val, _data = _unpack_scalar('uint32_t', 'timeMs', _data)
            _kwargs['timeMs'] = _val
            _val, _data = _unpack_scalar('float', 'pressurePa', _data)
            _kwargs['pressurePa'] = _val
            _val, _data = _unpack_scalar('int16_t', 'temp', _data)
            _kwargs['temp'] = _val
            return cls(**_kwargs), _data


class Msp2SensorAirspeed:
    CODE = 7942
    MSPV = 2
    """Provides airspeed data from an external MSP-based pitot sensor module."""
    @dataclass
    class Request:
        instance: int = 0
        timeMs: int = 0
        diffPressurePa: float = 0.0
        temp: int = 0

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.instance
            out += _pack_scalar('uint8_t', 'instance', _v)
            _v = self.timeMs
            out += _pack_scalar('uint32_t', 'timeMs', _v)
            _v = self.diffPressurePa
            out += _pack_scalar('float', 'diffPressurePa', _v)
            _v = self.temp
            out += _pack_scalar('int16_t', 'temp', _v)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Request', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _val, _data = _unpack_scalar('uint8_t', 'instance', _data)
            _kwargs['instance'] = _val
            _val, _data = _unpack_scalar('uint32_t', 'timeMs', _data)
            _kwargs['timeMs'] = _val
            _val, _data = _unpack_scalar('float', 'diffPressurePa', _data)
            _kwargs['diffPressurePa'] = _val
            _val, _data = _unpack_scalar('int16_t', 'temp', _data)
            _kwargs['temp'] = _val
            return cls(**_kwargs), _data


class Msp2SensorHeadtracker:
    CODE = 7943
    MSPV = 2
    """Provides head tracker orientation data."""
    @dataclass
    class Request:
        ...: int = 0

        def pack(self) -> bytes:
            out = bytearray()
            _v = self....
            out += _pack_scalar('Varies', '...', _v)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Request', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _val, _data = _unpack_scalar('Varies', '...', _data)
            _kwargs['...'] = _val
            return cls(**_kwargs), _data


class Msp2InavStatus:
    CODE = 8192
    MSPV = 2
    """Provides comprehensive flight controller status, extending `MSP_STATUS_EX` with full arming flags, battery profile, and mixer profile."""
    @dataclass
    class Reply:
        cycleTime: int = 0
        i2cErrors: int = 0
        sensorStatus: int = 0
        cpuLoad: int = 0
        profileAndBattProfile: int = 0
        armingFlags: int = 0
        activeModes: int = 0
        mixerProfile: int = 0

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.cycleTime
            out += _pack_scalar('uint16_t', 'cycleTime', _v)
            _v = self.i2cErrors
            out += _pack_scalar('uint16_t', 'i2cErrors', _v)
            _v = self.sensorStatus
            out += _pack_scalar('uint16_t', 'sensorStatus', _v)
            _v = self.cpuLoad
            out += _pack_scalar('uint16_t', 'cpuLoad', _v)
            _v = self.profileAndBattProfile
            out += _pack_scalar('uint8_t', 'profileAndBattProfile', _v)
            _v = self.armingFlags
            out += _pack_scalar('uint32_t', 'armingFlags', _v)
            _v = self.activeModes
            out += _pack_scalar('boxBitmask_t', 'activeModes', _v)
            _v = self.mixerProfile
            out += _pack_scalar('uint8_t', 'mixerProfile', _v)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Reply', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _val, _data = _unpack_scalar('uint16_t', 'cycleTime', _data)
            _kwargs['cycleTime'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'i2cErrors', _data)
            _kwargs['i2cErrors'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'sensorStatus', _data)
            _kwargs['sensorStatus'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'cpuLoad', _data)
            _kwargs['cpuLoad'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'profileAndBattProfile', _data)
            _kwargs['profileAndBattProfile'] = _val
            _val, _data = _unpack_scalar('uint32_t', 'armingFlags', _data)
            _kwargs['armingFlags'] = _val
            _val, _data = _unpack_scalar('boxBitmask_t', 'activeModes', _data)
            _kwargs['activeModes'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'mixerProfile', _data)
            _kwargs['mixerProfile'] = _val
            return cls(**_kwargs), _data


class Msp2InavOpticalFlow:
    CODE = 8193
    MSPV = 2
    """Provides data from the optical flow sensor."""
    @dataclass
    class Reply:
        quality: int = 0
        flowRateX: int = 0
        flowRateY: int = 0
        bodyRateX: int = 0
        bodyRateY: int = 0

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.quality
            out += _pack_scalar('uint8_t', 'quality', _v)
            _v = self.flowRateX
            out += _pack_scalar('int16_t', 'flowRateX', _v)
            _v = self.flowRateY
            out += _pack_scalar('int16_t', 'flowRateY', _v)
            _v = self.bodyRateX
            out += _pack_scalar('int16_t', 'bodyRateX', _v)
            _v = self.bodyRateY
            out += _pack_scalar('int16_t', 'bodyRateY', _v)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Reply', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _val, _data = _unpack_scalar('uint8_t', 'quality', _data)
            _kwargs['quality'] = _val
            _val, _data = _unpack_scalar('int16_t', 'flowRateX', _data)
            _kwargs['flowRateX'] = _val
            _val, _data = _unpack_scalar('int16_t', 'flowRateY', _data)
            _kwargs['flowRateY'] = _val
            _val, _data = _unpack_scalar('int16_t', 'bodyRateX', _data)
            _kwargs['bodyRateX'] = _val
            _val, _data = _unpack_scalar('int16_t', 'bodyRateY', _data)
            _kwargs['bodyRateY'] = _val
            return cls(**_kwargs), _data


class Msp2InavAnalog:
    CODE = 8194
    MSPV = 2
    """Provides detailed analog sensor readings, superseding `MSP_ANALOG` with higher precision and additional fields."""
    @dataclass
    class Reply:
        batteryFlags: int = 0
        vbat: int = 0
        amperage: int = 0
        powerDraw: int = 0
        mAhDrawn: int = 0
        mWhDrawn: int = 0
        remainingCapacity: int = 0
        percentageRemaining: int = 0
        rssi: int = 0

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.batteryFlags
            out += _pack_scalar('uint8_t', 'batteryFlags', _v)
            _v = self.vbat
            out += _pack_scalar('uint16_t', 'vbat', _v)
            _v = self.amperage
            out += _pack_scalar('int16_t', 'amperage', _v)
            _v = self.powerDraw
            out += _pack_scalar('uint32_t', 'powerDraw', _v)
            _v = self.mAhDrawn
            out += _pack_scalar('uint32_t', 'mAhDrawn', _v)
            _v = self.mWhDrawn
            out += _pack_scalar('uint32_t', 'mWhDrawn', _v)
            _v = self.remainingCapacity
            out += _pack_scalar('uint32_t', 'remainingCapacity', _v)
            _v = self.percentageRemaining
            out += _pack_scalar('uint8_t', 'percentageRemaining', _v)
            _v = self.rssi
            out += _pack_scalar('uint16_t', 'rssi', _v)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Reply', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _val, _data = _unpack_scalar('uint8_t', 'batteryFlags', _data)
            _kwargs['batteryFlags'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'vbat', _data)
            _kwargs['vbat'] = _val
            _val, _data = _unpack_scalar('int16_t', 'amperage', _data)
            _kwargs['amperage'] = _val
            _val, _data = _unpack_scalar('uint32_t', 'powerDraw', _data)
            _kwargs['powerDraw'] = _val
            _val, _data = _unpack_scalar('uint32_t', 'mAhDrawn', _data)
            _kwargs['mAhDrawn'] = _val
            _val, _data = _unpack_scalar('uint32_t', 'mWhDrawn', _data)
            _kwargs['mWhDrawn'] = _val
            _val, _data = _unpack_scalar('uint32_t', 'remainingCapacity', _data)
            _kwargs['remainingCapacity'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'percentageRemaining', _data)
            _kwargs['percentageRemaining'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'rssi', _data)
            _kwargs['rssi'] = _val
            return cls(**_kwargs), _data


class Msp2InavMisc:
    CODE = 8195
    MSPV = 2
    """Retrieves miscellaneous configuration settings, superseding `MSP_MISC` with higher precision and capacity fields."""
    @dataclass
    class Reply:
        midRc: int = 0
        legacyMinThrottle: int = 0
        maxThrottle: int = 0
        minCommand: int = 0
        failsafeThrottle: int = 0
        gpsType: int = 0
        legacyGpsBaud: int = 0
        gpsSbasMode: int = 0
        rssiChannel: int = 0
        magDeclination: int = 0
        vbatScale: int = 0
        vbatSource: int = 0
        cellCount: int = 0
        vbatCellDetect: int = 0
        vbatMinCell: int = 0
        vbatMaxCell: int = 0
        vbatWarningCell: int = 0
        capacityValue: int = 0
        capacityWarning: int = 0
        capacityCritical: int = 0
        capacityUnit: int = 0

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.midRc
            out += _pack_scalar('uint16_t', 'midRc', _v)
            _v = self.legacyMinThrottle
            out += _pack_scalar('uint16_t', 'legacyMinThrottle', _v)
            _v = self.maxThrottle
            out += _pack_scalar('uint16_t', 'maxThrottle', _v)
            _v = self.minCommand
            out += _pack_scalar('uint16_t', 'minCommand', _v)
            _v = self.failsafeThrottle
            out += _pack_scalar('uint16_t', 'failsafeThrottle', _v)
            _v = self.gpsType
            out += _pack_scalar('uint8_t', 'gpsType', _v)
            _v = self.legacyGpsBaud
            out += _pack_scalar('uint8_t', 'legacyGpsBaud', _v)
            _v = self.gpsSbasMode
            out += _pack_scalar('uint8_t', 'gpsSbasMode', _v)
            _v = self.rssiChannel
            out += _pack_scalar('uint8_t', 'rssiChannel', _v)
            _v = self.magDeclination
            out += _pack_scalar('int16_t', 'magDeclination', _v)
            _v = self.vbatScale
            out += _pack_scalar('uint16_t', 'vbatScale', _v)
            _v = self.vbatSource
            out += _pack_scalar('uint8_t', 'vbatSource', _v)
            _v = self.cellCount
            out += _pack_scalar('uint8_t', 'cellCount', _v)
            _v = self.vbatCellDetect
            out += _pack_scalar('uint16_t', 'vbatCellDetect', _v)
            _v = self.vbatMinCell
            out += _pack_scalar('uint16_t', 'vbatMinCell', _v)
            _v = self.vbatMaxCell
            out += _pack_scalar('uint16_t', 'vbatMaxCell', _v)
            _v = self.vbatWarningCell
            out += _pack_scalar('uint16_t', 'vbatWarningCell', _v)
            _v = self.capacityValue
            out += _pack_scalar('uint32_t', 'capacityValue', _v)
            _v = self.capacityWarning
            out += _pack_scalar('uint32_t', 'capacityWarning', _v)
            _v = self.capacityCritical
            out += _pack_scalar('uint32_t', 'capacityCritical', _v)
            _v = self.capacityUnit
            out += _pack_scalar('uint8_t', 'capacityUnit', _v)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Reply', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _val, _data = _unpack_scalar('uint16_t', 'midRc', _data)
            _kwargs['midRc'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'legacyMinThrottle', _data)
            _kwargs['legacyMinThrottle'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'maxThrottle', _data)
            _kwargs['maxThrottle'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'minCommand', _data)
            _kwargs['minCommand'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'failsafeThrottle', _data)
            _kwargs['failsafeThrottle'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'gpsType', _data)
            _kwargs['gpsType'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'legacyGpsBaud', _data)
            _kwargs['legacyGpsBaud'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'gpsSbasMode', _data)
            _kwargs['gpsSbasMode'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'rssiChannel', _data)
            _kwargs['rssiChannel'] = _val
            _val, _data = _unpack_scalar('int16_t', 'magDeclination', _data)
            _kwargs['magDeclination'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'vbatScale', _data)
            _kwargs['vbatScale'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'vbatSource', _data)
            _kwargs['vbatSource'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'cellCount', _data)
            _kwargs['cellCount'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'vbatCellDetect', _data)
            _kwargs['vbatCellDetect'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'vbatMinCell', _data)
            _kwargs['vbatMinCell'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'vbatMaxCell', _data)
            _kwargs['vbatMaxCell'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'vbatWarningCell', _data)
            _kwargs['vbatWarningCell'] = _val
            _val, _data = _unpack_scalar('uint32_t', 'capacityValue', _data)
            _kwargs['capacityValue'] = _val
            _val, _data = _unpack_scalar('uint32_t', 'capacityWarning', _data)
            _kwargs['capacityWarning'] = _val
            _val, _data = _unpack_scalar('uint32_t', 'capacityCritical', _data)
            _kwargs['capacityCritical'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'capacityUnit', _data)
            _kwargs['capacityUnit'] = _val
            return cls(**_kwargs), _data


class Msp2InavSetMisc:
    CODE = 8196
    MSPV = 2
    """Sets miscellaneous configuration settings, superseding `MSP_SET_MISC`."""
    @dataclass
    class Request:
        midRc: int = 0
        legacyMinThrottle: int = 0
        legacyMaxThrottle: int = 0
        minCommand: int = 0
        failsafeThrottle: int = 0
        gpsType: int = 0
        legacyGpsBaud: int = 0
        gpsSbasMode: int = 0
        rssiChannel: int = 0
        magDeclination: int = 0
        vbatScale: int = 0
        vbatSource: int = 0
        cellCount: int = 0
        vbatCellDetect: int = 0
        vbatMinCell: int = 0
        vbatMaxCell: int = 0
        vbatWarningCell: int = 0
        capacityValue: int = 0
        capacityWarning: int = 0
        capacityCritical: int = 0
        capacityUnit: int = 0

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.midRc
            out += _pack_scalar('uint16_t', 'midRc', _v)
            _v = self.legacyMinThrottle
            out += _pack_scalar('uint16_t', 'legacyMinThrottle', _v)
            _v = self.legacyMaxThrottle
            out += _pack_scalar('uint16_t', 'legacyMaxThrottle', _v)
            _v = self.minCommand
            out += _pack_scalar('uint16_t', 'minCommand', _v)
            _v = self.failsafeThrottle
            out += _pack_scalar('uint16_t', 'failsafeThrottle', _v)
            _v = self.gpsType
            out += _pack_scalar('uint8_t', 'gpsType', _v)
            _v = self.legacyGpsBaud
            out += _pack_scalar('uint8_t', 'legacyGpsBaud', _v)
            _v = self.gpsSbasMode
            out += _pack_scalar('uint8_t', 'gpsSbasMode', _v)
            _v = self.rssiChannel
            out += _pack_scalar('uint8_t', 'rssiChannel', _v)
            _v = self.magDeclination
            out += _pack_scalar('int16_t', 'magDeclination', _v)
            _v = self.vbatScale
            out += _pack_scalar('uint16_t', 'vbatScale', _v)
            _v = self.vbatSource
            out += _pack_scalar('uint8_t', 'vbatSource', _v)
            _v = self.cellCount
            out += _pack_scalar('uint8_t', 'cellCount', _v)
            _v = self.vbatCellDetect
            out += _pack_scalar('uint16_t', 'vbatCellDetect', _v)
            _v = self.vbatMinCell
            out += _pack_scalar('uint16_t', 'vbatMinCell', _v)
            _v = self.vbatMaxCell
            out += _pack_scalar('uint16_t', 'vbatMaxCell', _v)
            _v = self.vbatWarningCell
            out += _pack_scalar('uint16_t', 'vbatWarningCell', _v)
            _v = self.capacityValue
            out += _pack_scalar('uint32_t', 'capacityValue', _v)
            _v = self.capacityWarning
            out += _pack_scalar('uint32_t', 'capacityWarning', _v)
            _v = self.capacityCritical
            out += _pack_scalar('uint32_t', 'capacityCritical', _v)
            _v = self.capacityUnit
            out += _pack_scalar('uint8_t', 'capacityUnit', _v)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Request', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _val, _data = _unpack_scalar('uint16_t', 'midRc', _data)
            _kwargs['midRc'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'legacyMinThrottle', _data)
            _kwargs['legacyMinThrottle'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'legacyMaxThrottle', _data)
            _kwargs['legacyMaxThrottle'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'minCommand', _data)
            _kwargs['minCommand'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'failsafeThrottle', _data)
            _kwargs['failsafeThrottle'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'gpsType', _data)
            _kwargs['gpsType'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'legacyGpsBaud', _data)
            _kwargs['legacyGpsBaud'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'gpsSbasMode', _data)
            _kwargs['gpsSbasMode'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'rssiChannel', _data)
            _kwargs['rssiChannel'] = _val
            _val, _data = _unpack_scalar('int16_t', 'magDeclination', _data)
            _kwargs['magDeclination'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'vbatScale', _data)
            _kwargs['vbatScale'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'vbatSource', _data)
            _kwargs['vbatSource'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'cellCount', _data)
            _kwargs['cellCount'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'vbatCellDetect', _data)
            _kwargs['vbatCellDetect'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'vbatMinCell', _data)
            _kwargs['vbatMinCell'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'vbatMaxCell', _data)
            _kwargs['vbatMaxCell'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'vbatWarningCell', _data)
            _kwargs['vbatWarningCell'] = _val
            _val, _data = _unpack_scalar('uint32_t', 'capacityValue', _data)
            _kwargs['capacityValue'] = _val
            _val, _data = _unpack_scalar('uint32_t', 'capacityWarning', _data)
            _kwargs['capacityWarning'] = _val
            _val, _data = _unpack_scalar('uint32_t', 'capacityCritical', _data)
            _kwargs['capacityCritical'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'capacityUnit', _data)
            _kwargs['capacityUnit'] = _val
            return cls(**_kwargs), _data


class Msp2InavBatteryConfig:
    CODE = 8197
    MSPV = 2
    """Retrieves the configuration specific to the battery voltage and current sensors and capacity settings for the current battery profile."""
    @dataclass
    class Reply:
        vbatScale: int = 0
        vbatSource: int = 0
        cellCount: int = 0
        vbatCellDetect: int = 0
        vbatMinCell: int = 0
        vbatMaxCell: int = 0
        vbatWarningCell: int = 0
        currentOffset: int = 0
        currentScale: int = 0
        capacityValue: int = 0
        capacityWarning: int = 0
        capacityCritical: int = 0
        capacityUnit: int = 0

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.vbatScale
            out += _pack_scalar('uint16_t', 'vbatScale', _v)
            _v = self.vbatSource
            out += _pack_scalar('uint8_t', 'vbatSource', _v)
            _v = self.cellCount
            out += _pack_scalar('uint8_t', 'cellCount', _v)
            _v = self.vbatCellDetect
            out += _pack_scalar('uint16_t', 'vbatCellDetect', _v)
            _v = self.vbatMinCell
            out += _pack_scalar('uint16_t', 'vbatMinCell', _v)
            _v = self.vbatMaxCell
            out += _pack_scalar('uint16_t', 'vbatMaxCell', _v)
            _v = self.vbatWarningCell
            out += _pack_scalar('uint16_t', 'vbatWarningCell', _v)
            _v = self.currentOffset
            out += _pack_scalar('int16_t', 'currentOffset', _v)
            _v = self.currentScale
            out += _pack_scalar('int16_t', 'currentScale', _v)
            _v = self.capacityValue
            out += _pack_scalar('uint32_t', 'capacityValue', _v)
            _v = self.capacityWarning
            out += _pack_scalar('uint32_t', 'capacityWarning', _v)
            _v = self.capacityCritical
            out += _pack_scalar('uint32_t', 'capacityCritical', _v)
            _v = self.capacityUnit
            out += _pack_scalar('uint8_t', 'capacityUnit', _v)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Reply', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _val, _data = _unpack_scalar('uint16_t', 'vbatScale', _data)
            _kwargs['vbatScale'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'vbatSource', _data)
            _kwargs['vbatSource'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'cellCount', _data)
            _kwargs['cellCount'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'vbatCellDetect', _data)
            _kwargs['vbatCellDetect'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'vbatMinCell', _data)
            _kwargs['vbatMinCell'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'vbatMaxCell', _data)
            _kwargs['vbatMaxCell'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'vbatWarningCell', _data)
            _kwargs['vbatWarningCell'] = _val
            _val, _data = _unpack_scalar('int16_t', 'currentOffset', _data)
            _kwargs['currentOffset'] = _val
            _val, _data = _unpack_scalar('int16_t', 'currentScale', _data)
            _kwargs['currentScale'] = _val
            _val, _data = _unpack_scalar('uint32_t', 'capacityValue', _data)
            _kwargs['capacityValue'] = _val
            _val, _data = _unpack_scalar('uint32_t', 'capacityWarning', _data)
            _kwargs['capacityWarning'] = _val
            _val, _data = _unpack_scalar('uint32_t', 'capacityCritical', _data)
            _kwargs['capacityCritical'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'capacityUnit', _data)
            _kwargs['capacityUnit'] = _val
            return cls(**_kwargs), _data


class Msp2InavSetBatteryConfig:
    CODE = 8198
    MSPV = 2
    """Sets the battery voltage/current sensor configuration and capacity settings for the current battery profile."""
    @dataclass
    class Request:
        vbatScale: int = 0
        vbatSource: int = 0
        cellCount: int = 0
        vbatCellDetect: int = 0
        vbatMinCell: int = 0
        vbatMaxCell: int = 0
        vbatWarningCell: int = 0
        currentOffset: int = 0
        currentScale: int = 0
        capacityValue: int = 0
        capacityWarning: int = 0
        capacityCritical: int = 0
        capacityUnit: int = 0

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.vbatScale
            out += _pack_scalar('uint16_t', 'vbatScale', _v)
            _v = self.vbatSource
            out += _pack_scalar('uint8_t', 'vbatSource', _v)
            _v = self.cellCount
            out += _pack_scalar('uint8_t', 'cellCount', _v)
            _v = self.vbatCellDetect
            out += _pack_scalar('uint16_t', 'vbatCellDetect', _v)
            _v = self.vbatMinCell
            out += _pack_scalar('uint16_t', 'vbatMinCell', _v)
            _v = self.vbatMaxCell
            out += _pack_scalar('uint16_t', 'vbatMaxCell', _v)
            _v = self.vbatWarningCell
            out += _pack_scalar('uint16_t', 'vbatWarningCell', _v)
            _v = self.currentOffset
            out += _pack_scalar('int16_t', 'currentOffset', _v)
            _v = self.currentScale
            out += _pack_scalar('int16_t', 'currentScale', _v)
            _v = self.capacityValue
            out += _pack_scalar('uint32_t', 'capacityValue', _v)
            _v = self.capacityWarning
            out += _pack_scalar('uint32_t', 'capacityWarning', _v)
            _v = self.capacityCritical
            out += _pack_scalar('uint32_t', 'capacityCritical', _v)
            _v = self.capacityUnit
            out += _pack_scalar('uint8_t', 'capacityUnit', _v)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Request', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _val, _data = _unpack_scalar('uint16_t', 'vbatScale', _data)
            _kwargs['vbatScale'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'vbatSource', _data)
            _kwargs['vbatSource'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'cellCount', _data)
            _kwargs['cellCount'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'vbatCellDetect', _data)
            _kwargs['vbatCellDetect'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'vbatMinCell', _data)
            _kwargs['vbatMinCell'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'vbatMaxCell', _data)
            _kwargs['vbatMaxCell'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'vbatWarningCell', _data)
            _kwargs['vbatWarningCell'] = _val
            _val, _data = _unpack_scalar('int16_t', 'currentOffset', _data)
            _kwargs['currentOffset'] = _val
            _val, _data = _unpack_scalar('int16_t', 'currentScale', _data)
            _kwargs['currentScale'] = _val
            _val, _data = _unpack_scalar('uint32_t', 'capacityValue', _data)
            _kwargs['capacityValue'] = _val
            _val, _data = _unpack_scalar('uint32_t', 'capacityWarning', _data)
            _kwargs['capacityWarning'] = _val
            _val, _data = _unpack_scalar('uint32_t', 'capacityCritical', _data)
            _kwargs['capacityCritical'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'capacityUnit', _data)
            _kwargs['capacityUnit'] = _val
            return cls(**_kwargs), _data


class Msp2InavRateProfile:
    CODE = 8199
    MSPV = 2
    """Retrieves the rates and expos for the current control rate profile, including both stabilized and manual flight modes. Supersedes `MSP_RC_TUNING`."""
    @dataclass
    class Reply:
        throttleMid: int = 0
        throttleExpo: int = 0
        dynamicThrottlePID: int = 0
        tpaBreakpoint: int = 0
        stabRcExpo: int = 0
        stabRcYawExpo: int = 0
        stabRollRate: int = 0
        stabPitchRate: int = 0
        stabYawRate: int = 0
        manualRcExpo: int = 0
        manualRcYawExpo: int = 0
        manualRollRate: int = 0
        manualPitchRate: int = 0
        manualYawRate: int = 0

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.throttleMid
            out += _pack_scalar('uint8_t', 'throttleMid', _v)
            _v = self.throttleExpo
            out += _pack_scalar('uint8_t', 'throttleExpo', _v)
            _v = self.dynamicThrottlePID
            out += _pack_scalar('uint8_t', 'dynamicThrottlePID', _v)
            _v = self.tpaBreakpoint
            out += _pack_scalar('uint16_t', 'tpaBreakpoint', _v)
            _v = self.stabRcExpo
            out += _pack_scalar('uint8_t', 'stabRcExpo', _v)
            _v = self.stabRcYawExpo
            out += _pack_scalar('uint8_t', 'stabRcYawExpo', _v)
            _v = self.stabRollRate
            out += _pack_scalar('uint8_t', 'stabRollRate', _v)
            _v = self.stabPitchRate
            out += _pack_scalar('uint8_t', 'stabPitchRate', _v)
            _v = self.stabYawRate
            out += _pack_scalar('uint8_t', 'stabYawRate', _v)
            _v = self.manualRcExpo
            out += _pack_scalar('uint8_t', 'manualRcExpo', _v)
            _v = self.manualRcYawExpo
            out += _pack_scalar('uint8_t', 'manualRcYawExpo', _v)
            _v = self.manualRollRate
            out += _pack_scalar('uint8_t', 'manualRollRate', _v)
            _v = self.manualPitchRate
            out += _pack_scalar('uint8_t', 'manualPitchRate', _v)
            _v = self.manualYawRate
            out += _pack_scalar('uint8_t', 'manualYawRate', _v)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Reply', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _val, _data = _unpack_scalar('uint8_t', 'throttleMid', _data)
            _kwargs['throttleMid'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'throttleExpo', _data)
            _kwargs['throttleExpo'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'dynamicThrottlePID', _data)
            _kwargs['dynamicThrottlePID'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'tpaBreakpoint', _data)
            _kwargs['tpaBreakpoint'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'stabRcExpo', _data)
            _kwargs['stabRcExpo'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'stabRcYawExpo', _data)
            _kwargs['stabRcYawExpo'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'stabRollRate', _data)
            _kwargs['stabRollRate'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'stabPitchRate', _data)
            _kwargs['stabPitchRate'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'stabYawRate', _data)
            _kwargs['stabYawRate'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'manualRcExpo', _data)
            _kwargs['manualRcExpo'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'manualRcYawExpo', _data)
            _kwargs['manualRcYawExpo'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'manualRollRate', _data)
            _kwargs['manualRollRate'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'manualPitchRate', _data)
            _kwargs['manualPitchRate'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'manualYawRate', _data)
            _kwargs['manualYawRate'] = _val
            return cls(**_kwargs), _data


class Msp2InavSetRateProfile:
    CODE = 8200
    MSPV = 2
    """Sets the rates and expos for the current control rate profile (stabilized and manual). Supersedes `MSP_SET_RC_TUNING`."""
    @dataclass
    class Request:
        throttleMid: int = 0
        throttleExpo: int = 0
        dynamicThrottlePID: int = 0
        tpaBreakpoint: int = 0
        stabRcExpo: int = 0
        stabRcYawExpo: int = 0
        stabRollRate: int = 0
        stabPitchRate: int = 0
        stabYawRate: int = 0
        manualRcExpo: int = 0
        manualRcYawExpo: int = 0
        manualRollRate: int = 0
        manualPitchRate: int = 0
        manualYawRate: int = 0

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.throttleMid
            out += _pack_scalar('uint8_t', 'throttleMid', _v)
            _v = self.throttleExpo
            out += _pack_scalar('uint8_t', 'throttleExpo', _v)
            _v = self.dynamicThrottlePID
            out += _pack_scalar('uint8_t', 'dynamicThrottlePID', _v)
            _v = self.tpaBreakpoint
            out += _pack_scalar('uint16_t', 'tpaBreakpoint', _v)
            _v = self.stabRcExpo
            out += _pack_scalar('uint8_t', 'stabRcExpo', _v)
            _v = self.stabRcYawExpo
            out += _pack_scalar('uint8_t', 'stabRcYawExpo', _v)
            _v = self.stabRollRate
            out += _pack_scalar('uint8_t', 'stabRollRate', _v)
            _v = self.stabPitchRate
            out += _pack_scalar('uint8_t', 'stabPitchRate', _v)
            _v = self.stabYawRate
            out += _pack_scalar('uint8_t', 'stabYawRate', _v)
            _v = self.manualRcExpo
            out += _pack_scalar('uint8_t', 'manualRcExpo', _v)
            _v = self.manualRcYawExpo
            out += _pack_scalar('uint8_t', 'manualRcYawExpo', _v)
            _v = self.manualRollRate
            out += _pack_scalar('uint8_t', 'manualRollRate', _v)
            _v = self.manualPitchRate
            out += _pack_scalar('uint8_t', 'manualPitchRate', _v)
            _v = self.manualYawRate
            out += _pack_scalar('uint8_t', 'manualYawRate', _v)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Request', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _val, _data = _unpack_scalar('uint8_t', 'throttleMid', _data)
            _kwargs['throttleMid'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'throttleExpo', _data)
            _kwargs['throttleExpo'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'dynamicThrottlePID', _data)
            _kwargs['dynamicThrottlePID'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'tpaBreakpoint', _data)
            _kwargs['tpaBreakpoint'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'stabRcExpo', _data)
            _kwargs['stabRcExpo'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'stabRcYawExpo', _data)
            _kwargs['stabRcYawExpo'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'stabRollRate', _data)
            _kwargs['stabRollRate'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'stabPitchRate', _data)
            _kwargs['stabPitchRate'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'stabYawRate', _data)
            _kwargs['stabYawRate'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'manualRcExpo', _data)
            _kwargs['manualRcExpo'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'manualRcYawExpo', _data)
            _kwargs['manualRcYawExpo'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'manualRollRate', _data)
            _kwargs['manualRollRate'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'manualPitchRate', _data)
            _kwargs['manualPitchRate'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'manualYawRate', _data)
            _kwargs['manualYawRate'] = _val
            return cls(**_kwargs), _data


class Msp2InavAirSpeed:
    CODE = 8201
    MSPV = 2
    """Retrieves the estimated or measured airspeed."""
    @dataclass
    class Reply:
        airspeed: int = 0

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.airspeed
            out += _pack_scalar('uint32_t', 'airspeed', _v)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Reply', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _val, _data = _unpack_scalar('uint32_t', 'airspeed', _data)
            _kwargs['airspeed'] = _val
            return cls(**_kwargs), _data


class Msp2InavOutputMapping:
    CODE = 8202
    MSPV = 2
    """Retrieves the output mapping configuration (identifies which timer outputs are used for Motors/Servos). Legacy version sending only 8-bit usage flags."""
    @dataclass
    class Reply:
        usageFlags: int = 0

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.usageFlags
            out += _pack_scalar('uint8_t', 'usageFlags', _v)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Reply', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _val, _data = _unpack_scalar('uint8_t', 'usageFlags', _data)
            _kwargs['usageFlags'] = _val
            return cls(**_kwargs), _data


class Msp2InavMcBraking:
    CODE = 8203
    MSPV = 2
    """Retrieves configuration parameters for the multirotor braking mode feature."""
    @dataclass
    class Reply:
        brakingSpeedThreshold: int = 0
        brakingDisengageSpeed: int = 0
        brakingTimeout: int = 0
        brakingBoostFactor: int = 0
        brakingBoostTimeout: int = 0
        brakingBoostSpeedThreshold: int = 0
        brakingBoostDisengageSpeed: int = 0
        brakingBankAngle: int = 0

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.brakingSpeedThreshold
            out += _pack_scalar('uint16_t', 'brakingSpeedThreshold', _v)
            _v = self.brakingDisengageSpeed
            out += _pack_scalar('uint16_t', 'brakingDisengageSpeed', _v)
            _v = self.brakingTimeout
            out += _pack_scalar('uint16_t', 'brakingTimeout', _v)
            _v = self.brakingBoostFactor
            out += _pack_scalar('uint8_t', 'brakingBoostFactor', _v)
            _v = self.brakingBoostTimeout
            out += _pack_scalar('uint16_t', 'brakingBoostTimeout', _v)
            _v = self.brakingBoostSpeedThreshold
            out += _pack_scalar('uint16_t', 'brakingBoostSpeedThreshold', _v)
            _v = self.brakingBoostDisengageSpeed
            out += _pack_scalar('uint16_t', 'brakingBoostDisengageSpeed', _v)
            _v = self.brakingBankAngle
            out += _pack_scalar('uint8_t', 'brakingBankAngle', _v)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Reply', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _val, _data = _unpack_scalar('uint16_t', 'brakingSpeedThreshold', _data)
            _kwargs['brakingSpeedThreshold'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'brakingDisengageSpeed', _data)
            _kwargs['brakingDisengageSpeed'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'brakingTimeout', _data)
            _kwargs['brakingTimeout'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'brakingBoostFactor', _data)
            _kwargs['brakingBoostFactor'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'brakingBoostTimeout', _data)
            _kwargs['brakingBoostTimeout'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'brakingBoostSpeedThreshold', _data)
            _kwargs['brakingBoostSpeedThreshold'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'brakingBoostDisengageSpeed', _data)
            _kwargs['brakingBoostDisengageSpeed'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'brakingBankAngle', _data)
            _kwargs['brakingBankAngle'] = _val
            return cls(**_kwargs), _data


class Msp2InavSetMcBraking:
    CODE = 8204
    MSPV = 2
    """Sets configuration parameters for the multirotor braking mode feature."""
    @dataclass
    class Request:
        brakingSpeedThreshold: int = 0
        brakingDisengageSpeed: int = 0
        brakingTimeout: int = 0
        brakingBoostFactor: int = 0
        brakingBoostTimeout: int = 0
        brakingBoostSpeedThreshold: int = 0
        brakingBoostDisengageSpeed: int = 0
        brakingBankAngle: int = 0

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.brakingSpeedThreshold
            out += _pack_scalar('uint16_t', 'brakingSpeedThreshold', _v)
            _v = self.brakingDisengageSpeed
            out += _pack_scalar('uint16_t', 'brakingDisengageSpeed', _v)
            _v = self.brakingTimeout
            out += _pack_scalar('uint16_t', 'brakingTimeout', _v)
            _v = self.brakingBoostFactor
            out += _pack_scalar('uint8_t', 'brakingBoostFactor', _v)
            _v = self.brakingBoostTimeout
            out += _pack_scalar('uint16_t', 'brakingBoostTimeout', _v)
            _v = self.brakingBoostSpeedThreshold
            out += _pack_scalar('uint16_t', 'brakingBoostSpeedThreshold', _v)
            _v = self.brakingBoostDisengageSpeed
            out += _pack_scalar('uint16_t', 'brakingBoostDisengageSpeed', _v)
            _v = self.brakingBankAngle
            out += _pack_scalar('uint8_t', 'brakingBankAngle', _v)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Request', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _val, _data = _unpack_scalar('uint16_t', 'brakingSpeedThreshold', _data)
            _kwargs['brakingSpeedThreshold'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'brakingDisengageSpeed', _data)
            _kwargs['brakingDisengageSpeed'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'brakingTimeout', _data)
            _kwargs['brakingTimeout'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'brakingBoostFactor', _data)
            _kwargs['brakingBoostFactor'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'brakingBoostTimeout', _data)
            _kwargs['brakingBoostTimeout'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'brakingBoostSpeedThreshold', _data)
            _kwargs['brakingBoostSpeedThreshold'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'brakingBoostDisengageSpeed', _data)
            _kwargs['brakingBoostDisengageSpeed'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'brakingBankAngle', _data)
            _kwargs['brakingBankAngle'] = _val
            return cls(**_kwargs), _data


class Msp2InavOutputMappingExt:
    CODE = 8205
    MSPV = 2
    """Retrieves extended output mapping configuration (timer ID and usage flags). Obsolete, use `MSP2_INAV_OUTPUT_MAPPING_EXT2`."""
    @dataclass
    class Reply:
        timerId: int = 0
        usageFlags: int = 0

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.timerId
            out += _pack_scalar('uint8_t', 'timerId', _v)
            _v = self.usageFlags
            out += _pack_scalar('uint8_t', 'usageFlags', _v)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Reply', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _val, _data = _unpack_scalar('uint8_t', 'timerId', _data)
            _kwargs['timerId'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'usageFlags', _data)
            _kwargs['usageFlags'] = _val
            return cls(**_kwargs), _data


class Msp2InavTimerOutputMode:
    CODE = 8206
    MSPV = 2
    """Reads timer output mode overrides."""
    pass

class Msp2InavSetTimerOutputMode:
    CODE = 8207
    MSPV = 2
    """Set the output mode override for a specific hardware timer."""
    @dataclass
    class Request:
        timerIndex: int = 0
        outputMode: int = 0

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.timerIndex
            out += _pack_scalar('uint8_t', 'timerIndex', _v)
            _v = self.outputMode
            out += _pack_scalar('uint8_t', 'outputMode', _v)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Request', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _val, _data = _unpack_scalar('uint8_t', 'timerIndex', _data)
            _kwargs['timerIndex'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'outputMode', _data)
            _kwargs['outputMode'] = _val
            return cls(**_kwargs), _data


class Msp2InavMixer:
    CODE = 8208
    MSPV = 2
    """Retrieves INAV-specific mixer configuration details."""
    @dataclass
    class Reply:
        motorDirectionInverted: int = 0
        reserved1: int = 0
        motorStopOnLow: int = 0
        platformType: int = 0
        hasFlaps: int = 0
        appliedMixerPreset: int = 0
        maxMotors: int = 0
        maxServos: int = 0

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.motorDirectionInverted
            out += _pack_scalar('uint8_t', 'motorDirectionInverted', _v)
            _v = self.reserved1
            out += _pack_scalar('uint8_t', 'reserved1', _v)
            _v = self.motorStopOnLow
            out += _pack_scalar('uint8_t', 'motorStopOnLow', _v)
            _v = self.platformType
            out += _pack_scalar('uint8_t', 'platformType', _v)
            _v = self.hasFlaps
            out += _pack_scalar('uint8_t', 'hasFlaps', _v)
            _v = self.appliedMixerPreset
            out += _pack_scalar('int16_t', 'appliedMixerPreset', _v)
            _v = self.maxMotors
            out += _pack_scalar('uint8_t', 'maxMotors', _v)
            _v = self.maxServos
            out += _pack_scalar('uint8_t', 'maxServos', _v)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Reply', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _val, _data = _unpack_scalar('uint8_t', 'motorDirectionInverted', _data)
            _kwargs['motorDirectionInverted'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'reserved1', _data)
            _kwargs['reserved1'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'motorStopOnLow', _data)
            _kwargs['motorStopOnLow'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'platformType', _data)
            _kwargs['platformType'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'hasFlaps', _data)
            _kwargs['hasFlaps'] = _val
            _val, _data = _unpack_scalar('int16_t', 'appliedMixerPreset', _data)
            _kwargs['appliedMixerPreset'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'maxMotors', _data)
            _kwargs['maxMotors'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'maxServos', _data)
            _kwargs['maxServos'] = _val
            return cls(**_kwargs), _data


class Msp2InavSetMixer:
    CODE = 8209
    MSPV = 2
    """Sets INAV-specific mixer configuration details."""
    @dataclass
    class Request:
        motorDirectionInverted: int = 0
        reserved1: int = 0
        motorStopOnLow: int = 0
        platformType: int = 0
        hasFlaps: int = 0
        appliedMixerPreset: int = 0
        maxMotors: int = 0
        maxServos: int = 0

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.motorDirectionInverted
            out += _pack_scalar('uint8_t', 'motorDirectionInverted', _v)
            _v = self.reserved1
            out += _pack_scalar('uint8_t', 'reserved1', _v)
            _v = self.motorStopOnLow
            out += _pack_scalar('uint8_t', 'motorStopOnLow', _v)
            _v = self.platformType
            out += _pack_scalar('uint8_t', 'platformType', _v)
            _v = self.hasFlaps
            out += _pack_scalar('uint8_t', 'hasFlaps', _v)
            _v = self.appliedMixerPreset
            out += _pack_scalar('int16_t', 'appliedMixerPreset', _v)
            _v = self.maxMotors
            out += _pack_scalar('uint8_t', 'maxMotors', _v)
            _v = self.maxServos
            out += _pack_scalar('uint8_t', 'maxServos', _v)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Request', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _val, _data = _unpack_scalar('uint8_t', 'motorDirectionInverted', _data)
            _kwargs['motorDirectionInverted'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'reserved1', _data)
            _kwargs['reserved1'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'motorStopOnLow', _data)
            _kwargs['motorStopOnLow'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'platformType', _data)
            _kwargs['platformType'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'hasFlaps', _data)
            _kwargs['hasFlaps'] = _val
            _val, _data = _unpack_scalar('int16_t', 'appliedMixerPreset', _data)
            _kwargs['appliedMixerPreset'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'maxMotors', _data)
            _kwargs['maxMotors'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'maxServos', _data)
            _kwargs['maxServos'] = _val
            return cls(**_kwargs), _data


class Msp2InavOsdLayouts:
    CODE = 8210
    MSPV = 2
    """Retrieves OSD layout metadata or item positions for specific layouts/items."""
    pass

class Msp2InavOsdSetLayoutItem:
    CODE = 8211
    MSPV = 2
    """Sets the position of a single OSD item within a specific layout."""
    @dataclass
    class Request:
        layoutIndex: int = 0
        itemIndex: int = 0
        itemPosition: int = 0

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.layoutIndex
            out += _pack_scalar('uint8_t', 'layoutIndex', _v)
            _v = self.itemIndex
            out += _pack_scalar('uint8_t', 'itemIndex', _v)
            _v = self.itemPosition
            out += _pack_scalar('uint16_t', 'itemPosition', _v)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Request', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _val, _data = _unpack_scalar('uint8_t', 'layoutIndex', _data)
            _kwargs['layoutIndex'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'itemIndex', _data)
            _kwargs['itemIndex'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'itemPosition', _data)
            _kwargs['itemPosition'] = _val
            return cls(**_kwargs), _data


class Msp2InavOsdAlarms:
    CODE = 8212
    MSPV = 2
    """Retrieves OSD alarm threshold settings."""
    @dataclass
    class Reply:
        rssiAlarm: int = 0
        timerAlarm: int = 0
        altAlarm: int = 0
        distAlarm: int = 0
        negAltAlarm: int = 0
        gForceAlarm: int = 0
        gForceAxisMinAlarm: int = 0
        gForceAxisMaxAlarm: int = 0
        currentAlarm: int = 0
        imuTempMinAlarm: int = 0
        imuTempMaxAlarm: int = 0
        baroTempMinAlarm: int = 0
        baroTempMaxAlarm: int = 0
        adsbWarnDistance: int = 0
        adsbAlertDistance: int = 0

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.rssiAlarm
            out += _pack_scalar('uint8_t', 'rssiAlarm', _v)
            _v = self.timerAlarm
            out += _pack_scalar('uint16_t', 'timerAlarm', _v)
            _v = self.altAlarm
            out += _pack_scalar('uint16_t', 'altAlarm', _v)
            _v = self.distAlarm
            out += _pack_scalar('uint16_t', 'distAlarm', _v)
            _v = self.negAltAlarm
            out += _pack_scalar('uint16_t', 'negAltAlarm', _v)
            _v = self.gForceAlarm
            out += _pack_scalar('uint16_t', 'gForceAlarm', _v)
            _v = self.gForceAxisMinAlarm
            out += _pack_scalar('int16_t', 'gForceAxisMinAlarm', _v)
            _v = self.gForceAxisMaxAlarm
            out += _pack_scalar('int16_t', 'gForceAxisMaxAlarm', _v)
            _v = self.currentAlarm
            out += _pack_scalar('uint8_t', 'currentAlarm', _v)
            _v = self.imuTempMinAlarm
            out += _pack_scalar('int16_t', 'imuTempMinAlarm', _v)
            _v = self.imuTempMaxAlarm
            out += _pack_scalar('int16_t', 'imuTempMaxAlarm', _v)
            _v = self.baroTempMinAlarm
            out += _pack_scalar('int16_t', 'baroTempMinAlarm', _v)
            _v = self.baroTempMaxAlarm
            out += _pack_scalar('int16_t', 'baroTempMaxAlarm', _v)
            _v = self.adsbWarnDistance
            out += _pack_scalar('uint16_t', 'adsbWarnDistance', _v)
            _v = self.adsbAlertDistance
            out += _pack_scalar('uint16_t', 'adsbAlertDistance', _v)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Reply', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _val, _data = _unpack_scalar('uint8_t', 'rssiAlarm', _data)
            _kwargs['rssiAlarm'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'timerAlarm', _data)
            _kwargs['timerAlarm'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'altAlarm', _data)
            _kwargs['altAlarm'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'distAlarm', _data)
            _kwargs['distAlarm'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'negAltAlarm', _data)
            _kwargs['negAltAlarm'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'gForceAlarm', _data)
            _kwargs['gForceAlarm'] = _val
            _val, _data = _unpack_scalar('int16_t', 'gForceAxisMinAlarm', _data)
            _kwargs['gForceAxisMinAlarm'] = _val
            _val, _data = _unpack_scalar('int16_t', 'gForceAxisMaxAlarm', _data)
            _kwargs['gForceAxisMaxAlarm'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'currentAlarm', _data)
            _kwargs['currentAlarm'] = _val
            _val, _data = _unpack_scalar('int16_t', 'imuTempMinAlarm', _data)
            _kwargs['imuTempMinAlarm'] = _val
            _val, _data = _unpack_scalar('int16_t', 'imuTempMaxAlarm', _data)
            _kwargs['imuTempMaxAlarm'] = _val
            _val, _data = _unpack_scalar('int16_t', 'baroTempMinAlarm', _data)
            _kwargs['baroTempMinAlarm'] = _val
            _val, _data = _unpack_scalar('int16_t', 'baroTempMaxAlarm', _data)
            _kwargs['baroTempMaxAlarm'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'adsbWarnDistance', _data)
            _kwargs['adsbWarnDistance'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'adsbAlertDistance', _data)
            _kwargs['adsbAlertDistance'] = _val
            return cls(**_kwargs), _data


class Msp2InavOsdSetAlarms:
    CODE = 8213
    MSPV = 2
    """Sets OSD alarm threshold settings."""
    @dataclass
    class Request:
        rssiAlarm: int = 0
        timerAlarm: int = 0
        altAlarm: int = 0
        distAlarm: int = 0
        negAltAlarm: int = 0
        gForceAlarm: int = 0
        gForceAxisMinAlarm: int = 0
        gForceAxisMaxAlarm: int = 0
        currentAlarm: int = 0
        imuTempMinAlarm: int = 0
        imuTempMaxAlarm: int = 0
        baroTempMinAlarm: int = 0
        baroTempMaxAlarm: int = 0

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.rssiAlarm
            out += _pack_scalar('uint8_t', 'rssiAlarm', _v)
            _v = self.timerAlarm
            out += _pack_scalar('uint16_t', 'timerAlarm', _v)
            _v = self.altAlarm
            out += _pack_scalar('uint16_t', 'altAlarm', _v)
            _v = self.distAlarm
            out += _pack_scalar('uint16_t', 'distAlarm', _v)
            _v = self.negAltAlarm
            out += _pack_scalar('uint16_t', 'negAltAlarm', _v)
            _v = self.gForceAlarm
            out += _pack_scalar('uint16_t', 'gForceAlarm', _v)
            _v = self.gForceAxisMinAlarm
            out += _pack_scalar('int16_t', 'gForceAxisMinAlarm', _v)
            _v = self.gForceAxisMaxAlarm
            out += _pack_scalar('int16_t', 'gForceAxisMaxAlarm', _v)
            _v = self.currentAlarm
            out += _pack_scalar('uint8_t', 'currentAlarm', _v)
            _v = self.imuTempMinAlarm
            out += _pack_scalar('int16_t', 'imuTempMinAlarm', _v)
            _v = self.imuTempMaxAlarm
            out += _pack_scalar('int16_t', 'imuTempMaxAlarm', _v)
            _v = self.baroTempMinAlarm
            out += _pack_scalar('int16_t', 'baroTempMinAlarm', _v)
            _v = self.baroTempMaxAlarm
            out += _pack_scalar('int16_t', 'baroTempMaxAlarm', _v)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Request', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _val, _data = _unpack_scalar('uint8_t', 'rssiAlarm', _data)
            _kwargs['rssiAlarm'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'timerAlarm', _data)
            _kwargs['timerAlarm'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'altAlarm', _data)
            _kwargs['altAlarm'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'distAlarm', _data)
            _kwargs['distAlarm'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'negAltAlarm', _data)
            _kwargs['negAltAlarm'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'gForceAlarm', _data)
            _kwargs['gForceAlarm'] = _val
            _val, _data = _unpack_scalar('int16_t', 'gForceAxisMinAlarm', _data)
            _kwargs['gForceAxisMinAlarm'] = _val
            _val, _data = _unpack_scalar('int16_t', 'gForceAxisMaxAlarm', _data)
            _kwargs['gForceAxisMaxAlarm'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'currentAlarm', _data)
            _kwargs['currentAlarm'] = _val
            _val, _data = _unpack_scalar('int16_t', 'imuTempMinAlarm', _data)
            _kwargs['imuTempMinAlarm'] = _val
            _val, _data = _unpack_scalar('int16_t', 'imuTempMaxAlarm', _data)
            _kwargs['imuTempMaxAlarm'] = _val
            _val, _data = _unpack_scalar('int16_t', 'baroTempMinAlarm', _data)
            _kwargs['baroTempMinAlarm'] = _val
            _val, _data = _unpack_scalar('int16_t', 'baroTempMaxAlarm', _data)
            _kwargs['baroTempMaxAlarm'] = _val
            return cls(**_kwargs), _data


class Msp2InavOsdPreferences:
    CODE = 8214
    MSPV = 2
    """Retrieves OSD display preferences (video system, units, styles, etc.)."""
    @dataclass
    class Reply:
        videoSystem: int = 0
        mainVoltageDecimals: int = 0
        ahiReverseRoll: int = 0
        crosshairsStyle: int = 0
        leftSidebarScroll: int = 0
        rightSidebarScroll: int = 0
        sidebarScrollArrows: int = 0
        units: int = 0
        statsEnergyUnit: int = 0

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.videoSystem
            out += _pack_scalar('uint8_t', 'videoSystem', _v)
            _v = self.mainVoltageDecimals
            out += _pack_scalar('uint8_t', 'mainVoltageDecimals', _v)
            _v = self.ahiReverseRoll
            out += _pack_scalar('uint8_t', 'ahiReverseRoll', _v)
            _v = self.crosshairsStyle
            out += _pack_scalar('uint8_t', 'crosshairsStyle', _v)
            _v = self.leftSidebarScroll
            out += _pack_scalar('uint8_t', 'leftSidebarScroll', _v)
            _v = self.rightSidebarScroll
            out += _pack_scalar('uint8_t', 'rightSidebarScroll', _v)
            _v = self.sidebarScrollArrows
            out += _pack_scalar('uint8_t', 'sidebarScrollArrows', _v)
            _v = self.units
            out += _pack_scalar('uint8_t', 'units', _v)
            _v = self.statsEnergyUnit
            out += _pack_scalar('uint8_t', 'statsEnergyUnit', _v)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Reply', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _val, _data = _unpack_scalar('uint8_t', 'videoSystem', _data)
            _kwargs['videoSystem'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'mainVoltageDecimals', _data)
            _kwargs['mainVoltageDecimals'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'ahiReverseRoll', _data)
            _kwargs['ahiReverseRoll'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'crosshairsStyle', _data)
            _kwargs['crosshairsStyle'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'leftSidebarScroll', _data)
            _kwargs['leftSidebarScroll'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'rightSidebarScroll', _data)
            _kwargs['rightSidebarScroll'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'sidebarScrollArrows', _data)
            _kwargs['sidebarScrollArrows'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'units', _data)
            _kwargs['units'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'statsEnergyUnit', _data)
            _kwargs['statsEnergyUnit'] = _val
            return cls(**_kwargs), _data


class Msp2InavOsdSetPreferences:
    CODE = 8215
    MSPV = 2
    """Sets OSD display preferences."""
    @dataclass
    class Request:
        videoSystem: int = 0
        mainVoltageDecimals: int = 0
        ahiReverseRoll: int = 0
        crosshairsStyle: int = 0
        leftSidebarScroll: int = 0
        rightSidebarScroll: int = 0
        sidebarScrollArrows: int = 0
        units: int = 0
        statsEnergyUnit: int = 0

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.videoSystem
            out += _pack_scalar('uint8_t', 'videoSystem', _v)
            _v = self.mainVoltageDecimals
            out += _pack_scalar('uint8_t', 'mainVoltageDecimals', _v)
            _v = self.ahiReverseRoll
            out += _pack_scalar('uint8_t', 'ahiReverseRoll', _v)
            _v = self.crosshairsStyle
            out += _pack_scalar('uint8_t', 'crosshairsStyle', _v)
            _v = self.leftSidebarScroll
            out += _pack_scalar('uint8_t', 'leftSidebarScroll', _v)
            _v = self.rightSidebarScroll
            out += _pack_scalar('uint8_t', 'rightSidebarScroll', _v)
            _v = self.sidebarScrollArrows
            out += _pack_scalar('uint8_t', 'sidebarScrollArrows', _v)
            _v = self.units
            out += _pack_scalar('uint8_t', 'units', _v)
            _v = self.statsEnergyUnit
            out += _pack_scalar('uint8_t', 'statsEnergyUnit', _v)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Request', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _val, _data = _unpack_scalar('uint8_t', 'videoSystem', _data)
            _kwargs['videoSystem'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'mainVoltageDecimals', _data)
            _kwargs['mainVoltageDecimals'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'ahiReverseRoll', _data)
            _kwargs['ahiReverseRoll'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'crosshairsStyle', _data)
            _kwargs['crosshairsStyle'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'leftSidebarScroll', _data)
            _kwargs['leftSidebarScroll'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'rightSidebarScroll', _data)
            _kwargs['rightSidebarScroll'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'sidebarScrollArrows', _data)
            _kwargs['sidebarScrollArrows'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'units', _data)
            _kwargs['units'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'statsEnergyUnit', _data)
            _kwargs['statsEnergyUnit'] = _val
            return cls(**_kwargs), _data


class Msp2InavSelectBatteryProfile:
    CODE = 8216
    MSPV = 2
    """Selects the active battery profile and saves configuration."""
    @dataclass
    class Request:
        batteryProfileIndex: int = 0

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.batteryProfileIndex
            out += _pack_scalar('uint8_t', 'batteryProfileIndex', _v)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Request', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _val, _data = _unpack_scalar('uint8_t', 'batteryProfileIndex', _data)
            _kwargs['batteryProfileIndex'] = _val
            return cls(**_kwargs), _data


class Msp2InavDebug:
    CODE = 8217
    MSPV = 2
    """Retrieves values from the firmware's 32-bit `debug[]` array. Supersedes `MSP_DEBUG`."""
    @dataclass
    class Reply:
        debugValues: List[int] = field(default_factory=list)

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.debugValues
            if not isinstance(_v, list):
                raise TypeError('debugValues must be list')
            if len(_v) != 8:
                raise ValueError('debugValues must have exactly 8 elements')
            for i, _e in enumerate(_v):
                out += _pack_scalar('int32_t', 'debugValues[{}]'.format(i), _e)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Reply', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            if len(_data) < 32:
                raise ValueError('not enough data to unpack debugValues')
            _tmp_v = []
            _tmp = _data[:32]
            for _i in range(8):
                _val, _tmp = _unpack_scalar('int32_t', 'debugValues[{}]'.format(_i), _tmp)
                _tmp_v.append(_val)
            _kwargs['debugValues'] = _tmp_v
            _data = _data[32:]
            return cls(**_kwargs), _data


class Msp2BlackboxConfig:
    CODE = 8218
    MSPV = 2
    """Retrieves the Blackbox configuration. Supersedes `MSP_BLACKBOX_CONFIG`."""
    @dataclass
    class Reply:
        blackboxSupported: int = 0
        blackboxDevice: int = 0
        blackboxRateNum: int = 0
        blackboxRateDenom: int = 0
        blackboxIncludeFlags: int = 0

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.blackboxSupported
            out += _pack_scalar('uint8_t', 'blackboxSupported', _v)
            _v = self.blackboxDevice
            out += _pack_scalar('uint8_t', 'blackboxDevice', _v)
            _v = self.blackboxRateNum
            out += _pack_scalar('uint16_t', 'blackboxRateNum', _v)
            _v = self.blackboxRateDenom
            out += _pack_scalar('uint16_t', 'blackboxRateDenom', _v)
            _v = self.blackboxIncludeFlags
            out += _pack_scalar('uint32_t', 'blackboxIncludeFlags', _v)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Reply', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _val, _data = _unpack_scalar('uint8_t', 'blackboxSupported', _data)
            _kwargs['blackboxSupported'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'blackboxDevice', _data)
            _kwargs['blackboxDevice'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'blackboxRateNum', _data)
            _kwargs['blackboxRateNum'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'blackboxRateDenom', _data)
            _kwargs['blackboxRateDenom'] = _val
            _val, _data = _unpack_scalar('uint32_t', 'blackboxIncludeFlags', _data)
            _kwargs['blackboxIncludeFlags'] = _val
            return cls(**_kwargs), _data


class Msp2SetBlackboxConfig:
    CODE = 8219
    MSPV = 2
    """Sets the Blackbox configuration. Supersedes `MSP_SET_BLACKBOX_CONFIG`."""
    @dataclass
    class Request:
        blackboxDevice: int = 0
        blackboxRateNum: int = 0
        blackboxRateDenom: int = 0
        blackboxIncludeFlags: int = 0

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.blackboxDevice
            out += _pack_scalar('uint8_t', 'blackboxDevice', _v)
            _v = self.blackboxRateNum
            out += _pack_scalar('uint16_t', 'blackboxRateNum', _v)
            _v = self.blackboxRateDenom
            out += _pack_scalar('uint16_t', 'blackboxRateDenom', _v)
            _v = self.blackboxIncludeFlags
            out += _pack_scalar('uint32_t', 'blackboxIncludeFlags', _v)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Request', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _val, _data = _unpack_scalar('uint8_t', 'blackboxDevice', _data)
            _kwargs['blackboxDevice'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'blackboxRateNum', _data)
            _kwargs['blackboxRateNum'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'blackboxRateDenom', _data)
            _kwargs['blackboxRateDenom'] = _val
            _val, _data = _unpack_scalar('uint32_t', 'blackboxIncludeFlags', _data)
            _kwargs['blackboxIncludeFlags'] = _val
            return cls(**_kwargs), _data


class Msp2InavTempSensorConfig:
    CODE = 8220
    MSPV = 2
    """Retrieves the configuration for all onboard temperature sensors."""
    @dataclass
    class Reply:
        type: int = 0
        address: int = 0
        alarmMin: int = 0
        alarmMax: int = 0
        osdSymbol: int = 0
        label: str = ''

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.type
            out += _pack_scalar('uint8_t', 'type', _v)
            _v = self.address
            out += _pack_scalar('uint64_t', 'address', _v)
            _v = self.alarmMin
            out += _pack_scalar('int16_t', 'alarmMin', _v)
            _v = self.alarmMax
            out += _pack_scalar('int16_t', 'alarmMax', _v)
            _v = self.osdSymbol
            out += _pack_scalar('uint8_t', 'osdSymbol', _v)
            _v = self.label
            if not isinstance(_v, str):
                raise TypeError('label must be str')
            _b = _v.encode('ascii', errors='ignore')
            if len(_b) > 4:
                raise ValueError('label length {} > 4'.format(len(_b)))
            out += _b.ljust(4, b'\x00')
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Reply', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _val, _data = _unpack_scalar('uint8_t', 'type', _data)
            _kwargs['type'] = _val
            _val, _data = _unpack_scalar('uint64_t', 'address', _data)
            _kwargs['address'] = _val
            _val, _data = _unpack_scalar('int16_t', 'alarmMin', _data)
            _kwargs['alarmMin'] = _val
            _val, _data = _unpack_scalar('int16_t', 'alarmMax', _data)
            _kwargs['alarmMax'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'osdSymbol', _data)
            _kwargs['osdSymbol'] = _val
            if len(_data) < 4:
                raise ValueError('not enough data to unpack label')
            _raw = _data[:4]
            _kwargs['label'] = _raw.split(b'\x00', 1)[0].decode('ascii', errors='ignore')
            _data = _data[4:]
            return cls(**_kwargs), _data


class Msp2InavSetTempSensorConfig:
    CODE = 8221
    MSPV = 2
    """Sets the configuration for all onboard temperature sensors."""
    @dataclass
    class Request:
        type: int = 0
        address: int = 0
        alarmMin: int = 0
        alarmMax: int = 0
        osdSymbol: int = 0
        label: str = ''

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.type
            out += _pack_scalar('uint8_t', 'type', _v)
            _v = self.address
            out += _pack_scalar('uint64_t', 'address', _v)
            _v = self.alarmMin
            out += _pack_scalar('int16_t', 'alarmMin', _v)
            _v = self.alarmMax
            out += _pack_scalar('int16_t', 'alarmMax', _v)
            _v = self.osdSymbol
            out += _pack_scalar('uint8_t', 'osdSymbol', _v)
            _v = self.label
            if not isinstance(_v, str):
                raise TypeError('label must be str')
            _b = _v.encode('ascii', errors='ignore')
            if len(_b) > 4:
                raise ValueError('label length {} > 4'.format(len(_b)))
            out += _b.ljust(4, b'\x00')
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Request', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _val, _data = _unpack_scalar('uint8_t', 'type', _data)
            _kwargs['type'] = _val
            _val, _data = _unpack_scalar('uint64_t', 'address', _data)
            _kwargs['address'] = _val
            _val, _data = _unpack_scalar('int16_t', 'alarmMin', _data)
            _kwargs['alarmMin'] = _val
            _val, _data = _unpack_scalar('int16_t', 'alarmMax', _data)
            _kwargs['alarmMax'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'osdSymbol', _data)
            _kwargs['osdSymbol'] = _val
            if len(_data) < 4:
                raise ValueError('not enough data to unpack label')
            _raw = _data[:4]
            _kwargs['label'] = _raw.split(b'\x00', 1)[0].decode('ascii', errors='ignore')
            _data = _data[4:]
            return cls(**_kwargs), _data


class Msp2InavTemperatures:
    CODE = 8222
    MSPV = 2
    """Retrieves the current readings from all configured temperature sensors."""
    @dataclass
    class Reply:
        temperature: int = 0

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.temperature
            out += _pack_scalar('int16_t', 'temperature', _v)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Reply', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _val, _data = _unpack_scalar('int16_t', 'temperature', _data)
            _kwargs['temperature'] = _val
            return cls(**_kwargs), _data


class MspSimulator:
    CODE = 8223
    MSPV = 2
    """Handles Hardware-in-the-Loop (HITL) simulation data exchange. Receives simulated sensor data and options, sends back control outputs and debug info."""
    @dataclass
    class Request:
        simulatorVersion: int = 0
        simulatorFlags_t: int = 0
        gpsFixType: int = 0
        gpsNumSat: int = 0
        gpsLat: int = 0
        gpsLon: int = 0
        gpsAlt: int = 0
        gpsSpeed: int = 0
        gpsCourse: int = 0
        gpsVelN: int = 0
        gpsVelE: int = 0
        gpsVelD: int = 0
        imuRoll: int = 0
        imuPitch: int = 0
        imuYaw: int = 0
        accX: int = 0
        accY: int = 0
        accZ: int = 0
        gyroX: int = 0
        gyroY: int = 0
        gyroZ: int = 0
        baroPressure: int = 0
        magX: int = 0
        magY: int = 0
        magZ: int = 0
        vbat: int = 0
        airspeed: int = 0
        extFlags: int = 0

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.simulatorVersion
            out += _pack_scalar('uint8_t', 'simulatorVersion', _v)
            _v = self.simulatorFlags_t
            out += _pack_scalar('uint8_t', 'simulatorFlags_t', _v)
            _v = self.gpsFixType
            out += _pack_scalar('uint8_t', 'gpsFixType', _v)
            _v = self.gpsNumSat
            out += _pack_scalar('uint8_t', 'gpsNumSat', _v)
            _v = self.gpsLat
            out += _pack_scalar('int32_t', 'gpsLat', _v)
            _v = self.gpsLon
            out += _pack_scalar('int32_t', 'gpsLon', _v)
            _v = self.gpsAlt
            out += _pack_scalar('int32_t', 'gpsAlt', _v)
            _v = self.gpsSpeed
            out += _pack_scalar('uint16_t', 'gpsSpeed', _v)
            _v = self.gpsCourse
            out += _pack_scalar('uint16_t', 'gpsCourse', _v)
            _v = self.gpsVelN
            out += _pack_scalar('int16_t', 'gpsVelN', _v)
            _v = self.gpsVelE
            out += _pack_scalar('int16_t', 'gpsVelE', _v)
            _v = self.gpsVelD
            out += _pack_scalar('int16_t', 'gpsVelD', _v)
            _v = self.imuRoll
            out += _pack_scalar('int16_t', 'imuRoll', _v)
            _v = self.imuPitch
            out += _pack_scalar('int16_t', 'imuPitch', _v)
            _v = self.imuYaw
            out += _pack_scalar('int16_t', 'imuYaw', _v)
            _v = self.accX
            out += _pack_scalar('int16_t', 'accX', _v)
            _v = self.accY
            out += _pack_scalar('int16_t', 'accY', _v)
            _v = self.accZ
            out += _pack_scalar('int16_t', 'accZ', _v)
            _v = self.gyroX
            out += _pack_scalar('int16_t', 'gyroX', _v)
            _v = self.gyroY
            out += _pack_scalar('int16_t', 'gyroY', _v)
            _v = self.gyroZ
            out += _pack_scalar('int16_t', 'gyroZ', _v)
            _v = self.baroPressure
            out += _pack_scalar('uint32_t', 'baroPressure', _v)
            _v = self.magX
            out += _pack_scalar('int16_t', 'magX', _v)
            _v = self.magY
            out += _pack_scalar('int16_t', 'magY', _v)
            _v = self.magZ
            out += _pack_scalar('int16_t', 'magZ', _v)
            _v = self.vbat
            out += _pack_scalar('uint8_t', 'vbat', _v)
            _v = self.airspeed
            out += _pack_scalar('uint16_t', 'airspeed', _v)
            _v = self.extFlags
            out += _pack_scalar('uint8_t', 'extFlags', _v)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Request', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _val, _data = _unpack_scalar('uint8_t', 'simulatorVersion', _data)
            _kwargs['simulatorVersion'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'simulatorFlags_t', _data)
            _kwargs['simulatorFlags_t'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'gpsFixType', _data)
            _kwargs['gpsFixType'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'gpsNumSat', _data)
            _kwargs['gpsNumSat'] = _val
            _val, _data = _unpack_scalar('int32_t', 'gpsLat', _data)
            _kwargs['gpsLat'] = _val
            _val, _data = _unpack_scalar('int32_t', 'gpsLon', _data)
            _kwargs['gpsLon'] = _val
            _val, _data = _unpack_scalar('int32_t', 'gpsAlt', _data)
            _kwargs['gpsAlt'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'gpsSpeed', _data)
            _kwargs['gpsSpeed'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'gpsCourse', _data)
            _kwargs['gpsCourse'] = _val
            _val, _data = _unpack_scalar('int16_t', 'gpsVelN', _data)
            _kwargs['gpsVelN'] = _val
            _val, _data = _unpack_scalar('int16_t', 'gpsVelE', _data)
            _kwargs['gpsVelE'] = _val
            _val, _data = _unpack_scalar('int16_t', 'gpsVelD', _data)
            _kwargs['gpsVelD'] = _val
            _val, _data = _unpack_scalar('int16_t', 'imuRoll', _data)
            _kwargs['imuRoll'] = _val
            _val, _data = _unpack_scalar('int16_t', 'imuPitch', _data)
            _kwargs['imuPitch'] = _val
            _val, _data = _unpack_scalar('int16_t', 'imuYaw', _data)
            _kwargs['imuYaw'] = _val
            _val, _data = _unpack_scalar('int16_t', 'accX', _data)
            _kwargs['accX'] = _val
            _val, _data = _unpack_scalar('int16_t', 'accY', _data)
            _kwargs['accY'] = _val
            _val, _data = _unpack_scalar('int16_t', 'accZ', _data)
            _kwargs['accZ'] = _val
            _val, _data = _unpack_scalar('int16_t', 'gyroX', _data)
            _kwargs['gyroX'] = _val
            _val, _data = _unpack_scalar('int16_t', 'gyroY', _data)
            _kwargs['gyroY'] = _val
            _val, _data = _unpack_scalar('int16_t', 'gyroZ', _data)
            _kwargs['gyroZ'] = _val
            _val, _data = _unpack_scalar('uint32_t', 'baroPressure', _data)
            _kwargs['baroPressure'] = _val
            _val, _data = _unpack_scalar('int16_t', 'magX', _data)
            _kwargs['magX'] = _val
            _val, _data = _unpack_scalar('int16_t', 'magY', _data)
            _kwargs['magY'] = _val
            _val, _data = _unpack_scalar('int16_t', 'magZ', _data)
            _kwargs['magZ'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'vbat', _data)
            _kwargs['vbat'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'airspeed', _data)
            _kwargs['airspeed'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'extFlags', _data)
            _kwargs['extFlags'] = _val
            return cls(**_kwargs), _data

    @dataclass
    class Reply:
        stabilizedRoll: int = 0
        stabilizedPitch: int = 0
        stabilizedYaw: int = 0
        stabilizedThrottle: int = 0
        debugFlags: int = 0
        debugValue: int = 0
        attitudeRoll: int = 0
        attitudePitch: int = 0
        attitudeYaw: int = 0
        osdHeader: Optional[int] = None
        osdRows: Optional[int] = None
        osdCols: Optional[int] = None
        osdStartY: Optional[int] = None
        osdStartX: Optional[int] = None
        osdRleData: Optional[List[int]] = None

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.stabilizedRoll
            out += _pack_scalar('uint16_t', 'stabilizedRoll', _v)
            _v = self.stabilizedPitch
            out += _pack_scalar('uint16_t', 'stabilizedPitch', _v)
            _v = self.stabilizedYaw
            out += _pack_scalar('uint16_t', 'stabilizedYaw', _v)
            _v = self.stabilizedThrottle
            out += _pack_scalar('uint16_t', 'stabilizedThrottle', _v)
            _v = self.debugFlags
            out += _pack_scalar('uint8_t', 'debugFlags', _v)
            _v = self.debugValue
            out += _pack_scalar('uint32_t', 'debugValue', _v)
            _v = self.attitudeRoll
            out += _pack_scalar('int16_t', 'attitudeRoll', _v)
            _v = self.attitudePitch
            out += _pack_scalar('int16_t', 'attitudePitch', _v)
            _v = self.attitudeYaw
            out += _pack_scalar('int16_t', 'attitudeYaw', _v)
            if self.osdHeader is None:
                pass
            else:
                _v = self.osdHeader
                out += _pack_scalar('uint8_t', 'osdHeader', _v)
            if self.osdRows is None:
                pass
            else:
                _v = self.osdRows
                out += _pack_scalar('uint8_t', 'osdRows', _v)
            if self.osdCols is None:
                pass
            else:
                _v = self.osdCols
                out += _pack_scalar('uint8_t', 'osdCols', _v)
            if self.osdStartY is None:
                pass
            else:
                _v = self.osdStartY
                out += _pack_scalar('uint8_t', 'osdStartY', _v)
            if self.osdStartX is None:
                pass
            else:
                _v = self.osdStartX
                out += _pack_scalar('uint8_t', 'osdStartX', _v)
            if self.osdRleData is None:
                pass
            else:
                _v = self.osdRleData
                if not isinstance(_v, list):
                    raise TypeError('osdRleData must be list')
                for i, _e in enumerate(_v):
                    out += _pack_scalar('uint8_t', 'osdRleData[{}]'.format(i), _e)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Reply', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _val, _data = _unpack_scalar('uint16_t', 'stabilizedRoll', _data)
            _kwargs['stabilizedRoll'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'stabilizedPitch', _data)
            _kwargs['stabilizedPitch'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'stabilizedYaw', _data)
            _kwargs['stabilizedYaw'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'stabilizedThrottle', _data)
            _kwargs['stabilizedThrottle'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'debugFlags', _data)
            _kwargs['debugFlags'] = _val
            _val, _data = _unpack_scalar('uint32_t', 'debugValue', _data)
            _kwargs['debugValue'] = _val
            _val, _data = _unpack_scalar('int16_t', 'attitudeRoll', _data)
            _kwargs['attitudeRoll'] = _val
            _val, _data = _unpack_scalar('int16_t', 'attitudePitch', _data)
            _kwargs['attitudePitch'] = _val
            _val, _data = _unpack_scalar('int16_t', 'attitudeYaw', _data)
            _kwargs['attitudeYaw'] = _val
            if len(_data) == 0:
                _kwargs['osdHeader'] = None
            else:
                _val, _data = _unpack_scalar('uint8_t', 'osdHeader', _data)
                _kwargs['osdHeader'] = _val
            if len(_data) == 0:
                _kwargs['osdRows'] = None
            else:
                _val, _data = _unpack_scalar('uint8_t', 'osdRows', _data)
                _kwargs['osdRows'] = _val
            if len(_data) == 0:
                _kwargs['osdCols'] = None
            else:
                _val, _data = _unpack_scalar('uint8_t', 'osdCols', _data)
                _kwargs['osdCols'] = _val
            if len(_data) == 0:
                _kwargs['osdStartY'] = None
            else:
                _val, _data = _unpack_scalar('uint8_t', 'osdStartY', _data)
                _kwargs['osdStartY'] = _val
            if len(_data) == 0:
                _kwargs['osdStartX'] = None
            else:
                _val, _data = _unpack_scalar('uint8_t', 'osdStartX', _data)
                _kwargs['osdStartX'] = _val
            if len(_data) == 0:
                _kwargs['osdRleData'] = None
            else:
                _alen = hints.get('osdRleData_len')
                if _alen is None:
                    raise ValueError('missing hint: osdRleData_len for variable length array')
                elem_size = 1
                total = int(_alen) * elem_size
                if len(_data) < total:
                    raise ValueError('not enough data to unpack osdRleData')
                _tmp_v = []
                _tmp = _data[:total]
                for _i in range(int(_alen)):
                    _val, _tmp = _unpack_scalar('uint8_t', 'osdRleData[{}]'.format(_i), _tmp)
                    _tmp_v.append(_val)
                _kwargs['osdRleData'] = _tmp_v
                _data = _data[total:]
            return cls(**_kwargs), _data


class Msp2InavServoMixer:
    CODE = 8224
    MSPV = 2
    """Retrieves the custom servo mixer rules, including programming framework condition IDs, for primary and secondary mixer profiles. Supersedes `MSP_SERVO_MIX_RULES`."""
    @dataclass
    class Reply:
        targetChannel: int = 0
        inputSource: int = 0
        rate: int = 0
        speed: int = 0
        conditionId: int = 0
        p2TargetChannel: Optional[int] = None
        p2InputSource: Optional[int] = None
        p2Rate: Optional[int] = None
        p2Speed: Optional[int] = None
        p2ConditionId: Optional[int] = None

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.targetChannel
            out += _pack_scalar('uint8_t', 'targetChannel', _v)
            _v = self.inputSource
            out += _pack_scalar('uint8_t', 'inputSource', _v)
            _v = self.rate
            out += _pack_scalar('int16_t', 'rate', _v)
            _v = self.speed
            out += _pack_scalar('uint8_t', 'speed', _v)
            _v = self.conditionId
            out += _pack_scalar('int8_t', 'conditionId', _v)
            if self.p2TargetChannel is None:
                pass
            else:
                _v = self.p2TargetChannel
                out += _pack_scalar('uint8_t', 'p2TargetChannel', _v)
            if self.p2InputSource is None:
                pass
            else:
                _v = self.p2InputSource
                out += _pack_scalar('uint8_t', 'p2InputSource', _v)
            if self.p2Rate is None:
                pass
            else:
                _v = self.p2Rate
                out += _pack_scalar('int16_t', 'p2Rate', _v)
            if self.p2Speed is None:
                pass
            else:
                _v = self.p2Speed
                out += _pack_scalar('uint8_t', 'p2Speed', _v)
            if self.p2ConditionId is None:
                pass
            else:
                _v = self.p2ConditionId
                out += _pack_scalar('int8_t', 'p2ConditionId', _v)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Reply', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _val, _data = _unpack_scalar('uint8_t', 'targetChannel', _data)
            _kwargs['targetChannel'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'inputSource', _data)
            _kwargs['inputSource'] = _val
            _val, _data = _unpack_scalar('int16_t', 'rate', _data)
            _kwargs['rate'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'speed', _data)
            _kwargs['speed'] = _val
            _val, _data = _unpack_scalar('int8_t', 'conditionId', _data)
            _kwargs['conditionId'] = _val
            if len(_data) == 0:
                _kwargs['p2TargetChannel'] = None
            else:
                _val, _data = _unpack_scalar('uint8_t', 'p2TargetChannel', _data)
                _kwargs['p2TargetChannel'] = _val
            if len(_data) == 0:
                _kwargs['p2InputSource'] = None
            else:
                _val, _data = _unpack_scalar('uint8_t', 'p2InputSource', _data)
                _kwargs['p2InputSource'] = _val
            if len(_data) == 0:
                _kwargs['p2Rate'] = None
            else:
                _val, _data = _unpack_scalar('int16_t', 'p2Rate', _data)
                _kwargs['p2Rate'] = _val
            if len(_data) == 0:
                _kwargs['p2Speed'] = None
            else:
                _val, _data = _unpack_scalar('uint8_t', 'p2Speed', _data)
                _kwargs['p2Speed'] = _val
            if len(_data) == 0:
                _kwargs['p2ConditionId'] = None
            else:
                _val, _data = _unpack_scalar('int8_t', 'p2ConditionId', _data)
                _kwargs['p2ConditionId'] = _val
            return cls(**_kwargs), _data


class Msp2InavSetServoMixer:
    CODE = 8225
    MSPV = 2
    """Sets a single custom servo mixer rule, including programming framework condition ID. Supersedes `MSP_SET_SERVO_MIX_RULE`."""
    @dataclass
    class Request:
        ruleIndex: int = 0
        targetChannel: int = 0
        inputSource: int = 0
        rate: int = 0
        speed: int = 0
        conditionId: int = 0

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.ruleIndex
            out += _pack_scalar('uint8_t', 'ruleIndex', _v)
            _v = self.targetChannel
            out += _pack_scalar('uint8_t', 'targetChannel', _v)
            _v = self.inputSource
            out += _pack_scalar('uint8_t', 'inputSource', _v)
            _v = self.rate
            out += _pack_scalar('int16_t', 'rate', _v)
            _v = self.speed
            out += _pack_scalar('uint8_t', 'speed', _v)
            _v = self.conditionId
            out += _pack_scalar('int8_t', 'conditionId', _v)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Request', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _val, _data = _unpack_scalar('uint8_t', 'ruleIndex', _data)
            _kwargs['ruleIndex'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'targetChannel', _data)
            _kwargs['targetChannel'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'inputSource', _data)
            _kwargs['inputSource'] = _val
            _val, _data = _unpack_scalar('int16_t', 'rate', _data)
            _kwargs['rate'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'speed', _data)
            _kwargs['speed'] = _val
            _val, _data = _unpack_scalar('int8_t', 'conditionId', _data)
            _kwargs['conditionId'] = _val
            return cls(**_kwargs), _data


class Msp2InavLogicConditions:
    CODE = 8226
    MSPV = 2
    """Retrieves the configuration of all defined Logic Conditions."""
    @dataclass
    class Reply:
        enabled: int = 0
        activatorId: int = 0
        operation: int = 0
        operandAType: int = 0
        operandAValue: int = 0
        operandBType: int = 0
        operandBValue: int = 0
        flags: int = 0

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.enabled
            out += _pack_scalar('uint8_t', 'enabled', _v)
            _v = self.activatorId
            out += _pack_scalar('int8_t', 'activatorId', _v)
            _v = self.operation
            out += _pack_scalar('uint8_t', 'operation', _v)
            _v = self.operandAType
            out += _pack_scalar('uint8_t', 'operandAType', _v)
            _v = self.operandAValue
            out += _pack_scalar('int32_t', 'operandAValue', _v)
            _v = self.operandBType
            out += _pack_scalar('uint8_t', 'operandBType', _v)
            _v = self.operandBValue
            out += _pack_scalar('int32_t', 'operandBValue', _v)
            _v = self.flags
            out += _pack_scalar('uint8_t', 'flags', _v)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Reply', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _val, _data = _unpack_scalar('uint8_t', 'enabled', _data)
            _kwargs['enabled'] = _val
            _val, _data = _unpack_scalar('int8_t', 'activatorId', _data)
            _kwargs['activatorId'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'operation', _data)
            _kwargs['operation'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'operandAType', _data)
            _kwargs['operandAType'] = _val
            _val, _data = _unpack_scalar('int32_t', 'operandAValue', _data)
            _kwargs['operandAValue'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'operandBType', _data)
            _kwargs['operandBType'] = _val
            _val, _data = _unpack_scalar('int32_t', 'operandBValue', _data)
            _kwargs['operandBValue'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'flags', _data)
            _kwargs['flags'] = _val
            return cls(**_kwargs), _data


class Msp2InavSetLogicConditions:
    CODE = 8227
    MSPV = 2
    """Sets the configuration for a single Logic Condition by its index."""
    @dataclass
    class Request:
        conditionIndex: int = 0
        enabled: int = 0
        activatorId: int = 0
        operation: int = 0
        operandAType: int = 0
        operandAValue: int = 0
        operandBType: int = 0
        operandBValue: int = 0
        flags: int = 0

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.conditionIndex
            out += _pack_scalar('uint8_t', 'conditionIndex', _v)
            _v = self.enabled
            out += _pack_scalar('uint8_t', 'enabled', _v)
            _v = self.activatorId
            out += _pack_scalar('int8_t', 'activatorId', _v)
            _v = self.operation
            out += _pack_scalar('uint8_t', 'operation', _v)
            _v = self.operandAType
            out += _pack_scalar('uint8_t', 'operandAType', _v)
            _v = self.operandAValue
            out += _pack_scalar('int32_t', 'operandAValue', _v)
            _v = self.operandBType
            out += _pack_scalar('uint8_t', 'operandBType', _v)
            _v = self.operandBValue
            out += _pack_scalar('int32_t', 'operandBValue', _v)
            _v = self.flags
            out += _pack_scalar('uint8_t', 'flags', _v)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Request', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _val, _data = _unpack_scalar('uint8_t', 'conditionIndex', _data)
            _kwargs['conditionIndex'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'enabled', _data)
            _kwargs['enabled'] = _val
            _val, _data = _unpack_scalar('int8_t', 'activatorId', _data)
            _kwargs['activatorId'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'operation', _data)
            _kwargs['operation'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'operandAType', _data)
            _kwargs['operandAType'] = _val
            _val, _data = _unpack_scalar('int32_t', 'operandAValue', _data)
            _kwargs['operandAValue'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'operandBType', _data)
            _kwargs['operandBType'] = _val
            _val, _data = _unpack_scalar('int32_t', 'operandBValue', _data)
            _kwargs['operandBValue'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'flags', _data)
            _kwargs['flags'] = _val
            return cls(**_kwargs), _data


class Msp2InavGlobalFunctions:
    CODE = 8228
    MSPV = 2
    """"""
    pass

class Msp2InavSetGlobalFunctions:
    CODE = 8229
    MSPV = 2
    """"""
    pass

class Msp2InavLogicConditionsStatus:
    CODE = 8230
    MSPV = 2
    """Retrieves the current evaluated status (true/false or numerical value) of all logic conditions."""
    @dataclass
    class Reply:
        conditionValues: List[int] = field(default_factory=list)

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.conditionValues
            if not isinstance(_v, list):
                raise TypeError('conditionValues must be list')
            if len(_v) != 64:
                raise ValueError('conditionValues must have exactly 64 elements')
            for i, _e in enumerate(_v):
                out += _pack_scalar('int32_t', 'conditionValues[{}]'.format(i), _e)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Reply', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            if len(_data) < 256:
                raise ValueError('not enough data to unpack conditionValues')
            _tmp_v = []
            _tmp = _data[:256]
            for _i in range(64):
                _val, _tmp = _unpack_scalar('int32_t', 'conditionValues[{}]'.format(_i), _tmp)
                _tmp_v.append(_val)
            _kwargs['conditionValues'] = _tmp_v
            _data = _data[256:]
            return cls(**_kwargs), _data


class Msp2InavGvarStatus:
    CODE = 8231
    MSPV = 2
    """Retrieves the current values of all Global Variables (GVARS)."""
    @dataclass
    class Reply:
        gvarValues: List[int] = field(default_factory=list)

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.gvarValues
            if not isinstance(_v, list):
                raise TypeError('gvarValues must be list')
            if len(_v) != 8:
                raise ValueError('gvarValues must have exactly 8 elements')
            for i, _e in enumerate(_v):
                out += _pack_scalar('int32_t', 'gvarValues[{}]'.format(i), _e)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Reply', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            if len(_data) < 32:
                raise ValueError('not enough data to unpack gvarValues')
            _tmp_v = []
            _tmp = _data[:32]
            for _i in range(8):
                _val, _tmp = _unpack_scalar('int32_t', 'gvarValues[{}]'.format(_i), _tmp)
                _tmp_v.append(_val)
            _kwargs['gvarValues'] = _tmp_v
            _data = _data[32:]
            return cls(**_kwargs), _data


class Msp2InavProgrammingPid:
    CODE = 8232
    MSPV = 2
    """Retrieves the configuration of all Programming PIDs."""
    @dataclass
    class Reply:
        enabled: int = 0
        setpointType: int = 0
        setpointValue: int = 0
        measurementType: int = 0
        measurementValue: int = 0
        gainP: int = 0
        gainI: int = 0
        gainD: int = 0
        gainFF: int = 0

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.enabled
            out += _pack_scalar('uint8_t', 'enabled', _v)
            _v = self.setpointType
            out += _pack_scalar('uint8_t', 'setpointType', _v)
            _v = self.setpointValue
            out += _pack_scalar('int32_t', 'setpointValue', _v)
            _v = self.measurementType
            out += _pack_scalar('uint8_t', 'measurementType', _v)
            _v = self.measurementValue
            out += _pack_scalar('int32_t', 'measurementValue', _v)
            _v = self.gainP
            out += _pack_scalar('uint16_t', 'gainP', _v)
            _v = self.gainI
            out += _pack_scalar('uint16_t', 'gainI', _v)
            _v = self.gainD
            out += _pack_scalar('uint16_t', 'gainD', _v)
            _v = self.gainFF
            out += _pack_scalar('uint16_t', 'gainFF', _v)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Reply', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _val, _data = _unpack_scalar('uint8_t', 'enabled', _data)
            _kwargs['enabled'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'setpointType', _data)
            _kwargs['setpointType'] = _val
            _val, _data = _unpack_scalar('int32_t', 'setpointValue', _data)
            _kwargs['setpointValue'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'measurementType', _data)
            _kwargs['measurementType'] = _val
            _val, _data = _unpack_scalar('int32_t', 'measurementValue', _data)
            _kwargs['measurementValue'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'gainP', _data)
            _kwargs['gainP'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'gainI', _data)
            _kwargs['gainI'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'gainD', _data)
            _kwargs['gainD'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'gainFF', _data)
            _kwargs['gainFF'] = _val
            return cls(**_kwargs), _data


class Msp2InavSetProgrammingPid:
    CODE = 8233
    MSPV = 2
    """Sets the configuration for a single Programming PID by its index."""
    @dataclass
    class Request:
        pidIndex: int = 0
        enabled: int = 0
        setpointType: int = 0
        setpointValue: int = 0
        measurementType: int = 0
        measurementValue: int = 0
        gainP: int = 0
        gainI: int = 0
        gainD: int = 0
        gainFF: int = 0

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.pidIndex
            out += _pack_scalar('uint8_t', 'pidIndex', _v)
            _v = self.enabled
            out += _pack_scalar('uint8_t', 'enabled', _v)
            _v = self.setpointType
            out += _pack_scalar('uint8_t', 'setpointType', _v)
            _v = self.setpointValue
            out += _pack_scalar('int32_t', 'setpointValue', _v)
            _v = self.measurementType
            out += _pack_scalar('uint8_t', 'measurementType', _v)
            _v = self.measurementValue
            out += _pack_scalar('int32_t', 'measurementValue', _v)
            _v = self.gainP
            out += _pack_scalar('uint16_t', 'gainP', _v)
            _v = self.gainI
            out += _pack_scalar('uint16_t', 'gainI', _v)
            _v = self.gainD
            out += _pack_scalar('uint16_t', 'gainD', _v)
            _v = self.gainFF
            out += _pack_scalar('uint16_t', 'gainFF', _v)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Request', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _val, _data = _unpack_scalar('uint8_t', 'pidIndex', _data)
            _kwargs['pidIndex'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'enabled', _data)
            _kwargs['enabled'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'setpointType', _data)
            _kwargs['setpointType'] = _val
            _val, _data = _unpack_scalar('int32_t', 'setpointValue', _data)
            _kwargs['setpointValue'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'measurementType', _data)
            _kwargs['measurementType'] = _val
            _val, _data = _unpack_scalar('int32_t', 'measurementValue', _data)
            _kwargs['measurementValue'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'gainP', _data)
            _kwargs['gainP'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'gainI', _data)
            _kwargs['gainI'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'gainD', _data)
            _kwargs['gainD'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'gainFF', _data)
            _kwargs['gainFF'] = _val
            return cls(**_kwargs), _data


class Msp2InavProgrammingPidStatus:
    CODE = 8234
    MSPV = 2
    """Retrieves the current output value of all Programming PIDs."""
    @dataclass
    class Reply:
        pidOutputs: List[int] = field(default_factory=list)

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.pidOutputs
            if not isinstance(_v, list):
                raise TypeError('pidOutputs must be list')
            if len(_v) != 4:
                raise ValueError('pidOutputs must have exactly 4 elements')
            for i, _e in enumerate(_v):
                out += _pack_scalar('int32_t', 'pidOutputs[{}]'.format(i), _e)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Reply', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            if len(_data) < 16:
                raise ValueError('not enough data to unpack pidOutputs')
            _tmp_v = []
            _tmp = _data[:16]
            for _i in range(4):
                _val, _tmp = _unpack_scalar('int32_t', 'pidOutputs[{}]'.format(_i), _tmp)
                _tmp_v.append(_val)
            _kwargs['pidOutputs'] = _tmp_v
            _data = _data[16:]
            return cls(**_kwargs), _data


class Msp2Pid:
    CODE = 8240
    MSPV = 2
    """Retrieves the standard PID controller gains (P, I, D, FF) for the current PID profile."""
    @dataclass
    class Reply:
        P: int = 0
        I: int = 0
        D: int = 0
        FF: int = 0

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.P
            out += _pack_scalar('uint8_t', 'P', _v)
            _v = self.I
            out += _pack_scalar('uint8_t', 'I', _v)
            _v = self.D
            out += _pack_scalar('uint8_t', 'D', _v)
            _v = self.FF
            out += _pack_scalar('uint8_t', 'FF', _v)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Reply', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _val, _data = _unpack_scalar('uint8_t', 'P', _data)
            _kwargs['P'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'I', _data)
            _kwargs['I'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'D', _data)
            _kwargs['D'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'FF', _data)
            _kwargs['FF'] = _val
            return cls(**_kwargs), _data


class Msp2SetPid:
    CODE = 8241
    MSPV = 2
    """Sets the standard PID controller gains (P, I, D, FF) for the current PID profile."""
    @dataclass
    class Request:
        P: int = 0
        I: int = 0
        D: int = 0
        FF: int = 0

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.P
            out += _pack_scalar('uint8_t', 'P', _v)
            _v = self.I
            out += _pack_scalar('uint8_t', 'I', _v)
            _v = self.D
            out += _pack_scalar('uint8_t', 'D', _v)
            _v = self.FF
            out += _pack_scalar('uint8_t', 'FF', _v)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Request', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _val, _data = _unpack_scalar('uint8_t', 'P', _data)
            _kwargs['P'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'I', _data)
            _kwargs['I'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'D', _data)
            _kwargs['D'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'FF', _data)
            _kwargs['FF'] = _val
            return cls(**_kwargs), _data


class Msp2InavOpflowCalibration:
    CODE = 8242
    MSPV = 2
    """Starts the optical flow sensor calibration procedure."""
    pass

class Msp2InavFwupdtPrepare:
    CODE = 8243
    MSPV = 2
    """Prepares the flight controller to receive a firmware update via MSP."""
    @dataclass
    class Request:
        firmwareSize: int = 0

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.firmwareSize
            out += _pack_scalar('uint32_t', 'firmwareSize', _v)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Request', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _val, _data = _unpack_scalar('uint32_t', 'firmwareSize', _data)
            _kwargs['firmwareSize'] = _val
            return cls(**_kwargs), _data


class Msp2InavFwupdtStore:
    CODE = 8244
    MSPV = 2
    """Stores a chunk of firmware data received via MSP."""
    @dataclass
    class Request:
        firmwareChunk: List[int] = field(default_factory=list)

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.firmwareChunk
            if not isinstance(_v, list):
                raise TypeError('firmwareChunk must be list')
            for i, _e in enumerate(_v):
                out += _pack_scalar('uint8_t', 'firmwareChunk[{}]'.format(i), _e)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Request', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _alen = hints.get('firmwareChunk_len')
            if _alen is None:
                raise ValueError('missing hint: firmwareChunk_len for variable length array')
            elem_size = 1
            total = int(_alen) * elem_size
            if len(_data) < total:
                raise ValueError('not enough data to unpack firmwareChunk')
            _tmp_v = []
            _tmp = _data[:total]
            for _i in range(int(_alen)):
                _val, _tmp = _unpack_scalar('uint8_t', 'firmwareChunk[{}]'.format(_i), _tmp)
                _tmp_v.append(_val)
            _kwargs['firmwareChunk'] = _tmp_v
            _data = _data[total:]
            return cls(**_kwargs), _data


class Msp2InavFwupdtExec:
    CODE = 8245
    MSPV = 2
    """Executes the firmware update process (flashes the stored firmware and reboots)."""
    @dataclass
    class Request:
        updateType: int = 0

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.updateType
            out += _pack_scalar('uint8_t', 'updateType', _v)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Request', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _val, _data = _unpack_scalar('uint8_t', 'updateType', _data)
            _kwargs['updateType'] = _val
            return cls(**_kwargs), _data


class Msp2InavFwupdtRollbackPrepare:
    CODE = 8246
    MSPV = 2
    """Prepares the flight controller to perform a firmware rollback to the previously stored version."""
    pass

class Msp2InavFwupdtRollbackExec:
    CODE = 8247
    MSPV = 2
    """Executes the firmware rollback process (flashes the stored backup firmware and reboots)."""
    pass

class Msp2InavSafehome:
    CODE = 8248
    MSPV = 2
    """Get or Set configuration for a specific Safe Home location."""
    @dataclass
    class Request:
        safehomeIndex: int = 0

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.safehomeIndex
            out += _pack_scalar('uint8_t', 'safehomeIndex', _v)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Request', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _val, _data = _unpack_scalar('uint8_t', 'safehomeIndex', _data)
            _kwargs['safehomeIndex'] = _val
            return cls(**_kwargs), _data

    @dataclass
    class Reply:
        safehomeIndex: int = 0
        enabled: int = 0
        latitude: int = 0
        longitude: int = 0

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.safehomeIndex
            out += _pack_scalar('uint8_t', 'safehomeIndex', _v)
            _v = self.enabled
            out += _pack_scalar('uint8_t', 'enabled', _v)
            _v = self.latitude
            out += _pack_scalar('int32_t', 'latitude', _v)
            _v = self.longitude
            out += _pack_scalar('int32_t', 'longitude', _v)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Reply', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _val, _data = _unpack_scalar('uint8_t', 'safehomeIndex', _data)
            _kwargs['safehomeIndex'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'enabled', _data)
            _kwargs['enabled'] = _val
            _val, _data = _unpack_scalar('int32_t', 'latitude', _data)
            _kwargs['latitude'] = _val
            _val, _data = _unpack_scalar('int32_t', 'longitude', _data)
            _kwargs['longitude'] = _val
            return cls(**_kwargs), _data


class Msp2InavSetSafehome:
    CODE = 8249
    MSPV = 2
    """Sets the configuration for a specific Safe Home location."""
    @dataclass
    class Request:
        safehomeIndex: int = 0
        enabled: int = 0
        latitude: int = 0
        longitude: int = 0

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.safehomeIndex
            out += _pack_scalar('uint8_t', 'safehomeIndex', _v)
            _v = self.enabled
            out += _pack_scalar('uint8_t', 'enabled', _v)
            _v = self.latitude
            out += _pack_scalar('int32_t', 'latitude', _v)
            _v = self.longitude
            out += _pack_scalar('int32_t', 'longitude', _v)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Request', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _val, _data = _unpack_scalar('uint8_t', 'safehomeIndex', _data)
            _kwargs['safehomeIndex'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'enabled', _data)
            _kwargs['enabled'] = _val
            _val, _data = _unpack_scalar('int32_t', 'latitude', _data)
            _kwargs['latitude'] = _val
            _val, _data = _unpack_scalar('int32_t', 'longitude', _data)
            _kwargs['longitude'] = _val
            return cls(**_kwargs), _data


class Msp2InavMisc2:
    CODE = 8250
    MSPV = 2
    """Retrieves miscellaneous runtime information including timers and throttle status."""
    @dataclass
    class Reply:
        uptimeSeconds: int = 0
        flightTimeSeconds: int = 0
        throttlePercent: int = 0
        autoThrottleFlag: int = 0

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.uptimeSeconds
            out += _pack_scalar('uint32_t', 'uptimeSeconds', _v)
            _v = self.flightTimeSeconds
            out += _pack_scalar('uint32_t', 'flightTimeSeconds', _v)
            _v = self.throttlePercent
            out += _pack_scalar('uint8_t', 'throttlePercent', _v)
            _v = self.autoThrottleFlag
            out += _pack_scalar('uint8_t', 'autoThrottleFlag', _v)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Reply', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _val, _data = _unpack_scalar('uint32_t', 'uptimeSeconds', _data)
            _kwargs['uptimeSeconds'] = _val
            _val, _data = _unpack_scalar('uint32_t', 'flightTimeSeconds', _data)
            _kwargs['flightTimeSeconds'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'throttlePercent', _data)
            _kwargs['throttlePercent'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'autoThrottleFlag', _data)
            _kwargs['autoThrottleFlag'] = _val
            return cls(**_kwargs), _data


class Msp2InavLogicConditionsSingle:
    CODE = 8251
    MSPV = 2
    """Gets the configuration for a single Logic Condition by its index."""
    @dataclass
    class Request:
        conditionIndex: int = 0

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.conditionIndex
            out += _pack_scalar('uint8_t', 'conditionIndex', _v)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Request', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _val, _data = _unpack_scalar('uint8_t', 'conditionIndex', _data)
            _kwargs['conditionIndex'] = _val
            return cls(**_kwargs), _data

    @dataclass
    class Reply:
        enabled: int = 0
        activatorId: int = 0
        operation: int = 0
        operandAType: int = 0
        operandAValue: int = 0
        operandBType: int = 0
        operandBValue: int = 0
        flags: int = 0

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.enabled
            out += _pack_scalar('uint8_t', 'enabled', _v)
            _v = self.activatorId
            out += _pack_scalar('int8_t', 'activatorId', _v)
            _v = self.operation
            out += _pack_scalar('uint8_t', 'operation', _v)
            _v = self.operandAType
            out += _pack_scalar('uint8_t', 'operandAType', _v)
            _v = self.operandAValue
            out += _pack_scalar('int32_t', 'operandAValue', _v)
            _v = self.operandBType
            out += _pack_scalar('uint8_t', 'operandBType', _v)
            _v = self.operandBValue
            out += _pack_scalar('int32_t', 'operandBValue', _v)
            _v = self.flags
            out += _pack_scalar('uint8_t', 'flags', _v)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Reply', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _val, _data = _unpack_scalar('uint8_t', 'enabled', _data)
            _kwargs['enabled'] = _val
            _val, _data = _unpack_scalar('int8_t', 'activatorId', _data)
            _kwargs['activatorId'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'operation', _data)
            _kwargs['operation'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'operandAType', _data)
            _kwargs['operandAType'] = _val
            _val, _data = _unpack_scalar('int32_t', 'operandAValue', _data)
            _kwargs['operandAValue'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'operandBType', _data)
            _kwargs['operandBType'] = _val
            _val, _data = _unpack_scalar('int32_t', 'operandBValue', _data)
            _kwargs['operandBValue'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'flags', _data)
            _kwargs['flags'] = _val
            return cls(**_kwargs), _data


class Msp2InavEscRpm:
    CODE = 8256
    MSPV = 2
    """Retrieves the RPM reported by each ESC via telemetry."""
    @dataclass
    class Reply:
        escRpm: int = 0

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.escRpm
            out += _pack_scalar('uint32_t', 'escRpm', _v)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Reply', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _val, _data = _unpack_scalar('uint32_t', 'escRpm', _data)
            _kwargs['escRpm'] = _val
            return cls(**_kwargs), _data


class Msp2InavEscTelem:
    CODE = 8257
    MSPV = 2
    """Retrieves the full telemetry data structure reported by each ESC."""
    @dataclass
    class Reply:
        motorCount: int = 0
        escData: List[int] = field(default_factory=list)

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.motorCount
            out += _pack_scalar('uint8_t', 'motorCount', _v)
            _v = self.escData
            if not isinstance(_v, list):
                raise TypeError('escData must be list')
            for i, _e in enumerate(_v):
                out += _pack_scalar('escSensorData_t', 'escData[{}]'.format(i), _e)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Reply', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _val, _data = _unpack_scalar('uint8_t', 'motorCount', _data)
            _kwargs['motorCount'] = _val
            _alen = hints.get('escData_len')
            if _alen is None:
                raise ValueError('missing hint: escData_len for variable length array')


class Msp2InavLedStripConfigEx:
    CODE = 8264
    MSPV = 2
    """Retrieves the full configuration for each LED on the strip using the `ledConfig_t` structure. Supersedes `MSP_LED_STRIP_CONFIG`."""
    @dataclass
    class Reply:
        ledConfig: int = 0

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.ledConfig
            out += _pack_scalar('ledConfig_t', 'ledConfig', _v)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Reply', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _val, _data = _unpack_scalar('ledConfig_t', 'ledConfig', _data)
            _kwargs['ledConfig'] = _val
            return cls(**_kwargs), _data


class Msp2InavSetLedStripConfigEx:
    CODE = 8265
    MSPV = 2
    """Sets the configuration for a single LED on the strip using the `ledConfig_t` structure. Supersedes `MSP_SET_LED_STRIP_CONFIG`."""
    @dataclass
    class Request:
        ledIndex: int = 0
        ledConfig: int = 0

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.ledIndex
            out += _pack_scalar('uint8_t', 'ledIndex', _v)
            _v = self.ledConfig
            out += _pack_scalar('ledConfig_t', 'ledConfig', _v)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Request', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _val, _data = _unpack_scalar('uint8_t', 'ledIndex', _data)
            _kwargs['ledIndex'] = _val
            _val, _data = _unpack_scalar('ledConfig_t', 'ledConfig', _data)
            _kwargs['ledConfig'] = _val
            return cls(**_kwargs), _data


class Msp2InavFwApproach:
    CODE = 8266
    MSPV = 2
    """Get or Set configuration for a specific Fixed Wing Autoland approach."""
    @dataclass
    class Request:
        approachIndex: int = 0

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.approachIndex
            out += _pack_scalar('uint8_t', 'approachIndex', _v)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Request', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _val, _data = _unpack_scalar('uint8_t', 'approachIndex', _data)
            _kwargs['approachIndex'] = _val
            return cls(**_kwargs), _data

    @dataclass
    class Reply:
        approachIndex: int = 0
        approachAlt: int = 0
        landAlt: int = 0
        approachDirection: int = 0
        landHeading1: int = 0
        landHeading2: int = 0
        isSeaLevelRef: int = 0

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.approachIndex
            out += _pack_scalar('uint8_t', 'approachIndex', _v)
            _v = self.approachAlt
            out += _pack_scalar('int32_t', 'approachAlt', _v)
            _v = self.landAlt
            out += _pack_scalar('int32_t', 'landAlt', _v)
            _v = self.approachDirection
            out += _pack_scalar('uint8_t', 'approachDirection', _v)
            _v = self.landHeading1
            out += _pack_scalar('int16_t', 'landHeading1', _v)
            _v = self.landHeading2
            out += _pack_scalar('int16_t', 'landHeading2', _v)
            _v = self.isSeaLevelRef
            out += _pack_scalar('uint8_t', 'isSeaLevelRef', _v)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Reply', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _val, _data = _unpack_scalar('uint8_t', 'approachIndex', _data)
            _kwargs['approachIndex'] = _val
            _val, _data = _unpack_scalar('int32_t', 'approachAlt', _data)
            _kwargs['approachAlt'] = _val
            _val, _data = _unpack_scalar('int32_t', 'landAlt', _data)
            _kwargs['landAlt'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'approachDirection', _data)
            _kwargs['approachDirection'] = _val
            _val, _data = _unpack_scalar('int16_t', 'landHeading1', _data)
            _kwargs['landHeading1'] = _val
            _val, _data = _unpack_scalar('int16_t', 'landHeading2', _data)
            _kwargs['landHeading2'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'isSeaLevelRef', _data)
            _kwargs['isSeaLevelRef'] = _val
            return cls(**_kwargs), _data


class Msp2InavSetFwApproach:
    CODE = 8267
    MSPV = 2
    """Sets the configuration for a specific Fixed Wing Autoland approach."""
    @dataclass
    class Request:
        approachIndex: int = 0
        approachAlt: int = 0
        landAlt: int = 0
        approachDirection: int = 0
        landHeading1: int = 0
        landHeading2: int = 0
        isSeaLevelRef: int = 0

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.approachIndex
            out += _pack_scalar('uint8_t', 'approachIndex', _v)
            _v = self.approachAlt
            out += _pack_scalar('int32_t', 'approachAlt', _v)
            _v = self.landAlt
            out += _pack_scalar('int32_t', 'landAlt', _v)
            _v = self.approachDirection
            out += _pack_scalar('uint8_t', 'approachDirection', _v)
            _v = self.landHeading1
            out += _pack_scalar('int16_t', 'landHeading1', _v)
            _v = self.landHeading2
            out += _pack_scalar('int16_t', 'landHeading2', _v)
            _v = self.isSeaLevelRef
            out += _pack_scalar('uint8_t', 'isSeaLevelRef', _v)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Request', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _val, _data = _unpack_scalar('uint8_t', 'approachIndex', _data)
            _kwargs['approachIndex'] = _val
            _val, _data = _unpack_scalar('int32_t', 'approachAlt', _data)
            _kwargs['approachAlt'] = _val
            _val, _data = _unpack_scalar('int32_t', 'landAlt', _data)
            _kwargs['landAlt'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'approachDirection', _data)
            _kwargs['approachDirection'] = _val
            _val, _data = _unpack_scalar('int16_t', 'landHeading1', _data)
            _kwargs['landHeading1'] = _val
            _val, _data = _unpack_scalar('int16_t', 'landHeading2', _data)
            _kwargs['landHeading2'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'isSeaLevelRef', _data)
            _kwargs['isSeaLevelRef'] = _val
            return cls(**_kwargs), _data


class Msp2InavGpsUbloxCommand:
    CODE = 8272
    MSPV = 2
    """Sends a raw command directly to a U-Blox GPS module connected to the FC."""
    @dataclass
    class Request:
        ubxCommand: List[int] = field(default_factory=list)

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.ubxCommand
            if not isinstance(_v, list):
                raise TypeError('ubxCommand must be list')
            for i, _e in enumerate(_v):
                out += _pack_scalar('uint8_t', 'ubxCommand[{}]'.format(i), _e)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Request', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _alen = hints.get('ubxCommand_len')
            if _alen is None:
                raise ValueError('missing hint: ubxCommand_len for variable length array')
            elem_size = 1
            total = int(_alen) * elem_size
            if len(_data) < total:
                raise ValueError('not enough data to unpack ubxCommand')
            _tmp_v = []
            _tmp = _data[:total]
            for _i in range(int(_alen)):
                _val, _tmp = _unpack_scalar('uint8_t', 'ubxCommand[{}]'.format(_i), _tmp)
                _tmp_v.append(_val)
            _kwargs['ubxCommand'] = _tmp_v
            _data = _data[total:]
            return cls(**_kwargs), _data


class Msp2InavRateDynamics:
    CODE = 8288
    MSPV = 2
    """Retrieves Rate Dynamics configuration parameters for the current control rate profile."""
    @dataclass
    class Reply:
        sensitivityCenter: int = 0
        sensitivityEnd: int = 0
        correctionCenter: int = 0
        correctionEnd: int = 0
        weightCenter: int = 0
        weightEnd: int = 0

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.sensitivityCenter
            out += _pack_scalar('uint8_t', 'sensitivityCenter', _v)
            _v = self.sensitivityEnd
            out += _pack_scalar('uint8_t', 'sensitivityEnd', _v)
            _v = self.correctionCenter
            out += _pack_scalar('uint8_t', 'correctionCenter', _v)
            _v = self.correctionEnd
            out += _pack_scalar('uint8_t', 'correctionEnd', _v)
            _v = self.weightCenter
            out += _pack_scalar('uint8_t', 'weightCenter', _v)
            _v = self.weightEnd
            out += _pack_scalar('uint8_t', 'weightEnd', _v)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Reply', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _val, _data = _unpack_scalar('uint8_t', 'sensitivityCenter', _data)
            _kwargs['sensitivityCenter'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'sensitivityEnd', _data)
            _kwargs['sensitivityEnd'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'correctionCenter', _data)
            _kwargs['correctionCenter'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'correctionEnd', _data)
            _kwargs['correctionEnd'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'weightCenter', _data)
            _kwargs['weightCenter'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'weightEnd', _data)
            _kwargs['weightEnd'] = _val
            return cls(**_kwargs), _data


class Msp2InavSetRateDynamics:
    CODE = 8289
    MSPV = 2
    """Sets Rate Dynamics configuration parameters for the current control rate profile."""
    @dataclass
    class Request:
        sensitivityCenter: int = 0
        sensitivityEnd: int = 0
        correctionCenter: int = 0
        correctionEnd: int = 0
        weightCenter: int = 0
        weightEnd: int = 0

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.sensitivityCenter
            out += _pack_scalar('uint8_t', 'sensitivityCenter', _v)
            _v = self.sensitivityEnd
            out += _pack_scalar('uint8_t', 'sensitivityEnd', _v)
            _v = self.correctionCenter
            out += _pack_scalar('uint8_t', 'correctionCenter', _v)
            _v = self.correctionEnd
            out += _pack_scalar('uint8_t', 'correctionEnd', _v)
            _v = self.weightCenter
            out += _pack_scalar('uint8_t', 'weightCenter', _v)
            _v = self.weightEnd
            out += _pack_scalar('uint8_t', 'weightEnd', _v)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Request', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _val, _data = _unpack_scalar('uint8_t', 'sensitivityCenter', _data)
            _kwargs['sensitivityCenter'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'sensitivityEnd', _data)
            _kwargs['sensitivityEnd'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'correctionCenter', _data)
            _kwargs['correctionCenter'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'correctionEnd', _data)
            _kwargs['correctionEnd'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'weightCenter', _data)
            _kwargs['weightCenter'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'weightEnd', _data)
            _kwargs['weightEnd'] = _val
            return cls(**_kwargs), _data


class Msp2InavEzTune:
    CODE = 8304
    MSPV = 2
    """Retrieves the current EZ-Tune parameters."""
    @dataclass
    class Reply:
        enabled: int = 0
        filterHz: int = 0
        axisRatio: int = 0
        response: int = 0
        damping: int = 0
        stability: int = 0
        aggressiveness: int = 0
        rate: int = 0
        expo: int = 0
        snappiness: int = 0

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.enabled
            out += _pack_scalar('uint8_t', 'enabled', _v)
            _v = self.filterHz
            out += _pack_scalar('uint16_t', 'filterHz', _v)
            _v = self.axisRatio
            out += _pack_scalar('uint8_t', 'axisRatio', _v)
            _v = self.response
            out += _pack_scalar('uint8_t', 'response', _v)
            _v = self.damping
            out += _pack_scalar('uint8_t', 'damping', _v)
            _v = self.stability
            out += _pack_scalar('uint8_t', 'stability', _v)
            _v = self.aggressiveness
            out += _pack_scalar('uint8_t', 'aggressiveness', _v)
            _v = self.rate
            out += _pack_scalar('uint8_t', 'rate', _v)
            _v = self.expo
            out += _pack_scalar('uint8_t', 'expo', _v)
            _v = self.snappiness
            out += _pack_scalar('uint8_t', 'snappiness', _v)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Reply', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _val, _data = _unpack_scalar('uint8_t', 'enabled', _data)
            _kwargs['enabled'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'filterHz', _data)
            _kwargs['filterHz'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'axisRatio', _data)
            _kwargs['axisRatio'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'response', _data)
            _kwargs['response'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'damping', _data)
            _kwargs['damping'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'stability', _data)
            _kwargs['stability'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'aggressiveness', _data)
            _kwargs['aggressiveness'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'rate', _data)
            _kwargs['rate'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'expo', _data)
            _kwargs['expo'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'snappiness', _data)
            _kwargs['snappiness'] = _val
            return cls(**_kwargs), _data


class Msp2InavEzTuneSet:
    CODE = 8305
    MSPV = 2
    """Sets the EZ-Tune parameters and triggers an update."""
    @dataclass
    class Request:
        enabled: int = 0
        filterHz: int = 0
        axisRatio: int = 0
        response: int = 0
        damping: int = 0
        stability: int = 0
        aggressiveness: int = 0
        rate: int = 0
        expo: int = 0
        snappiness: Optional[int] = None

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.enabled
            out += _pack_scalar('uint8_t', 'enabled', _v)
            _v = self.filterHz
            out += _pack_scalar('uint16_t', 'filterHz', _v)
            _v = self.axisRatio
            out += _pack_scalar('uint8_t', 'axisRatio', _v)
            _v = self.response
            out += _pack_scalar('uint8_t', 'response', _v)
            _v = self.damping
            out += _pack_scalar('uint8_t', 'damping', _v)
            _v = self.stability
            out += _pack_scalar('uint8_t', 'stability', _v)
            _v = self.aggressiveness
            out += _pack_scalar('uint8_t', 'aggressiveness', _v)
            _v = self.rate
            out += _pack_scalar('uint8_t', 'rate', _v)
            _v = self.expo
            out += _pack_scalar('uint8_t', 'expo', _v)
            if self.snappiness is None:
                pass
            else:
                _v = self.snappiness
                out += _pack_scalar('uint8_t', 'snappiness', _v)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Request', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _val, _data = _unpack_scalar('uint8_t', 'enabled', _data)
            _kwargs['enabled'] = _val
            _val, _data = _unpack_scalar('uint16_t', 'filterHz', _data)
            _kwargs['filterHz'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'axisRatio', _data)
            _kwargs['axisRatio'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'response', _data)
            _kwargs['response'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'damping', _data)
            _kwargs['damping'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'stability', _data)
            _kwargs['stability'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'aggressiveness', _data)
            _kwargs['aggressiveness'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'rate', _data)
            _kwargs['rate'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'expo', _data)
            _kwargs['expo'] = _val
            if len(_data) == 0:
                _kwargs['snappiness'] = None
            else:
                _val, _data = _unpack_scalar('uint8_t', 'snappiness', _data)
                _kwargs['snappiness'] = _val
            return cls(**_kwargs), _data


class Msp2InavSelectMixerProfile:
    CODE = 8320
    MSPV = 2
    """Selects the active mixer profile and saves configuration."""
    @dataclass
    class Request:
        mixerProfileIndex: int = 0

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.mixerProfileIndex
            out += _pack_scalar('uint8_t', 'mixerProfileIndex', _v)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Request', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _val, _data = _unpack_scalar('uint8_t', 'mixerProfileIndex', _data)
            _kwargs['mixerProfileIndex'] = _val
            return cls(**_kwargs), _data


class Msp2AdsbVehicleList:
    CODE = 8336
    MSPV = 2
    """Retrieves the list of currently tracked ADSB (Automatic Dependent SurveillanceBroadcast) vehicles. See `adsbVehicle_t` and `adsbVehicleValues_t` in `io/adsb.h` for the exact structure fields."""
    @dataclass
    class Reply:
        maxVehicles: int = 0
        callsignLength: int = 0
        totalVehicleMsgs: int = 0
        totalHeartbeatMsgs: int = 0


class Msp2InavCustomOsdElements:
    CODE = 8448
    MSPV = 2
    """Retrieves counts related to custom OSD elements defined by the programming framework."""
    @dataclass
    class Reply:
        maxElements: int = 0
        maxTextLength: int = 0
        maxParts: int = 0

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.maxElements
            out += _pack_scalar('uint8_t', 'maxElements', _v)
            _v = self.maxTextLength
            out += _pack_scalar('uint8_t', 'maxTextLength', _v)
            _v = self.maxParts
            out += _pack_scalar('uint8_t', 'maxParts', _v)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Reply', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _val, _data = _unpack_scalar('uint8_t', 'maxElements', _data)
            _kwargs['maxElements'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'maxTextLength', _data)
            _kwargs['maxTextLength'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'maxParts', _data)
            _kwargs['maxParts'] = _val
            return cls(**_kwargs), _data


class Msp2InavCustomOsdElement:
    CODE = 8449
    MSPV = 2
    """Gets the configuration of a single custom OSD element defined by the programming framework."""
    @dataclass
    class Request:
        elementIndex: int = 0

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.elementIndex
            out += _pack_scalar('uint8_t', 'elementIndex', _v)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Request', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _val, _data = _unpack_scalar('uint8_t', 'elementIndex', _data)
            _kwargs['elementIndex'] = _val
            return cls(**_kwargs), _data

    @dataclass
    class Reply:


class Msp2InavSetCustomOsdElements:
    CODE = 8450
    MSPV = 2
    """Sets the configuration of one custom OSD element."""
    @dataclass
    class Request:
        elementIndex: int = 0


class Msp2InavOutputMappingExt2:
    CODE = 8461
    MSPV = 2
    """Retrieves the full extended output mapping configuration (timer ID, full 32-bit usage flags, and pin label). Supersedes `MSP2_INAV_OUTPUT_MAPPING_EXT`."""
    @dataclass
    class Reply:
        timerId: int = 0
        usageFlags: int = 0
        pinLabel: int = 0

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.timerId
            out += _pack_scalar('uint8_t', 'timerId', _v)
            _v = self.usageFlags
            out += _pack_scalar('uint32_t', 'usageFlags', _v)
            _v = self.pinLabel
            out += _pack_scalar('uint8_t', 'pinLabel', _v)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Reply', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _val, _data = _unpack_scalar('uint8_t', 'timerId', _data)
            _kwargs['timerId'] = _val
            _val, _data = _unpack_scalar('uint32_t', 'usageFlags', _data)
            _kwargs['usageFlags'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'pinLabel', _data)
            _kwargs['pinLabel'] = _val
            return cls(**_kwargs), _data


class Msp2InavServoConfig:
    CODE = 8704
    MSPV = 2
    """Retrieves the configuration parameters for all supported servos (min, max, middle, rate). Supersedes `MSP_SERVO_CONFIGURATIONS`."""
    @dataclass
    class Reply:
        min: int = 0
        max: int = 0
        middle: int = 0
        rate: int = 0

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.min
            out += _pack_scalar('int16_t', 'min', _v)
            _v = self.max
            out += _pack_scalar('int16_t', 'max', _v)
            _v = self.middle
            out += _pack_scalar('int16_t', 'middle', _v)
            _v = self.rate
            out += _pack_scalar('int8_t', 'rate', _v)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Reply', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _val, _data = _unpack_scalar('int16_t', 'min', _data)
            _kwargs['min'] = _val
            _val, _data = _unpack_scalar('int16_t', 'max', _data)
            _kwargs['max'] = _val
            _val, _data = _unpack_scalar('int16_t', 'middle', _data)
            _kwargs['middle'] = _val
            _val, _data = _unpack_scalar('int8_t', 'rate', _data)
            _kwargs['rate'] = _val
            return cls(**_kwargs), _data


class Msp2InavSetServoConfig:
    CODE = 8705
    MSPV = 2
    """Sets the configuration parameters for a single servo. Supersedes `MSP_SET_SERVO_CONFIGURATION`."""
    @dataclass
    class Request:
        servoIndex: int = 0
        min: int = 0
        max: int = 0
        middle: int = 0
        rate: int = 0

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.servoIndex
            out += _pack_scalar('uint8_t', 'servoIndex', _v)
            _v = self.min
            out += _pack_scalar('int16_t', 'min', _v)
            _v = self.max
            out += _pack_scalar('int16_t', 'max', _v)
            _v = self.middle
            out += _pack_scalar('int16_t', 'middle', _v)
            _v = self.rate
            out += _pack_scalar('int8_t', 'rate', _v)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Request', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _val, _data = _unpack_scalar('uint8_t', 'servoIndex', _data)
            _kwargs['servoIndex'] = _val
            _val, _data = _unpack_scalar('int16_t', 'min', _data)
            _kwargs['min'] = _val
            _val, _data = _unpack_scalar('int16_t', 'max', _data)
            _kwargs['max'] = _val
            _val, _data = _unpack_scalar('int16_t', 'middle', _data)
            _kwargs['middle'] = _val
            _val, _data = _unpack_scalar('int8_t', 'rate', _data)
            _kwargs['rate'] = _val
            return cls(**_kwargs), _data


class Msp2InavGeozone:
    CODE = 8720
    MSPV = 2
    """Get configuration for a specific Geozone."""
    @dataclass
    class Request:
        geozoneIndex: int = 0

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.geozoneIndex
            out += _pack_scalar('uint8_t', 'geozoneIndex', _v)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Request', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _val, _data = _unpack_scalar('uint8_t', 'geozoneIndex', _data)
            _kwargs['geozoneIndex'] = _val
            return cls(**_kwargs), _data

    @dataclass
    class Reply:
        geozoneIndex: int = 0
        type: int = 0
        shape: int = 0
        minAltitude: int = 0
        maxAltitude: int = 0
        isSeaLevelRef: int = 0
        fenceAction: int = 0
        vertexCount: int = 0

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.geozoneIndex
            out += _pack_scalar('uint8_t', 'geozoneIndex', _v)
            _v = self.type
            out += _pack_scalar('uint8_t', 'type', _v)
            _v = self.shape
            out += _pack_scalar('uint8_t', 'shape', _v)
            _v = self.minAltitude
            out += _pack_scalar('int32_t', 'minAltitude', _v)
            _v = self.maxAltitude
            out += _pack_scalar('int32_t', 'maxAltitude', _v)
            _v = self.isSeaLevelRef
            out += _pack_scalar('uint8_t', 'isSeaLevelRef', _v)
            _v = self.fenceAction
            out += _pack_scalar('uint8_t', 'fenceAction', _v)
            _v = self.vertexCount
            out += _pack_scalar('uint8_t', 'vertexCount', _v)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Reply', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _val, _data = _unpack_scalar('uint8_t', 'geozoneIndex', _data)
            _kwargs['geozoneIndex'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'type', _data)
            _kwargs['type'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'shape', _data)
            _kwargs['shape'] = _val
            _val, _data = _unpack_scalar('int32_t', 'minAltitude', _data)
            _kwargs['minAltitude'] = _val
            _val, _data = _unpack_scalar('int32_t', 'maxAltitude', _data)
            _kwargs['maxAltitude'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'isSeaLevelRef', _data)
            _kwargs['isSeaLevelRef'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'fenceAction', _data)
            _kwargs['fenceAction'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'vertexCount', _data)
            _kwargs['vertexCount'] = _val
            return cls(**_kwargs), _data


class Msp2InavSetGeozone:
    CODE = 8721
    MSPV = 2
    """Sets the main configuration for a specific Geozone (type, shape, altitude, action). **This command resets (clears) all vertices associated with the zone.**"""
    @dataclass
    class Request:
        geozoneIndex: int = 0
        type: int = 0
        shape: int = 0
        minAltitude: int = 0
        maxAltitude: int = 0
        isSeaLevelRef: int = 0
        fenceAction: int = 0
        vertexCount: int = 0

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.geozoneIndex
            out += _pack_scalar('uint8_t', 'geozoneIndex', _v)
            _v = self.type
            out += _pack_scalar('uint8_t', 'type', _v)
            _v = self.shape
            out += _pack_scalar('uint8_t', 'shape', _v)
            _v = self.minAltitude
            out += _pack_scalar('int32_t', 'minAltitude', _v)
            _v = self.maxAltitude
            out += _pack_scalar('int32_t', 'maxAltitude', _v)
            _v = self.isSeaLevelRef
            out += _pack_scalar('uint8_t', 'isSeaLevelRef', _v)
            _v = self.fenceAction
            out += _pack_scalar('uint8_t', 'fenceAction', _v)
            _v = self.vertexCount
            out += _pack_scalar('uint8_t', 'vertexCount', _v)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Request', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _val, _data = _unpack_scalar('uint8_t', 'geozoneIndex', _data)
            _kwargs['geozoneIndex'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'type', _data)
            _kwargs['type'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'shape', _data)
            _kwargs['shape'] = _val
            _val, _data = _unpack_scalar('int32_t', 'minAltitude', _data)
            _kwargs['minAltitude'] = _val
            _val, _data = _unpack_scalar('int32_t', 'maxAltitude', _data)
            _kwargs['maxAltitude'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'isSeaLevelRef', _data)
            _kwargs['isSeaLevelRef'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'fenceAction', _data)
            _kwargs['fenceAction'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'vertexCount', _data)
            _kwargs['vertexCount'] = _val
            return cls(**_kwargs), _data


class Msp2InavGeozoneVertex:
    CODE = 8722
    MSPV = 2
    """Get a specific vertex (or center+radius for circular zones) of a Geozone."""
    @dataclass
    class Request:
        geozoneIndex: int = 0
        vertexId: int = 0

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.geozoneIndex
            out += _pack_scalar('uint8_t', 'geozoneIndex', _v)
            _v = self.vertexId
            out += _pack_scalar('uint8_t', 'vertexId', _v)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Request', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _val, _data = _unpack_scalar('uint8_t', 'geozoneIndex', _data)
            _kwargs['geozoneIndex'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'vertexId', _data)
            _kwargs['vertexId'] = _val
            return cls(**_kwargs), _data

    @dataclass
    class Reply:
        geozoneIndex: int = 0
        vertexId: int = 0
        latitude: int = 0
        longitude: int = 0
        radius: Optional[int] = None

        def pack(self) -> bytes:
            out = bytearray()
            _v = self.geozoneIndex
            out += _pack_scalar('uint8_t', 'geozoneIndex', _v)
            _v = self.vertexId
            out += _pack_scalar('uint8_t', 'vertexId', _v)
            _v = self.latitude
            out += _pack_scalar('int32_t', 'latitude', _v)
            _v = self.longitude
            out += _pack_scalar('int32_t', 'longitude', _v)
            if self.radius is None:
                pass
            else:
                _v = self.radius
                out += _pack_scalar('int32_t', 'radius', _v)
            return bytes(out)

        @classmethod
        def unpack(cls, data: bytes, **hints) -> Tuple['Reply', bytes]:
            _data = memoryview(data).tobytes()
            _kwargs: Dict[str, Any] = {}
            _val, _data = _unpack_scalar('uint8_t', 'geozoneIndex', _data)
            _kwargs['geozoneIndex'] = _val
            _val, _data = _unpack_scalar('uint8_t', 'vertexId', _data)
            _kwargs['vertexId'] = _val
            _val, _data = _unpack_scalar('int32_t', 'latitude', _data)
            _kwargs['latitude'] = _val
            _val, _data = _unpack_scalar('int32_t', 'longitude', _data)
            _kwargs['longitude'] = _val
            if len(_data) == 0:
                _kwargs['radius'] = None
            else:
                _val, _data = _unpack_scalar('int32_t', 'radius', _data)
                _kwargs['radius'] = _val
            return cls(**_kwargs), _data


class Msp2InavSetGeozoneVertex:
    CODE = 8723
    MSPV = 2
    """Sets a specific vertex (or center+radius for circular zones) for a Geozone."""
    pass

class Msp2BetaflightBind:
    CODE = 12288
    MSPV = 2
    """Initiates the receiver binding procedure for supported serial protocols (CRSF, SRXL2)."""
    pass
